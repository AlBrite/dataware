{"version":3,"file":"fGuard.min.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;;;;;;;;;;;;;;;;;;;;;;;;ACV+B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC/B;AACA,iEAAe;AACf;AACA;AACA;AACA,UAAU;AACV,UAAU;AACV,UAAU;AACV,UAAU;AACV,UAAU;AACV,UAAU;AACV,UAAU;AACV,UAAU;AACV,UAAU;AACV,UAAU;AACV;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,2BAA2B,MAAM;AACjC;AACA;AACA,iDAAiD,gBAAgB;AACjE,wBAAwB;AACxB;AACA,qBAAqB;AACrB,gBAAgB;AAChB;AACA,YAAY;AACZ;AACA;AACA;AACA;;;;;;;;;;;;;;AClEA,iEAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,4BAA4B,wBAAwB;AACpD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC,EAAC;;;;;;;;;;;;;;;;AChDK;AACP;AACA;AACA,+CAA+C,QAAQ;AACvD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACd4D;AAC7B;AACF;AAC7B;AACA,0BAA0B,+CAAM;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,iBAAiB;AAClE;AACA;AACA;AACA;AACA;AACA,kCAAkC,+CAAM;AACxC,2BAA2B,+CAAM;AACjC;AACA;AACA,8BAA8B,8CAAK,eAAe,+CAAM,kBAAkB,+CAAM;AAChF;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA,sBAAsB,+CAAM;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAK;AAClC;AACA,QAAQ,8CAAK;AACb;AACA,SAAS;AACT;AACA,QAAQ,8CAAK;AACb;AACA;AACA,mBAAmB,8CAAK;AACxB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,qCAAqC,8CAAK;AAC1C;AACA,aAAa,8CAAK;AAClB,sBAAsB,wDAAe;AACrC;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,QAAQ,8CAAK;AACb;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,8CAAK;AACzB,oBAAoB,8CAAK;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,YAAY,qCAAqC,aAAa,qHAAqH;AACnO;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,iBAAiB,8CAAK;AACtB,iBAAiB,8CAAK;AACtB;AACA,0BAA0B,wDAAe;AACzC,gDAAgD,MAAM;AACtD;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,oBAAoB,8CAAK;AACzB;AACA,wBAAwB;AACxB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,sBAAsB;AAC3C,mEAAmE,8CAAK;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8CAAK;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAK;AAClC,gBAAgB,8CAAK;AACrB;AACA;AACA,qBAAqB,8CAAK;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8CAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iBAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,qBAAqB;AAC3C,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8CAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8CAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iBAAiB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS,8CAAK;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,qBAAqB;AAC3C,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8CAAK;AACjB,0BAA0B;AAC1B;AACA,sBAAsB,8CAAK;AAC3B,0BAA0B,wDAAe;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,8CAAK;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,iBAAiB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAS,8CAAK;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,qBAAqB;AAC/C,kBAAkB;AAClB;AACA;AACA;AACA,wBAAwB,8CAAK;AAC7B,kCAAkC;AAClC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,uDAAuD,iBAAiB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,8CAAK;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,8CAAK;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,8CAAK;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,8CAAK;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,8CAAK;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,8CAAK;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,8CAAK;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8CAAK;AACjB,sBAAsB,KAAK;AAC3B;AACA;AACA;AACA,YAAY,8CAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8CAAK;AACrB;AACA,cAAc,SAAS,8CAAK;AAC5B;AACA;AACA;AACA,cAAc,SAAS,8CAAK;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8CAAK;AACrB;AACA;AACA,iBAAiB;AACjB,cAAc,SAAS,8CAAK;AAC5B;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8CAAK;AACjB;AACA,YAAY,8CAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,8CAAK,2BAA2B;AAC3E;AACA;AACA;AACA;AACA,UAAU,SAAS,8CAAK,iBAAiB,8CAAK;AAC9C;AACA;AACA;AACA,2CAA2C,8CAAK,2BAA2B;AAC3E;AACA;AACA;AACA,gBAAgB,8CAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8CAAK,qBAAqB,8CAAK;AAC3C,iBAAiB,8CAAK;AACtB,wCAAwC,8CAAK;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8CAAK;AACjB;AACA,UAAU,SAAS,8CAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,8CAAK,2BAA2B;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,8CAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8CAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,8CAAK,mBAAmB,8CAAK;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,8CAAK;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,8CAAK;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8CAAK;AACjB,8BAA8B,8CAAK;AACnC;AACA;AACA,8BAA8B,8CAAK;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wDAAe;AACrC;AACA;AACA;AACA;AACA,0BAA0B,8CAAK;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,8CAAK;AAClB,sBAAsB,wDAAe;AACrC;AACA;AACA;AACA;AACA,YAAY,8CAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8CAAK;AACjB,YAAY,8CAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,8CAAK;AAClB,aAAa,8CAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8CAAK;AACjB,YAAY,8CAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,sBAAsB;AAC1D,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yCAAyC;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,kCAAkC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,kCAAkC;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,kCAAkC;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,kCAAkC;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU,oCAAoC;AAC9C;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,8CAAK;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,8CAAK;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,8CAAK;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,8CAAK;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,8CAAK;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8CAAK;AACjB;AACA;AACA;AACA;AACA,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,8CAAK;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8CAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,GAAG,SAAS,EAAE,iBAAiB,GAAG,cAAc,GAAG,8BAA8B,GAAG,kBAAkB,EAAE,OAAO,GAAG,+BAA+B,GAAG,mCAAmC,GAAG;AAC/M;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wDAAe;AACrC,kEAAkE,cAAc;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wDAAe;AACrC,kEAAkE,cAAc;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,8CAAK;AAC/B;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,8CAAK;AAC/B;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,8CAAK;AAC/B;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,8CAAK;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8CAAK;AACjB;AACA;AACA;AACA;AACA;AACA,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8CAAK;AACjB;AACA;AACA;AACA;AACA;AACA,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,8CAAK;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,8CAAK;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,8CAAK;AAC9B;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,KAAK;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,8CAAK;AAC/B;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8CAAK,sBAAsB,8CAAK;AAC5C;AACA,8BAA8B,8CAAK;AACnC;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,8CAAK;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,WAAW;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,8CAAK;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,WAAW;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,8CAAK;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,8CAAK;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,WAAW;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,8CAAK;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,8CAAK;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8CAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wDAAe;AACrC,2DAA2D,YAAY;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kBAAkB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,8CAAK;AACrC,kCAAkC,8CAAK;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,8CAAK;AACrC,kCAAkC,8CAAK;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,8CAAK;AACrC,kCAAkC,8CAAK;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,8CAAK;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,8CAAK;AACb,gBAAgB,8CAAK;AACrB;AACA;AACA,gBAAgB,8CAAK;AACrB,uCAAuC,IAAI;AAC3C,iBAAiB;AACjB,cAAc;AACd,gBAAgB,8CAAK;AACrB,sCAAsC,8CAAK;AAC3C;AACA;AACA;AACA,uCAAuC,IAAI;AAC3C,iBAAiB;AACjB,cAAc;AACd,oBAAoB,8CAAK;AACzB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,8CAAK;AAClB;AACA;AACA,QAAQ,8CAAK;AACb;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,iBAAiB;AACjB;AACA;AACA;AACA,YAAY,8CAAK,0CAA0C,8CAAK;AAChE,iBAAiB,8CAAK;AACtB,iBAAiB,8CAAK;AACtB,iBAAiB,8CAAK;AACtB,iBAAiB,8CAAK;AACtB,iBAAiB,8CAAK;AACtB,iBAAiB,8CAAK;AACtB,iBAAiB,8CAAK;AACtB;AACA;AACA;AACA;AACA;AACA,oBAAoB,8CAAK,eAAe,8CAAK;AAC7C;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA,sBAAsB,8CAAK;AAC3B,qDAAqD,cAAc;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8CAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,qBAAqB,8CAAK;AAC1B,uCAAuC,8CAAK;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,8CAAK;AACtC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8CAAK;AACrB;AACA;AACA;AACA;AACA,qBAAqB,8CAAK;AAC1B;AACA;AACA;AACA;AACA;AACA,kDAAkD,8CAAK;AACvD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,8CAAK;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,UAAU;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,eAAe;AAC9B,eAAe,QAAQ;AACvB;AACA;AACA,YAAY,iBAAiB;AAC7B;AACA,sBAAsB,mDAAU;AAChC;AACA;AACA;AACA;AACA,oCAAoC,iBAAiB;AACrD;AACA;AACA,wBAAwB,8CAAK;AAC7B;AACA,kBAAkB,8CAAK;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,YAAY,8CAAK;AACjB;AACA;AACA,oBAAoB,8CAAK;AACzB;AACA;AACA;AACA;AACA,UAAU,SAAS,8CAAK;AACxB;AACA,oBAAoB,8CAAK;AACzB,kDAAkD,gBAAgB;AAClE;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,sBAAsB,wDAAe;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8CAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,8CAAK;AAC/B;AACA,YAAY,8CAAK;AACjB,wCAAwC,8CAAK;AAC7C,iBAAiB,8CAAK;AACtB;AACA;AACA;AACA,UAAU,SAAS,8CAAK;AACxB,iBAAiB,8CAAK;AACtB,iBAAiB,8CAAK;AACtB;AACA;AACA;AACA,kBAAkB,oDAAoD;AACtE;AACA;AACA,YAAY,8CAAK;AACjB;AACA;AACA,UAAU,SAAS,8CAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,8CAAK;AACrC,SAAS;AACT;AACA;AACA,iBAAiB,8CAAK;AACtB;AACA;AACA,yCAAyC,sBAAsB;AAC/D;AACA;AACA;AACA;AACA,YAAY,8CAAK;AACjB,kCAAkC,8CAAK;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,oBAAoB,8CAAK,4BAA4B,8CAAK;AAC1D,8BAA8B,mDAAU;AACxC;AACA;AACA,+CAA+C,8CAAK;AACpD,8BAA8B,mDAAU;AACxC;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,mCAAmC,mDAAU;AAC7C,wBAAwB,8CAAK;AAC7B;AACA;AACA,wBAAwB,8CAAK,+BAA+B,8CAAK;AACjE;AACA;AACA;AACA;AACA,wCAAwC,wDAAe;AACvD,8BAA8B,wDAAe;AAC7C;AACA;AACA;AACA;AACA;AACA,gBAAgB,8CAAK;AACrB,6CAA6C,qBAAqB;AAClE;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS,8CAAK;AAC5B;AACA;AACA,oBAAoB,8CAAK;AACzB,oDAAoD,sBAAsB;AAC1E;AACA;AACA;AACA;AACA;AACA,8DAA8D,KAAK;AACnE;AACA;AACA;AACA,0DAA0D,KAAK;AAC/D;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,0BAA0B,wDAAe;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,8CAAK;AAClB;AACA;AACA;AACA,aAAa,8CAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,8CAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8CAAK;AACjB;AACA;AACA,gBAAgB,8CAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,8CAAK;AAClB;AACA;AACA;AACA,YAAY,8CAAK;AACjB;AACA,oBAAoB,8CAAK,eAAe,+CAAM,eAAe,+CAAM,gBAAgB;AACnF;AACA;AACA,YAAY,8CAAK;AACjB;AACA;AACA,wBAAwB,8CAAK,wEAAwE;AACrG;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,8CAAK;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8CAAK,mBAAmB,8CAAK;AACzC,YAAY,8CAAK;AACjB,YAAY,8CAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF,8CAAK,iCAAiC;AAC1H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,8CAAK;AACxB;AACA;AACA,0BAA0B,SAAS;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8CAAK;AACjB,gBAAgB,8CAAK;AACrB;AACA;AACA,iBAAiB;AACjB;AACA,qBAAqB,8CAAK;AAC1B;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB,8CAAK;AACtB,YAAY,8CAAK;AACjB,oBAAoB,8CAAK,yBAAyB,8CAAK;AACvD,8BAA8B,oBAAoB;AAClD;AACA,0BAA0B,8CAAK;AAC/B;AACA;AACA,0BAA0B,8CAAK;AAC/B;AACA;AACA,aAAa;AACb;AACA;AACA,iBAAiB,8CAAK;AACtB;AACA,YAAY,8CAAK;AACjB,oBAAoB,8CAAK;AACzB;AACA;AACA;AACA;AACA,6CAA6C,KAAK,OAAO,yBAAyB;AAClF;AACA;AACA;AACA,+BAA+B,8CAAK,8BAA8B,wBAAwB;AAC1F;AACA,oBAAoB,8CAAK;AACzB;AACA;AACA;AACA,gEAAgE,KAAK,GAAG,OAAO;AAC/E;AACA;AACA;AACA;AACA;AACA,oBAAoB,8CAAK;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,MAAM;AAC9C;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACtqFa;AACb;AACA;AACA;AACA;AACA,OAAO,UAAU;AACjB,OAAO,gBAAgB;AACvB;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,aAAa,SAAS;AACtB;AACA,OAAO,SAAS;AAChB;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,eAAe;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,UAAU;AACrB;AACA,WAAW,SAAS;AACpB,aAAa;AACb;AACA,2BAA2B,oBAAoB,IAAI;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,OAAO;AACvC;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wFAAwF,qBAAM;AAC9F,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS,GAAG,SAAS;AAC5C,4BAA4B;AAC5B;AACA;AACA,WAAW,QAAQ;AACnB;AACA,aAAa,QAAQ;AACrB;AACA;AACA,SAAS,UAAU;AACnB;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,kCAAkC;AAClC,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA,WAAW,SAAS;AACpB,aAAa,QAAQ;AACrB;AACA,gCAAgC,WAAW,IAAI;AAC/C;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG,GAAG,WAAW;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B,WAAW,UAAU;AACrB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,eAAe;AACzC;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,EAAE;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA,2BAA2B,+BAA+B;AAC1D,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,IAAI;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,IAAI;AACL,IAAI,SAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,sBAAsB,SAAI;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,EAAE,+BAA+B,EAAE,iJAAiJ,GAAG,yEAAyE,EAAE;AAC/R;AACA;AACA;AACA;AACA,gBAAgB,EAAE,aAAa,EAAE,aAAa,EAAE,aAAa,EAAE,aAAa,GAAG;AAC/E;AACA;AACA;AACA;AACA,0EAA0E,IAAI,EAAE,EAAE,iCAAiC,IAAI,EAAE,EAAE,sCAAsC,IAAI,EAAE,EAAE,gDAAgD,IAAI,oBAAoB,EAAE,6FAA6F,KAAK,iDAAiD,GAAG,YAAY,IAAI;AACzZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,GAAG;AAChB,eAAe;AACf;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;ACnnCD,iEAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;AC/GD,iEAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;ACjHD,iEAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;ACzHD,iEAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;ACjHD,iEAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;ACjHD,iEAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;AC/GD,iEAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;ACjHD,iEAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;ACjHD,iEAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;ACjHD,iEAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;UCjHD;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA;WACA,CAAC;;;;;WCPD;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;ACNkC;AACC;AACC;AACpC;AACA,eAAe,oDAAU;AACzB,cAAc,mDAAU;AACxB,kBAAkB,iDAAY;AAC9B;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,2B","sources":["webpack://form-guard/webpack/universalModuleDefinition","webpack://form-guard/./src/core/config.js","webpack://form-guard/./src/core/cookie/index.js","webpack://form-guard/./src/core/exceptions/index.js","webpack://form-guard/./src/core/main/index.js","webpack://form-guard/./src/core/utils/index.js","webpack://form-guard/./src/locales/ar.js","webpack://form-guard/./src/locales/de.js","webpack://form-guard/./src/locales/en.js","webpack://form-guard/./src/locales/es.js","webpack://form-guard/./src/locales/fr.js","webpack://form-guard/./src/locales/hi.js","webpack://form-guard/./src/locales/ig.js","webpack://form-guard/./src/locales/lt.js","webpack://form-guard/./src/locales/pt.js","webpack://form-guard/./src/locales/ru.js","webpack://form-guard/webpack/bootstrap","webpack://form-guard/webpack/runtime/define property getters","webpack://form-guard/webpack/runtime/global","webpack://form-guard/webpack/runtime/hasOwnProperty shorthand","webpack://form-guard/webpack/runtime/make namespace object","webpack://form-guard/./src/index.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, () => {\nreturn ","import en from '../locales/en';\r\nimport ig from '../locales/ig';\r\nimport ar from '../locales/ar';\r\nimport de from '../locales/de';\r\nimport es from '../locales/es';\r\nimport fr from '../locales/fr';\r\nimport hi from '../locales/hi';\r\nimport lt from '../locales/lt';\r\nimport pt from '../locales/pt';\r\nimport ru from '../locales/ru';\r\n\r\nexport default { \r\n    debug: true,\r\n\r\n    locales: {\r\n        en,                 // Primary Local should come first before other locales\r\n        ig,\r\n        ar,\r\n        de,\r\n        es,\r\n        fr,\r\n        hi,\r\n        lt,\r\n        pt,\r\n        ru\r\n\r\n    },     \r\n\r\n    file_patterns: {\r\n        image: [\r\n            /^image\\/(png|gif|jpe?g)/,\r\n        ],\r\n        video: [\r\n            /^video\\/(.+?)/,\r\n        ],\r\n        pdf: [\r\n            /application\\/json/\r\n        ],\r\n        document: [\r\n            /application\\/json/\r\n        ],\r\n    },\r\n\r\n    attributes: {\r\n        // email: \"Email Address\",\r\n        // first_name: \"First Name\",\r\n        // last_name: \"Last Name\",\r\n        // phone: \"Phone Number\"\r\n    },\r\n\r\n\r\n    customRules: {\r\n        // exist: {\r\n        //     fn: async ({value}) => {\r\n        //         try {\r\n        //             const user = await fetch('/api/user_end_point', {\r\n        //                 body: JSON.stringify({username: value})\r\n        //             });\r\n        //             return user;\r\n        //         } catch(e) {}\r\n        //     },\r\n        //     message: 'User account already exists'\r\n        // },\r\n\r\n        // // add others\r\n    }\r\n}","export default {\r\n    write(name, value, expires, path, domain, secure) {\r\n        let config = {\r\n            expires: expires || Date.now() + (60 * 60 * 24 * 365),\r\n            path,\r\n            domain,\r\n            secure,\r\n        };\r\n\r\n        if (typeof expires === 'object' && expires !== null && !Array.isArray(expires)) {\r\n            config = {\r\n                ...config, ...expires\r\n            }\r\n        }\r\n        \r\n        const cookie = [name + \"=\" + encodeURIComponent(value)];\r\n\r\n        typeof config.expires === \"number\" &&\r\n            cookie.push(\"expires=\" + new Date(config.expires).toGMTString());\r\n\r\n        typeof config.path === \"string\" && cookie.push(\"path=\" + config.path);\r\n\r\n        typeof config.domain === \"string\" && cookie.push(\"domain=\" + config.domain);\r\n\r\n        config.secure === true && cookie.push(\"secure\");\r\n        \r\n        document.cookie = cookie.join(\"; \");\r\n\r\n        return value;\r\n    },\r\n\r\n\r\n    read(name) {\r\n        if (typeof name !== \"string\") return null;\r\n        const match = document.cookie.match(\r\n            new RegExp(\"(^|;\\\\s*)(\" + name + \")=([^;]*)\")\r\n        );\r\n        return match ? decodeURIComponent(match[3]) : null;\r\n    },\r\n\r\n    remove(name) {\r\n        const value = this.read(name);\r\n\r\n        if (value) {\r\n            this.write(name, \"\", Date.now() - 86400000);\r\n        }\r\n        return value;\r\n    },\r\n};\r\n","export class ValidationError extends Error {\r\n    constructor(message) {\r\n        super(message);\r\n        this.message = `[@VGuard/Validator]: ${message}`;\r\n        this.name = \"ValidationError\";\r\n    }\r\n}\r\n\r\nexport class KnownError extends EvalError {\r\n    constructor(message) {\r\n        super(message);\r\n        this.message = message;\r\n        this.name = \"KnownError\";\r\n    }\r\n}","import { ValidationError, KnownError } from \"../exceptions\";\r\nimport config from '../config';\r\nimport utils from \"../utils\";\r\n\r\nconst _keys = Object.keys(config.locales);\r\nconst system_locale = _keys.length > 0 ? _keys[0] : 'en';\r\n\r\nconst registers = {\r\n    types: [\r\n        \"blob\",\r\n        \"date\",\r\n        \"datetime\",\r\n        \"array\",\r\n        \"object\",\r\n        \"numeric\",\r\n        \"integer\",\r\n        \"string\",\r\n        \"file\",\r\n        \"files\",\r\n        \"boolean\",\r\n        \"url\",\r\n        \"ip\",\r\n        \"email\",\r\n        \"uuid\"\r\n    ],\r\n    stabilizers: [\"trim\", \"capitalize\", \"format_date\"],\r\n    fillables: [\r\n        \"if_empty\",\r\n        \"fill\",\r\n        \"fillable\",\r\n        \"nullable\",\r\n        \"required\",\r\n        \"required_if\",\r\n        \"required_unless\",\r\n        \"required_with\",\r\n        \"required_with_all\",\r\n        \"required_without\",\r\n        \"required_without_all\",\r\n    ],\r\n};\r\n\r\n\r\nexport class FormGuard {\r\n    _hasFile = false;\r\n    static locale_keys = _keys;\r\n    static locale = system_locale;\r\n    static _translations = {};\r\n    static _fallback_messages;\r\n    static _debug = false;\r\n    static user_defined_messages = {};\r\n\r\n    static registers = registers;\r\n\r\n    constructor(data, rules = null, messages = {}, attributes = {}) {\r\n        FormGuard.user_defined_messages;\r\n        console.log('testing');\r\n        this.setAttributes(attributes);\r\n        this._errors = {};\r\n        this._hasFile = false;\r\n        FormGuard._translations = config.locales;\r\n        FormGuard._debug = config.debug;\r\n        \r\n        this.loadFallbackMessages();\r\n        this._file_patterns = utils.isPlainObject(config.file_patterns) ? config.file_patterns : {};\r\n        FormGuard.user_defined_messages = {};\r\n\r\n        this._skips = [];\r\n        this._rules = {};\r\n\r\n        this._data = { ...data };\r\n\r\n        FormGuard.add(config.customRules);\r\n        FormGuard.setMessages(messages);\r\n\r\n        this.parseRules(rules);\r\n    }\r\n\r\n    init() {\r\n        FormGuard.registers = {\r\n            types: [\r\n                \"blob\",\r\n                \"date\",\r\n                \"datetime\",\r\n                \"array\",\r\n                \"object\",\r\n                \"numeric\",\r\n                \"integer\",\r\n                \"string\",\r\n                \"file\",\r\n                \"files\",\r\n                \"boolean\",\r\n            ],\r\n            stabilizers: [\"trim\", \"capitalize\", \"format_date\"],\r\n            fillables: [\r\n                \"if_empty\",\r\n                \"fill\",\r\n                \"fillable\",\r\n                \"nullable\",\r\n                \"required\",\r\n                \"required_if\",\r\n                \"required_unless\",\r\n                \"required_with\",\r\n                \"required_with_all\",\r\n                \"required_without\",\r\n                \"required_without_all\",\r\n            ],\r\n        };\r\n    \r\n\r\n    }\r\n\r\n    static log(type, ...args) {\r\n        if (this._debug && console[type]) {\r\n            console[type](...args);\r\n        }\r\n    }\r\n\r\n    static setSystemMessages(messages, name) {\r\n        this._translations = utils.castObject(this._translations);\r\n\r\n        utils.forEach(this._translations, (messages, locale) => {\r\n            delete this._translations[locale][name];\r\n        })\r\n\r\n        utils.forEach(messages, (message, key) => {\r\n            const [message_key, locale] = this.getKeys(key);\r\n            this._translations[locale] = {\r\n                ...utils.castObject(this._translations[locale]),\r\n                [message_key]:message\r\n            }\r\n        });\r\n        this._fallback_messages = this._translations[FormGuard.locale]\r\n    }\r\n\r\n    static setMessages(messages) {\r\n\r\n        this.user_defined_messages = utils.castObject(this.user_defined_messages);\r\n\r\n        if (!utils.isPlainObject(messages)) {\r\n            throw new ValidationError(\r\n                `Default Messages must be an object, but ${\r\n                    messages === null ? \"NULL\" : typeof messages\r\n                } was provided`\r\n            );\r\n        }\r\n\r\n\r\n        utils.forEach(messages, (default_message, attr) => {\r\n            const [message_key, locale] = this.getKeys(attr);\r\n\r\n            const fallback = message_key + \"$\" + system_locale;\r\n\r\n            if (locale !== system_locale) {\r\n                if (\r\n                    utils.isUndefined(messages[fallback]) &&\r\n                    utils.isUndefined(messages[message_key])\r\n                ) {\r\n                    const example = {\r\n                        ...messages,\r\n                        [message_key]: \"This is an error Message\",\r\n                    };\r\n                    this.log('warn', \r\n                        `Default message for \"${message_key}\" is missing. Defining message for ${message_key} will serve as fallback in case the user language is not available. So ensure it's written in english.\\n\\nExample:\\n${JSON.stringify(\r\n                            example\r\n                        )}`\r\n                    );\r\n                }\r\n            }\r\n            if (\r\n                !utils.isUndefined(default_message) &&\r\n                !utils.isString(default_message)\r\n            ) {\r\n                throw new ValidationError(\r\n                    `Default Message type for ${attr} is ${\r\n                        default_message === null\r\n                            ? \"NULL\"\r\n                            : typeof default_message\r\n                    }. But String was expected`\r\n                );\r\n            }\r\n\r\n            this.user_defined_messages[locale] = {\r\n                ...(utils.isPlainObject(this.user_defined_messages[locale])\r\n                    ? this.user_defined_messages[locale]\r\n                    : {}),\r\n                [message_key]: default_message,\r\n            };\r\n        });\r\n    }\r\n\r\n    //name, password, letters\r\n    //obj, attribute, rule, type\r\n    //namePasswordLetters\r\n    //namePasswordSymbols\r\n    //namePassword\r\n\r\n    getUserMessages({attribute, rule, type}, holder, defaultValue) {\r\n        const holderArgs = [attribute, rule, holder].filter(arg => utils.isString(arg));\r\n        const ruleArgs = [attribute, rule];\r\n\r\n        const getValue = (key) => {\r\n            const user_defined_messages = FormGuard.user_defined_messages[FormGuard.locale] || FormGuard.user_defined_messages.en;\r\n            return user_defined_messages?.[key];\r\n        };\r\n\r\n        defaultValue = defaultValue||\"validation.\"+rule;\r\n\r\n        const matches = [\r\n            this.snakeCase(...holderArgs),\r\n            this.snakeCase(...ruleArgs),\r\n            holderArgs.join('.'),\r\n            ruleArgs.join('.')\r\n        ]\r\n        .map(result => getValue(result))\r\n        .find(data => utils.isString(data));\r\n        \r\n\r\n        if (matches) {\r\n            return matches;\r\n        }\r\n        else {\r\n            const fallback = utils.objectGet(FormGuard._fallback_messages, rule);\r\n            if (utils.isString(fallback)) {\r\n                return fallback;\r\n            }\r\n            else if (utils.isPlainObject(fallback)) {\r\n                return fallback[holder || type] || defaultValue;\r\n            }\r\n\r\n            return defaultValue;\r\n        }\r\n        \r\n    }\r\n\r\n\r\n    static setLocale(locale) { \r\n        FormGuard.locale = locale;\r\n    }\r\n\r\n   \r\n\r\n    data(obj) {\r\n        if (utils.isPlainObject(obj)) {\r\n            this._data = obj;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    all() {\r\n        this._errors = {};\r\n        this._skips = [];\r\n\r\n        return new Promise(async (resolve, reject) => {\r\n            for (const [attribute, data] of Object.entries(this._rules)) {\r\n                for (const item of data) {\r\n                    const { args, callback } = item;\r\n                    await callback(...args);\r\n                }\r\n            }\r\n            const errorKeys = Object.keys(this._errors);\r\n\r\n            if (errorKeys.length > 0) {\r\n                return reject(this._errors);\r\n            }\r\n\r\n            const entries = Object.entries(this._data).filter(\r\n                ([key]) => !errorKeys.includes(key)\r\n            );\r\n            const validated = Object.fromEntries(entries);\r\n            const formData = this.convertDataToFormData(validated);\r\n\r\n            resolve({ validated, formData });\r\n        });\r\n    }\r\n    clearAll() {\r\n        this._errors = {};\r\n    }\r\n\r\n    only(attributes) {\r\n        if (utils.isString(attributes)) {\r\n            attributes = [attributes];\r\n        }\r\n\r\n        return new Promise(async (resolve, reject) => {\r\n            let errors = {};\r\n            let attrs = [];\r\n\r\n            if (utils.isArray(attributes)) {\r\n                attrs = attributes;\r\n                const rules = Object.entries(this._rules).filter(\r\n                    ([key]) => attrs.includes(key)\r\n                );\r\n\r\n                for (const [attribute, data] of rules) {\r\n                    // reset errors\r\n                    delete this._errors[attribute];\r\n\r\n                    for (const item of data) {\r\n                        const { args, callback } = item;\r\n                        await callback(...args);\r\n                    }\r\n                }\r\n\r\n                errors = Object.fromEntries(\r\n                    Object.entries(this._errors).filter(([key]) =>\r\n                        attrs.includes(key)\r\n                    )\r\n                );\r\n            } else if (utils.isPlainObject(attributes)) {\r\n                attrs = Object.keys(attributes);\r\n                const rules = Object.entries(this._rules).filter(\r\n                    ([key]) => attrs.includes(key)\r\n                );\r\n\r\n                for (const [attribute, data] of rules) {\r\n                    delete this._errors[attribute];\r\n                    if (attribute in attributes) {\r\n                        this._data[attribute] = attributes[attribute];\r\n                    }\r\n\r\n                    for (const item of data) {\r\n                        await item.callback(...item.args);\r\n                    }\r\n                }\r\n\r\n                errors = Object.fromEntries(\r\n                    Object.entries(this._errors).filter(([key]) =>\r\n                        attrs.includes(key)\r\n                    )\r\n                );\r\n            }\r\n\r\n            if (Object.keys(errors).length > 0) {\r\n                return reject(this._errors);\r\n            }\r\n\r\n            const entries = Object.entries(this._data).filter(([key]) =>\r\n                attrs.includes(key)\r\n            );\r\n            const validated = Object.fromEntries(entries);\r\n            const formData = this.convertDataToFormData(validated);\r\n\r\n            resolve({ validated, formData });\r\n        });\r\n    }\r\n\r\n\r\n    validate(attributes) {\r\n        attributes = attributes || this.getData();\r\n        \r\n        if (utils.isString(attributes)) {\r\n            attributes = {[attributes]:this._data[attributes]}\r\n        }\r\n            else if (!utils.isPlainObject(attributes)) {\r\n                throw new ValidationError(\r\n                    `Data should be an object`\r\n                );\r\n            }\r\n\r\n            return new Promise(async (resolve, reject) => {\r\n            try {\r\n                let errors = {};\r\n                let attrs = [];\r\n\r\n                if (utils.isArray(attributes)) {\r\n                    attrs = attributes;\r\n                    const rules = Object.entries(this._rules).filter(\r\n                        ([key]) => attrs.includes(key)\r\n                    );\r\n                    for (const [attribute, data] of rules) {\r\n                        // reset errors\r\n                        delete this._errors[attribute];\r\n\r\n                        \r\n                        for (const item of data) {\r\n                            const { args, callback } = item;\r\n                            await callback(...args);\r\n                        }\r\n                    }\r\n\r\n                    errors = Object.fromEntries(\r\n                        Object.entries(this._errors).filter(([key]) =>\r\n                            attrs.includes(key)\r\n                        )\r\n                    );\r\n                } else if (utils.isPlainObject(attributes)) {\r\n                    attrs = Object.keys(attributes);\r\n                    const rules = Object.entries(this._rules).filter(\r\n                        ([key]) => attrs.includes(key)\r\n                    );\r\n\r\n                    for (const [attribute, data] of rules) {\r\n                        delete this._errors[attribute];\r\n                        if (attribute in attributes) {\r\n                            this._data[attribute] = attributes[attribute];\r\n                        }\r\n\r\n\r\n                        for (const item of data) {\r\n                            await item.callback(...item.args);\r\n                        }\r\n                    }\r\n\r\n                    errors = Object.fromEntries(\r\n                        Object.entries(this._errors).filter(([key]) =>\r\n                            attrs.includes(key)\r\n                        )\r\n                    );\r\n                }\r\n\r\n                if (Object.keys(errors).length > 0) {\r\n                    return reject(this._errors);\r\n                }\r\n\r\n                const entries = Object.entries(this._data).filter(([key]) =>\r\n                    attrs.includes(key)\r\n                );\r\n                const validated = Object.fromEntries(entries);\r\n                const formData = this.convertDataToFormData(validated);\r\n\r\n                resolve({ validated, formData });\r\n                } catch(e) {\r\n                    FormGuard.log('error', e);\r\n\r\n                    let errors = this._errors;\r\n                    if (utils.isEmpty(errors)) {\r\n                        errors = {error:'Failed to validate'};\r\n                    }\r\n                    \r\n                    reject(errors);\r\n                }\r\n            });\r\n    }\r\n\r\n    static async make(data, rules = null, messages = {}, attributes = {}) {\r\n        const validator = new FormGuard(data, rules, messages, attributes);\r\n\r\n        return validator.validate();\r\n    }\r\n\r\n    successfully__passed__validation(obj) {\r\n        if (this.skippedValidation(obj)) return;\r\n        this.clearErrorMessage(obj);\r\n        FormGuard.log('info', 'Successfully validated '+obj.attribute)\r\n    }\r\n\r\n    /**\r\n     * TYPE RULES (types)\r\n     *\r\n     * @method blob\r\n     * @method date\r\n     * @method datetime\r\n     * @method array\r\n     * @method object\r\n     * @method numeric\r\n     * @method integer\r\n     * @method string\r\n     * @method file\r\n     * @method files\r\n     * @method boolean\r\n     * @method email\r\n     * @method uuid \r\n     * @method ip \r\n     * @method url\r\n     *\r\n     */\r\n\r\n    async blob(obj) {\r\n        const data = this.getData(obj);\r\n\r\n        this.clearIF(utils.isBlob(data), obj)\r\n    }\r\n\r\n    async date(obj) {\r\n        const data = this.getData(obj);\r\n        if (this.skippedValidation(obj)) return;\r\n        const date = new Date(data);\r\n        const validated = !isNaN(date.getFullYear());\r\n\r\n        if (validated) {\r\n            this.setData(obj, utils.format_date(date, 'yyyy-mm-dd'));\r\n        }\r\n\r\n        this.clearIF(validated, obj);\r\n\r\n    }\r\n\r\n    async datetime(obj) {\r\n        const data = this.getData(obj);\r\n        if (this.skippedValidation(obj)) return;\r\n        const date = new Date(data);\r\n        const validated = !isNaN(date.getSeconds());\r\n\r\n        if (validated) {\r\n            this.setData(obj, utils.format_date(date, 'yyyy-mm-dd H:i:s'));\r\n        }\r\n\r\n        this.clearIF(validated, obj);\r\n\r\n    }\r\n\r\n    async time(obj) {\r\n        const data = this.getData(obj);\r\n        if (this.skippedValidation(obj)) return;\r\n        const date = new Date(data);\r\n        const validated = !isNaN(date.getHours());\r\n\r\n        if (validated) {\r\n            this.setData(obj, utils.format_date(date, 'H:i:s'));\r\n        }\r\n\r\n        this.clearIF(validated, obj);\r\n\r\n    }\r\n\r\n\r\n    async timestamp(obj) {\r\n        let validated = false;\r\n        try {\r\n            const data = this.getData(obj);\r\n            const time = Date.parse(data);\r\n            validated = !isNaN(time);\r\n\r\n            if (validated) {\r\n                return this.setData(obj, time);\r\n            }\r\n\r\n        } catch(e) {};\r\n\r\n        this.clearIF(\r\n            validated,\r\n            obj\r\n        );\r\n    }\r\n\r\n    async array(obj) {\r\n        if (this.skippedValidation(obj)) return;\r\n\r\n        this.clearIF(utils.isArray(this.getData(obj)), obj);\r\n        \r\n    }\r\n\r\n    async numeric(obj) {\r\n        if (this.skippedValidation(obj)) return;\r\n\r\n        const data = this.getData(obj);\r\n        const num = utils.isNumeric(data);\r\n\r\n        this.clearIF(\r\n            num,\r\n            obj\r\n        );\r\n        if (num) {\r\n            this.setData(obj, num);\r\n        }\r\n\r\n    }\r\n\r\n    async integer(obj) {\r\n        if (this.skippedValidation(obj)) return;\r\n\r\n        const data = this.getData(obj);\r\n        const intData = utils.isInteger(data);\r\n\r\n        this.clearIF(\r\n            intData,\r\n            obj\r\n        );\r\n        if (intData) {\r\n            this.setData(obj, intData);\r\n        }\r\n\r\n    }\r\n\r\n    async string(obj) {\r\n        if (this.skippedValidation(obj)) return;\r\n        let data = this.getData(obj);\r\n\r\n        if (utils.isNumber(data)) {\r\n            data = `${data}`;\r\n        }\r\n\r\n        this.clearIF(\r\n            utils.isString(data),\r\n            obj\r\n        );\r\n        this.setData(obj, data);\r\n    }\r\n\r\n    matchFile(file, types) {\r\n        const matchPattern = (pattern) => {\r\n            if (utils.isArray(file)) {\r\n                return file.every((item) => pattern.test(item.type));\r\n            } else if (utils.isFileList(file)) {\r\n                return Array.from(file).every((item) =>\r\n                    pattern.test(item.type)\r\n                );\r\n            } else if (utils.isFile(file)) {\r\n                return pattern.test(file.type);\r\n            }\r\n            return false;\r\n        };\r\n\r\n        return types.some((type) => {\r\n            const patterns = this._file_patterns[type];\r\n\r\n            if (utils.isArray(patterns)) {\r\n                return patterns.some((pattern) => {\r\n                    return matchPattern(pattern);\r\n                });\r\n            } else if (utils.isRegExp(patterns)) {\r\n                return matchPattern(patterns);\r\n            }\r\n            return false;\r\n        });\r\n    }\r\n\r\n    async file(obj, ...types) {\r\n        if (this.skippedValidation(obj)) return;\r\n\r\n        const data = this.getData(obj);\r\n        const hasAttr = types[0] !== true;\r\n\r\n        if (\r\n            utils.isArray(data) &&\r\n            data.length > 0 &&\r\n            utils.isFile(data[data.length - 1])\r\n        ) {\r\n            const file = data[data.length - 1];\r\n\r\n            if (hasAttr && !this.matchFile(data, types)) {\r\n                return this.loadErrorMessage(\r\n                    obj,\r\n                    `File must be either ${utils.join(types, \", \", \" or \")}`\r\n                );\r\n            }\r\n\r\n            this.setData(obj, file);\r\n        } else if (utils.isFile(data) || utils.isFileList(data)) {\r\n            if (hasAttr && !this.matchFile(data, types)) {\r\n                return this.loadErrorMessage(\r\n                    obj,\r\n                    `File must be either ${utils.join(types, \", \", \" or \")}`\r\n                );\r\n            }\r\n\r\n            if (utils.isFileList(data) && data.length > 0) {\r\n                this.setData(obj, data[data.length - 1]);\r\n            }\r\n            return this.clearErrorMessage(obj);\r\n        }\r\n\r\n        this.loadErrorMessage(obj);\r\n    }\r\n\r\n    isFile(data) {\r\n        if (utils.isFileList(data) || utils.isFile(data)) return true;\r\n        else if (utils.isArray(data)) {\r\n            return data.every((file) => utils.isFile(file));\r\n        }\r\n        return false;\r\n    }\r\n\r\n    async files(obj, ...types) {\r\n        if (this.skippedValidation(obj)) return;\r\n        let data = this.getData(obj);\r\n        const hasAttr = types[0] !== true;\r\n\r\n        if (utils.isFileList(data)) {\r\n            data = Array.from(data);\r\n        } else if (utils.isFile(data)) {\r\n            data = [data];\r\n        }\r\n        this.setData(obj, data);\r\n\r\n        if (this.isFile(data)) {\r\n            if (hasAttr && !this.matchFile(data, types)) {\r\n                return this.loadErrorMessage(\r\n                    obj,\r\n                    `File must be either ${utils.join(types, \", \", \" or \")}`\r\n                );\r\n            }\r\n            return this.clearErrorMessage(obj);\r\n        }\r\n\r\n        this.loadErrorMessage(obj);\r\n    }\r\n\r\n    async boolean(obj) {\r\n        let value = this.getData(obj);\r\n        if (!utils.isBoolean(value)) {\r\n            this.loadErrorMessage(obj);\r\n        }\r\n    }\r\n\r\n    \r\n    async email(obj) {\r\n        if (this.skippedValidation(obj)) return;\r\n\r\n        const data = this.getData(obj);\r\n       \r\n        this.clearIF(\r\n            utils.isEmail(data),\r\n            obj\r\n        );\r\n    }\r\n\r\n\r\n    async uuid(obj) {\r\n        const data = this.getData(obj);\r\n        if (this.skippedValidation(obj)) return;\r\n\r\n        const validated = utils.isString(data) && utils.isUuid(data);\r\n\r\n        this.clearIF(\r\n            validated,\r\n            obj\r\n        );\r\n       \r\n    }\r\n\r\n    async url(obj) {\r\n        const data = this.getData(obj);\r\n        if (this.skippedValidation(obj)) return;\r\n        let validated = utils.isUrl(data);\r\n        \r\n        this.clearIF(\r\n            validated,\r\n            obj\r\n        );\r\n\r\n    }\r\n\r\n    async ip(obj) {\r\n        const data = this.getData(obj);\r\n        if (this.skippedValidation(obj)) return;\r\n        \r\n        const validated = utils.isIpAddress(data);\r\n\r\n        this.clearIF(\r\n            validated,\r\n            obj\r\n        );\r\n    }\r\n\r\n    /**\r\n     *\r\n     * STABILIZERS\r\n     * @method trim\r\n     * @method capitalize\r\n     * @method format_date\r\n     * */\r\n    async trim(obj) {\r\n        const value = this.getData(obj);\r\n\r\n        if (utils.isString(value)) {\r\n            this.setData(obj, utils.trim(value));\r\n        }\r\n        else {\r\n            this.setData(obj, utils.recursiveTrim(value));\r\n        }\r\n    }\r\n\r\n    async capitalize(obj, type) {\r\n        this.trim(obj);\r\n        const value = this.getData(obj);\r\n\r\n        if (value) {\r\n            if (type === \"all\") this.setData(obj, value.toUpperCase());\r\n            else if (type === \"none\") this.setData(obj, value.toLowerCase());\r\n            else\r\n                this.setData(\r\n                    obj,\r\n                    value.replace(/\\b([a-z])/g, ($1) => $1.toUpperCase())\r\n                );\r\n        }\r\n    }\r\n\r\n    async format_date(obj, format) {\r\n        if (![\"date\", \"datetime\", \"time\"].includes(obj.type)) {\r\n            throw new ValidationError(\r\n                \"format_date after declaring date, datetime or time type\"\r\n            );\r\n        }\r\n\r\n        const formatted = utils.format_date(this.getData(obj), format, obj.type);\r\n        if (formatted) {\r\n            this.setData(obj, formatted);\r\n        }\r\n        \r\n    }\r\n\r\n    /**\r\n     * FILLABLE RULES\r\n     * @method fill\r\n     * @method if_empty\r\n     * @method fillable\r\n     * @method nullable\r\n     * @method required\r\n     * @method required_if\r\n     * @method required_unless\r\n     * @method required_with\r\n     * @method required_with_all\r\n     * @method required_without\r\n     * @method required_without_all\r\n     */\r\n    async fill(obj, initial) {\r\n        const value = this.getData(obj);\r\n\r\n        if (this.empty(value)) {\r\n            this.setData(obj, initial);\r\n        }\r\n    }\r\n\r\n    async if_empty(obj, initial) {\r\n        if (!utils.isString(initial)) {\r\n            throw new ValidationError(\"if_empty argument is not accepted\");\r\n        }\r\n\r\n        const value = this.getData(obj);\r\n\r\n        if (utils.isEmpty(value)) {\r\n            this.setData(obj, initial);\r\n        }\r\n    }\r\n\r\n    async filled(obj) {\r\n        if (this.skippedValidation(obj)) return;\r\n\r\n        const data = this.getData(obj);\r\n\r\n        const matcher = [\r\n            data === undefined,\r\n            data === null,\r\n            data === \"\",\r\n            utils.isArray(data) && data.length === 0,\r\n            utils.isPlainObject(data) && data && Object.keys(data).length === 0,\r\n        ];\r\n\r\n        if (matcher.some((item) => item === true)) {\r\n            this.loadErrorMessage(obj);\r\n        }\r\n    }\r\n\r\n    async nullable(obj) {\r\n        if (this.skippedValidation(obj)) return;\r\n\r\n        if (!this.getData(obj)) {\r\n            this.setData(obj, null);\r\n            this.skipNextValidation(obj);\r\n        }\r\n    }\r\n\r\n    async required(obj) {\r\n        const data = this.getData(obj);\r\n        if (\r\n            (utils.isFile(data) && obj.type === \"file\") ||\r\n            (utils.isFileList(data) && obj.type === \"files\")\r\n        ) {\r\n            return this.clearErrorMessage(obj);\r\n        }\r\n\r\n        const matcher = [\r\n            data === undefined,\r\n            data === null,\r\n            data === \"\",\r\n            utils.isArray(data) && data.length === 0,\r\n            utils.isPlainObject(data) && Object.keys(data).length === 0,\r\n        ];\r\n\r\n        if (matcher.some((item) => item === true)) {\r\n            this.loadErrorMessage(obj);\r\n        }\r\n    }\r\n\r\n    async required_if(obj, other, value) {\r\n        if (!this.getData(obj) && this._data[other] !== value) {\r\n            this.loadErrorMessage({ ...obj, other, value });\r\n        } else {\r\n            this.clearErrorMessage(obj);\r\n        }\r\n    }\r\n\r\n    async required_unless(obj, other, ...values) {\r\n        const value = this.getData(obj);\r\n        const otherValue = this._data[other];\r\n\r\n        if (value && values.includes(otherValue)) {\r\n            return this.clearErrorMessage(obj);\r\n        }\r\n\r\n        this.loadErrorMessage({ ...obj, other, values: values.join(\",\") });\r\n    }\r\n\r\n    async required_with(obj, ...values) {\r\n        const required_files = [obj.attribute, ...values];\r\n        const value = this.getData(obj);\r\n        const valueData = required_files.map((item) => this._data[item]);\r\n\r\n        if (value && valueData.some((item) => !this.empty(item))) {\r\n            return this.clearErrorMessage(obj);\r\n        }\r\n        this.loadErrorMessage({ ...obj, values: values.join(\",\") });\r\n    }\r\n\r\n    async required_with_all(obj, ...values) {\r\n        const required_files = [obj.attribute, ...values];\r\n        const data = required_files.map((item) => this._data[item]);\r\n\r\n        if (data.some((item) => this.empty(item))) {\r\n            this.loadErrorMessage({ ...obj, values: values.join(\",\") });\r\n        }\r\n    }\r\n\r\n    async required_without(obj, ...values) {\r\n        const required_files = [obj.attribute, ...values];\r\n        const data = required_files.map((item) => this._data[item]);\r\n\r\n        if (data.every((item) => this.empty(item))) {\r\n            this.loadErrorMessage({ ...obj, values: values.join(\",\") });\r\n        }\r\n    }\r\n\r\n    async required_without_all(obj, ...values) {\r\n        const value = this.getData(obj);\r\n        const valudData = values.map((item) => this._data[item]);\r\n\r\n        if (!value && valudData.some((item) => this.empty(item))) {\r\n            this.loadErrorMessage({ ...obj, values: values.join(\",\") });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * LAST ORDER RULES (validators)\r\n     */\r\n\r\n    /**\r\n     *\r\n     * Check if a field has been accepted\r\n     *\r\n     * @see filled\r\n     *\r\n     * term: 'accepted|...'\r\n     *\r\n     * or\r\n     * term: {accepted: true, ...}\r\n     *\r\n     * or\r\n     * term: ['accepted',...]\r\n     */\r\n\r\n    accepted(obj) {\r\n        if (!this.getData(obj)) {\r\n            this.loadErrorMessage(obj);\r\n        }\r\n    }\r\n\r\n    /**\r\n     *\r\n     * Checks if the provided data has strong password features\r\n     *\r\n     * @usage\r\n     * name: 'string|password|...'\r\n     *\r\n     * or\r\n     * name: {string:true, password:true, ...}\r\n     *\r\n     * or\r\n     * name: ['string', 'password', ...]\r\n     */\r\n\r\n    async password(obj) {\r\n        const data = this.getData(obj) ?? \"\";\r\n        const patterns = {\r\n            letters: [/[a-zA-Z]/],\r\n            mixed: [/[a-z]/, /[A-Z]/],\r\n            numbers: [/[0-9]/],\r\n            symbols: [/[!@#$^&*()_+<>?\\/\\\\,.+|{}%-`~]/]\r\n        };\r\n\r\n        for(const [key, pattern] of Object.entries(patterns)) {\r\n            if (pattern.some(p => !p.test(data))) {\r\n                return this.loadErrorMessage(\r\n                    obj,\r\n                    this.getUserMessages(obj, key)\r\n                )\r\n            }\r\n        }\r\n        return this.clearErrorMessage(obj)\r\n\r\n        if (!/[a-zA-Z]/.test(data)) {\r\n            this.loadErrorMessage(\r\n                obj,\r\n                this.getUserMessages(obj, 'letters')\r\n            );\r\n        } else if (!/[a-z]/.test(data) || !/[A-Z]/.test(data)) {\r\n            this.loadErrorMessage(\r\n                obj,\r\n                this.getUserMessages(obj, 'mixed')\r\n            );\r\n        } else if (!/[0-9]/.test(data)) {\r\n            this.loadErrorMessage(\r\n                obj,\r\n                this.getUserMessages(obj, 'numbers')\r\n            );\r\n        } else if (!/[!@#$^&*()_+<>?\\/\\\\,.+|{}%-`~]/.test(data)) {\r\n            this.loadErrorMessage(\r\n                obj,\r\n                this.getUserMessages(obj, 'symbols')\r\n            );\r\n        } else if (data.length < 8) {\r\n            this.loadErrorMessage(\r\n                { ...obj, length: 8 },\r\n                this.getUserMessages(obj, 'length')\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     *\r\n     * Checks is a provided data has only alphabets\r\n     *\r\n     * @usage\r\n     * name: 'string|alpha|...'\r\n     *\r\n     * or\r\n     * name: {string:true, alpha:true, ...}\r\n     *\r\n     * or\r\n     * name: ['string', 'alpha', ...]\r\n     */\r\n\r\n    alpha(obj) {\r\n        if (this.skippedValidation(obj)) return;\r\n        this.trim(obj);\r\n        const data = this.getData(obj).toString();\r\n\r\n        const pattern = /^[a-zA-Z]+$/;\r\n\r\n        \r\n        this.clearIF(utils.isString(data) && pattern.test(data), obj)\r\n    }\r\n\r\n    clearIF(validated, obj, errorMessage) {\r\n        if (validated) {\r\n            return this.clearErrorMessage(obj);\r\n        }\r\n        this.loadErrorMessage(obj, errorMessage);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * Checks is a provided data has only alphabets and underscores\r\n     *\r\n     * @usage\r\n     * name: 'string|alpha_underscore|...'\r\n     *\r\n     * or\r\n     * name: {string:true, alpha_underscore:true, ...}\r\n     *\r\n     * or\r\n     * name: ['string', 'alpha_underscore', ...]\r\n     */\r\n\r\n    alpha_underscore(obj) {\r\n        if (this.skippedValidation(obj)) return;\r\n\r\n        this.trim(obj);\r\n        const data = this.getData(obj);\r\n        \r\n        this.clearIF(utils.isString(data) && /^[a-zA-Z_]+$/.test(data), obj)\r\n    }\r\n\r\n    /**\r\n     *\r\n     * Checks is a provided data has only alphabets and dashes\r\n     *\r\n     * @usage\r\n     * name: 'string|alpha_dash|...'\r\n     *\r\n     * or\r\n     * name: {string:true, alpha_dash:true, ...}\r\n     *\r\n     * or\r\n     * name: ['string', 'alpha_dash', ...]\r\n     */\r\n\r\n    alpha_dash(obj) {\r\n        if (this.skippedValidation(obj)) return;\r\n        this.trim(obj);\r\n        const data = this.getData(obj);\r\n\r\n        this.clearIF(utils.isString(data) && /^[a-zA-Z0-9_-]+$/.test(data), obj)\r\n    }\r\n\r\n    /**\r\n     *\r\n     * Checks is a provided data has only alphabets and numbers\r\n     *\r\n     * @usage\r\n     * name: 'string|alpha_num|...'\r\n     *\r\n     * or\r\n     * name: {string:true, alpha_num:true, ...}\r\n     *\r\n     * or\r\n     * name: ['string', 'alpha_num', ...]\r\n     */\r\n\r\n    alpha_num(obj) {\r\n        if (this.skippedValidation(obj)) return;\r\n        \r\n        this.trim(obj);\r\n\r\n        const data = this.getData(obj);\r\n\r\n        this.clearIF(utils.isString(data) && /^[a-zA-Z0-9]+$/.test(data), obj)\r\n    }\r\n\r\n    /**\r\n     *\r\n     * Checks is a provided data has only alphabets and spaces\r\n     *\r\n     * @usage\r\n     * name: 'string|alpha_spaces|...'\r\n     *\r\n     * or\r\n     * name: {string:true, alpha_spaces:true, ...}\r\n     *\r\n     * or\r\n     * name: ['string', 'alpha_spaces', ...]\r\n     */\r\n\r\n    alpha_spaces(obj) {\r\n        if (this.skippedValidation(obj)) return;\r\n       \r\n        this.trim(obj);\r\n        const data = this.getData(obj);\r\n\r\n        this.clearIF(utils.isString(data) && /^[a-zA-Z\\s]+$/.test(data), obj)\r\n    }\r\n\r\n    getSize(obj) {\r\n        const data = this.getData(obj);\r\n\r\n        if (obj.type === 'numeric') {\r\n            return [data]; \r\n        }\r\n        else if (obj.type === 'files') {\r\n            return data.map(file => file.size);\r\n        }\r\n        else if (obj.type === 'file') {\r\n            return [\r\n                data.size\r\n            ];\r\n        }\r\n        else if (obj.type === 'string' || obj.type === 'array') {\r\n            return [\r\n                data.length\r\n            ];\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * Ensures a value is between a minimum and maximum range.\r\n     * Handles numeric, string, array, and file types\r\n     *\r\n     * @usage\r\n     * age: 'between:18,45|...'\r\n     *\r\n     * or\r\n     *\r\n     * age: {between: [18, 45], ...}\r\n     *\r\n     * or\r\n     * age: ['between:18,45', ...]\r\n     */\r\n\r\n    async between(obj, min, max) {\r\n        if (this.skippedValidation(obj)) return;\r\n\r\n        min = this.parseInt(min);\r\n        max = this.parseInt(max);\r\n        const data = this.getData(obj);\r\n\r\n        min = Math.min(max, min);\r\n        max = Math.max(max, min);\r\n\r\n        const patterns = {\r\n            numeric: (data) => data < min || data > max,\r\n            string: (data) => data.length < min || data > max,\r\n            array: (data) => data.length < min || data > max,\r\n            files: (data) => data.some(file => file.size < min || file.size > max),\r\n            file: (data) => data.size < min || data.size > max\r\n        };\r\n\r\n        const fnc = patterns[obj.type];\r\n        let validated = false;\r\n\r\n        if (utils.isFunction(fnc)) {\r\n            validated = !fnc(data);\r\n        }\r\n        this.clearIF(\r\n            validated, \r\n            {...obj, min, max},\r\n            this.getUserMessages(obj)\r\n        );\r\n\r\n    }\r\n\r\n    /**\r\n     *\r\n     * Validates if the value matches another field (commonly used for password confirmation)\r\n     *\r\n     * @usage\r\n     * terms: 'confirmed|...'\r\n     *\r\n     * or\r\n     * terms: {confirmed: true, ...}\r\n     *\r\n     * or\r\n     * terms: ['confirmed', ...]\r\n     */\r\n\r\n    async confirmed(obj) {\r\n        if (this.skippedValidation(obj)) return;\r\n        let other = arguments.length > 1 ? arguments[1] : obj.attribute + '_confirmation';\r\n\r\n        const validated = utils.isString(other) && this.getData(obj) === this._data[other];\r\n\r\n        \r\n\r\n        if (!validated) {\r\n            this._skips.push(other);\r\n            this._errors[other] = this.getUserMessages(obj);\r\n        }\r\n    }\r\n\r\n    /**\r\n     *\r\n     * Checks if the value contains a specific substring\r\n     *\r\n     * @usage\r\n     * name: 'contains:bright|...'\r\n     *\r\n     * or\r\n     * name: {contains: 'bright', ...}\r\n     *\r\n     * or\r\n     * name: ['contains:bright', ...]\r\n     */\r\n\r\n    \r\n\r\n    async contains(obj, value) {\r\n        if (this.skippedValidation(obj)) return;\r\n        const data = this.getData(obj);\r\n\r\n        this.clearIF(\r\n            utils.isString(data) && data.includes(value),\r\n            obj\r\n        );\r\n    }\r\n\r\n    /**\r\n     *\r\n     * Validates a credit card number using regex patterns for various card types (Visa, MasterCard, etc.)\r\n     *\r\n     * @param {*} obj\r\n     * @returns\r\n     */\r\n\r\n    async credit_card(obj) {\r\n        const data = this.getData(obj);\r\n        if (this.skippedValidation(obj)) return;\r\n\r\n        const cardNumberRegex =\r\n            /^4[0-9]{12}(?:[0-9]{3})?$|^5[1-5][0-9]{14}$|^3[47][0-9]{13}$|^3(?:0[0-5]|[68][0-9])[0-9]{11}$|^6(?:011|5[0-9]{2})[0-9]{12}$|^35(?:2[89]|[3-8][0-9])[0-9]{12}$|^(?:2131|1800|35[2-8][0-9])[0-9]{11}$/;\r\n\r\n        this.clearIF(\r\n            cardNumberRegex.test(data),\r\n            obj\r\n        );\r\n    }\r\n\r\n    /**\r\n     *\r\n     * Validates if a date is after a certain time (e.g., after:18years)\r\n     *\r\n     * @usage\r\n     * birthdate: 'date|after:18years'\r\n     *\r\n     * or\r\n     * birthdate: {date:true, after: '18years', ...}\r\n     *\r\n     * or\r\n     * birthdate: ['date', 'before:18years', ....]\r\n     */\r\n\r\n    after(obj, after) {\r\n        if (this.skippedValidation(obj)) return;\r\n        const date = after;\r\n\r\n        const current = Date.now();\r\n\r\n        const mtch = date.match(\r\n            /^(\\d+)\\s*(year|month|day|hour|minute|second|millisecond)(s)?$/\r\n        );\r\n        if (!mtch) {\r\n            throw new ValidationError(\r\n                `Invalid Validation Rule Syntax, usage example: ${obj.attribute}: 'date|after:18years`\r\n            );\r\n        }\r\n\r\n        let value = Date.parse(this.getData(obj));\r\n        let validated = false;\r\n        if (!isNaN(value)) {\r\n            // value = new Date(value);\r\n\r\n            let [all, digits, text] = mtch;\r\n            const timers = {\r\n                year: 1000 * 60 * 60 * 24 * 365, // 1000 * 60*60*24*365\r\n                month: 1000 * 60 * 60 * 24 * 7 * 4, // 1000 * 60 * 60 * 60 * 24 * 7 * 4\r\n                week: 1000 * 60 * 60 * 24 * 7,\r\n                day: 1000 * 60 * 60 * 24,\r\n                hour: 1000 * 60 * 60,\r\n                minute: 1000 * 60,\r\n                second: 1000,\r\n                millisecond: 1,\r\n            };\r\n            digits = parseInt(digits);\r\n\r\n            if (text in timers) {\r\n                const newTime = Math.floor((current - value) / timers[text]);\r\n                validated = newTime >= digits\r\n            }\r\n        }\r\n        this.clearIF(\r\n            validated,\r\n            { ...obj, after }\r\n        );\r\n    }\r\n\r\n    /**\r\n     *\r\n     * Validates if a date is before a certain time (e.g., before:45years)\r\n     *\r\n     * @usage\r\n     * birthdate: 'date|before:45years'\r\n     *\r\n     * or\r\n     * birthdate: {date:true, before: '45years', ...}\r\n     *\r\n     * or\r\n     * birthdate ['date', 'before:45years', ...]\r\n     */\r\n\r\n    async before(obj, before) {\r\n        if (this.skippedValidation(obj)) return;\r\n        const date = before;\r\n\r\n        const current = Date.now();\r\n\r\n        const mtch = date.match(\r\n            /^(\\d+)\\s*(year|month|day|hour|minute|second|millisecond)(s)?$/\r\n        );\r\n\r\n        if (!mtch) {\r\n            throw new ValidationError(\r\n                `Invalid Validation Rule Syntax, usage example: ${obj.attribute}: 'date|before:45years`\r\n            );\r\n        }\r\n\r\n        const value = Date.parse(this.getData(obj));\r\n        let validated = false;\r\n\r\n        if (!isNaN(value)) {\r\n            let [all, digits, text] = mtch;\r\n            const timers = {\r\n                year: 1000 * 60 * 60 * 24 * 365,\r\n                month: 1000 * 60 * 60 * 24 * 7 * 4,\r\n                week: 1000 * 60 * 60 * 24 * 7,\r\n                day: 1000 * 60 * 60 * 24,\r\n                hour: 1000 * 60 * 60,\r\n                minute: 1000 * 60,\r\n                second: 1000,\r\n                millisecond: 1,\r\n            };\r\n            digits = parseInt(digits);\r\n\r\n            if (text in timers) {\r\n                const newTime = Math.floor((value - current) / timers[text]);\r\n                validated = newTime >= digits;\r\n            }\r\n        }\r\n\r\n        this.clearIF(\r\n            validated,\r\n            { ...obj, before }\r\n        );\r\n    }\r\n\r\n\r\n    /**\r\n     *\r\n     * Ensures the string ends with any of the specified values\r\n     *\r\n     */\r\n\r\n    async ends_with(obj, ...values) {\r\n        if (this.skippedValidation(obj)) return;\r\n        const data = this.getData(obj);\r\n        const pattern = values.join(\"|\") + \"$\";\r\n        const regex = new RegExp(pattern);\r\n\r\n\r\n        const validated = utils.isString(data) && regex.test(data);\r\n\r\n        this.clearIF(\r\n            validated,\r\n            { ...obj, values: values.join(\", \") }\r\n        );\r\n    }\r\n\r\n    /**\r\n     *\r\n     * Checks if the value is within a specified set of values\r\n     *\r\n     * @see in_array\r\n     */\r\n\r\n    async in(obj, ...values) {\r\n        if (this.skippedValidation(obj)) return;\r\n        const data = this.getData(obj);\r\n\r\n        const validated = utils.isPlainObject(data) && values.some(item => item in data);\r\n\r\n        this.clearIF(\r\n            validated,\r\n            { ...obj, values: values.join(\", \") }\r\n        );\r\n    }\r\n\r\n\r\n    async in_array(obj, ...values) {\r\n        if (this.skippedValidation(obj)) return;\r\n        const data = this.getData(obj);\r\n\r\n        const validated = utils.isString(data) && values.includes(data);\r\n\r\n        this.clearIF(\r\n            validated,\r\n            { ...obj, values: values.join(\", \") }\r\n        );\r\n    }\r\n\r\n    \r\n\r\n    /** */\r\n\r\n    async json(obj) {\r\n        if (this.skippedValidation(obj)) return;\r\n        const data = this.getData(obj);\r\n\r\n        let validated = false;\r\n\r\n        try {\r\n            JSON.parse(data);\r\n            validated = true;\r\n        } catch (e) {\r\n        }\r\n\r\n        this.clearIF(\r\n            validated,\r\n            obj\r\n        );\r\n    }\r\n\r\n    async lowercase(obj) {\r\n        const data = this.getData(obj);\r\n        if (this.skippedValidation(obj)) return;\r\n\r\n        const validated = utils.isString(data) && /^[a-z]+$/.test(data);\r\n\r\n        this.clearIF(\r\n            validated,\r\n            obj\r\n        );\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n    async max(obj, max) {\r\n        max = parseInt(max);\r\n        const data = this.getData(obj);\r\n\r\n        if (this.skippedValidation(obj)) return;\r\n\r\n        const patterns = {\r\n            numeric: (data) => data >= max,\r\n            string: (data) => data.length >= max,\r\n            array: (data) => data.length >= max,\r\n            files: (data) => data.some(file => file.size >= max),\r\n            file: (data) => data.size >= max\r\n        };\r\n\r\n        const fnc = patterns[obj.type];\r\n        let validated = false;\r\n\r\n        if (utils.isFunction(fnc)) {\r\n            validated = !fnc(data);\r\n        }\r\n\r\n        this.clearIF(\r\n            validated, \r\n            {...obj, min, max},\r\n            this.getUserMessages(obj)\r\n        );\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n    async mimes(obj, ...mimes) {\r\n        const data = this.getData(obj);\r\n        if (this.skippedValidation(obj)) return;\r\n\r\n        let error = false;\r\n\r\n        switch (obj.type) {\r\n            case \"file\":\r\n                error = !mimes.includes(data.type);\r\n                break;\r\n            case \"files\":\r\n                error = Array.from(data).some(\r\n                    (file) => !mimes.includes(file.type)\r\n                );\r\n                break;\r\n        }\r\n\r\n        this.clearIF(\r\n            !error,\r\n            { ...obj, mimes: mimes.join(\", \") }\r\n        );\r\n\r\n    }\r\n\r\n    async min(obj, min) {\r\n        if (this.skippedValidation(obj)) return;\r\n\r\n        min = this.parseInt(min);\r\n        const data = this.getData(obj);\r\n\r\n        const patterns = {\r\n            numeric: (data) => data < max,\r\n            string: (data) => data.length < max,\r\n            array: (data) => data.length < max,\r\n            files: (data) => data.some(file => file.size < max),\r\n            file: (data) => data.size < max\r\n        };\r\n\r\n        const fnc = patterns[obj.type];\r\n        let validated = false;\r\n\r\n        if (utils.isFunction(fnc)) {\r\n            validated = !fnc(data);\r\n        }\r\n\r\n        this.clearIF(\r\n            validated, \r\n            {...obj, min, max},\r\n            this.getUserMessages(obj)\r\n        );\r\n\r\n    }\r\n\r\n    async multiple_of(obj, number) {\r\n        number = parseFloat(number);\r\n        const data = this.getData(obj);\r\n        if (this.skippedValidation(obj)) return;\r\n\r\n        const validated = utils.isNumber(data) && data % number === 0;\r\n\r\n        this.clearIF(\r\n            validated,\r\n            obj\r\n        );\r\n    }\r\n\r\n    async not_contains(obj, value) {\r\n        const data = this.getData(obj);\r\n        if (this.skippedValidation(obj)) return;\r\n\r\n        const validated = utils.isString(data) && !data.includes(value);\r\n\r\n        this.clearIF(\r\n            validated,\r\n            obj\r\n        );\r\n    }\r\n\r\n    async not_in(obj, ...values) {\r\n        if (this.skippedValidation(obj)) return;\r\n        const data = this.getData(obj);\r\n\r\n        const validate = utils.isPlainObject(data) && values.every(value => !(value in data))\r\n\r\n        this.clearIF(\r\n            validated,\r\n            { ...obj, values: values.join(\", \") }\r\n        );\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n    async phone(obj) {\r\n        if (this.skippedValidation(obj)) return;\r\n        const data = this.getData(obj);\r\n\r\n        const phoneRegex = /^\\+?[1-9]\\d{1,14}$/;\r\n\r\n        this.clearIF(\r\n            phoneRegex.test(data),\r\n            obj\r\n        );\r\n    }\r\n\r\n\r\n\r\n    async range(obj, min, max) {\r\n        min = this.parseInt(min);\r\n        max = this.parseInt(max);\r\n        const data = this.getData(obj);\r\n\r\n        if (this.skippedValidation(obj)) return;\r\n\r\n        const validated = utils.isNumber(data) && data >= min && data <= max;\r\n\r\n        this.clearIF(\r\n            validated,\r\n            {...obj, min, max}\r\n        );\r\n\r\n    }\r\n\r\n\r\n    async regex(obj, pattern) {\r\n        if (this.skippedValidation(obj)) return;\r\n        const data = this.getData(obj);\r\n        let validated = false;\r\n\r\n        if (utils.isRegExp(pattern) || utils.isString(data)) {\r\n            try {\r\n                const regex = utils.isRegExp(pattern) ? pattern : new RegExp(pattern);\r\n\r\n                validated = regex.test(data);\r\n            } catch(e) {}\r\n        }\r\n\r\n        this.clearIF(\r\n            validated,\r\n            {...obj, pattern}\r\n        );\r\n\r\n    }\r\n\r\n    async same(obj, other) {\r\n        if (this.skippedValidation(obj)) return;\r\n\r\n        this.clearIF(\r\n            this.getData(obj) !== this._data[other],\r\n            {...obj, other}\r\n        );\r\n    }\r\n\r\n\r\n\r\n\r\n    async starts_with(obj, ...values) {\r\n        if (this.skippedValidation(obj)) return;\r\n        const data = this.getData(obj);\r\n        const pattern = \"^\" + values.join(\"|\");\r\n        let validated = false;\r\n\r\n        try {\r\n            const regex = new RegExp(pattern);\r\n            validated = regex.test(data);\r\n        } catch(e) {}\r\n\r\n        this.clearIF(\r\n            validated,\r\n            { ...obj, values: values.join(\", \") }\r\n        );\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n    async timezone(obj) {\r\n        if (this.skippedValidation(obj)) return;\r\n        const data = this.getData(obj);\r\n\r\n        const validTimezones = Intl.supportedValuesOf(\"timeZone\");\r\n        const validated = validTimezones.includes(data);\r\n\r\n        this.clearIF(\r\n            validated,\r\n            obj\r\n        );\r\n    }\r\n\r\n    async uppercase(obj) {\r\n        if (this.skippedValidation(obj)) return;\r\n        const data = this.getData(obj);\r\n\r\n        const validated = utils.isString(data) && /^[A-Z]+$/.test(data);\r\n\r\n        this.clearIF(\r\n            validated,\r\n            obj\r\n        );\r\n    }\r\n\r\n    \r\n\r\n\r\n    async gt(obj, gt) {\r\n        if (this.skippedValidation(obj)) return;\r\n        gt = this.parseInt(gt, `gt argument expects a number but ${typeof gt} was provided`);\r\n        const data = this.getData(obj);\r\n\r\n        let error = false;\r\n        switch (obj.type) {\r\n            case \"numeric\":\r\n                error = data <= gt;\r\n                break;\r\n            case \"file\":\r\n                error = utils.isFile(data) ? 1 <= gt : data.length <= gt;\r\n                break;\r\n            case \"string\":\r\n            case \"array\":\r\n                error = data.length <= gt;\r\n                break;\r\n        }\r\n\r\n        \r\n        this.clearIF(\r\n            !error,\r\n            {...obj, gt},\r\n            this.getUserMessages(obj)\r\n        );\r\n\r\n    }\r\n\r\n    async gte(obj, gte) {\r\n        gte = parseInt(gte);\r\n        const data = this.getData(obj);\r\n\r\n        if (this.skippedValidation(obj)) return;\r\n\r\n        let error = false;\r\n        switch (obj.type) {\r\n            case \"numeric\":\r\n                error = data < gte;\r\n                break;\r\n            case \"file\":\r\n                error = utils.isFile(data) ? 1 < gte : data.length < gte;\r\n                break;\r\n            case \"string\":\r\n            case \"array\":\r\n                error = data.length < gte;\r\n                break;\r\n        }\r\n\r\n        this.clearIF(\r\n            !error,\r\n            {...obj, gte},\r\n            this.getUserMessages(obj)\r\n        );\r\n    }\r\n\r\n    async lt(obj, lt) {\r\n        lt = parseInt(lt);\r\n        const data = this.getData(obj);\r\n\r\n        if (this.skippedValidation(obj)) return;\r\n\r\n        let error = false;\r\n        switch (obj.type) {\r\n            case \"numeric\":\r\n                error = data >= lt;\r\n                break;\r\n            case \"file\":\r\n                error = utils.isFile(data) ? 1 >= lt : data.length >= lt;\r\n                break;\r\n            case \"string\":\r\n            case \"array\":\r\n                error = data.length >= lt;\r\n                break;\r\n        }\r\n\r\n        this.clearIF(\r\n            !error,\r\n            {...obj, lt},\r\n            this.getUserMessages(obj)\r\n        );\r\n    }\r\n\r\n    async lte(obj, lte) {\r\n        lte = parseInt(lte);\r\n        const data = this.getData(obj);\r\n\r\n        if (this.skippedValidation(obj)) return;\r\n\r\n        let error = false;\r\n        switch (obj.type) {\r\n            case \"numeric\":\r\n                error = data > lte;\r\n                break;\r\n            case \"file\":\r\n                error = utils.isFile(data) ? 1 > lte : data.length > lte;\r\n                break;\r\n            case \"string\":\r\n            case \"array\":\r\n                error = data.length > lte;\r\n                break;\r\n        }\r\n\r\n        this.clearIF(\r\n            !error,\r\n            {...obj, lte},\r\n            this.getUserMessages(obj)\r\n        );\r\n    }\r\n\r\n    async active_url(obj) {\r\n        const data = this.getData(obj);\r\n\r\n        if (this.skippedValidation(obj)) return;\r\n\r\n        let validated = utils.isString(data) && /^https?:\\/\\//.test(data);\r\n\r\n        if (validated) {\r\n            validated = false;\r\n            try {\r\n                await fetch(this.getData(obj));\r\n                validated = true;\r\n            } catch (e) {}\r\n        }\r\n\r\n        this.clearIF(\r\n            validated, \r\n            obj\r\n        );\r\n    }\r\n\r\n    parseInt(num, message) {\r\n        if (utils.isNumber(num)) {\r\n            return str;\r\n        }\r\n\r\n        const parsed = parseInt(num);\r\n\r\n        if (isNaN(parsed)) {\r\n            throw new ValidationError(\r\n                message || `Number type was expected but ${typeof num} was provided`\r\n            )\r\n        }\r\n\r\n        return parsed;\r\n    }\r\n\r\n    async digits(obj, digits) {\r\n        digits = this.parseInt(digits);\r\n        \r\n        let data = `${this.getData(obj)}`;\r\n\r\n        const validated = data.length === digits;\r\n    \r\n        this.clearIF(\r\n            validated,\r\n            obj\r\n        );\r\n    }\r\n\r\n    \r\n    async image(obj) {\r\n        if (this.skippedValidation(obj)) return;\r\n\r\n        const data = this.getData(obj);\r\n\r\n        const isImage = (type) => this._file_patterns.image.some(pattern => pattern.test(type));\r\n\r\n        if ([\"file\", \"files\"].includes(obj.type)) {\r\n            const fileIsImage = utils.isFile(data) && isImage(data.type);\r\n            const filesAreImage = utils.isArray(data) && data.every((item) => isImage(item.type));\r\n\r\n            validated = fileIsImage || filesAreImage;\r\n        }\r\n\r\n        this.clearIF(\r\n            validated,\r\n            obj\r\n        );\r\n    }\r\n\r\n    audio(obj) {\r\n        if (this.skippedValidation(obj)) return;\r\n\r\n        const data = this.getData(obj);\r\n\r\n        const isAudio = (type) => this._file_patterns.audio.some(pattern => pattern.test(type));\r\n\r\n        if ([\"file\", \"files\"].includes(obj.type)) {\r\n            const fileIsAudio = utils.isFile(data) && isAudio(data.type);\r\n            const filesAreAudio = utils.isArray(data) && data.every((item) => isAudio(item.type));\r\n\r\n            validated = fileIsAudio || filesAreAudio;\r\n        }\r\n\r\n        this.clearIF(\r\n            validated,\r\n            obj\r\n        );\r\n    }\r\n\r\n    async video(obj) {\r\n        if (this.skippedValidation(obj)) return;\r\n\r\n        const data = this.getData(obj);\r\n\r\n        const isVideo = (type) => this._file_patterns.video.some(pattern => pattern.test(type));\r\n\r\n        if ([\"file\", \"files\"].includes(obj.type)) {\r\n            const fileIsVideo = utils.isFile(data) && isVideo(data.type);\r\n            const filesAreVideo = utils.isArray(data) && data.every((item) => isVideo(item.type));\r\n\r\n            validated = fileIsVideo || filesAreVideo;\r\n        }\r\n\r\n        this.clearIF(\r\n            validated,\r\n            obj\r\n        );\r\n    }\r\n\r\n\r\n\r\n\r\n    async pattern(obj, pattern) {\r\n        if (this.skippedValidation(obj)) return;\r\n\r\n        const indicators = {\r\n            z: /^[a-z]$/,\r\n            Z: /^[A-Z]$/,\r\n            a: /^[a-z]$/,\r\n            A: /^[A-Z]$/,\r\n            0: /^[0-9]$/,\r\n            9: /^[0-9]$/,\r\n            \"*\": /^[a-zA-Z0-9]$/,\r\n        };\r\n\r\n        let data = this.getData(obj);\r\n\r\n        let validated = false;\r\n\r\n        if (data) {\r\n            const splitData = utils.trim(data.toString()).split(\"\");\r\n            const splitPattern = pattern.split(\"\");\r\n\r\n            if (splitPattern.length === splitData.length) {\r\n                validated = splitPattern.every((pattern, i) => {\r\n                    return (\r\n                        (!indicators[pattern] && pattern === splitData[i]) ||\r\n                        (indicators[pattern] &&\r\n                            indicators[pattern].test(splitData[i]))\r\n                    );\r\n                });\r\n\r\n                \r\n            }\r\n        }\r\n\r\n        this.clearIF(\r\n            validated,\r\n            {...obj, pattern}\r\n        )\r\n\r\n    }\r\n\r\n    \r\n\r\n    hasFile() {\r\n        return this._hasFile;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * Converts regular data into FormData,\r\n     * which is often required for file uploads\r\n     * or sending data in POST requests\r\n     *\r\n     * @param {*} data\r\n     * @returns\r\n     */\r\n\r\n    convertDataToFormData(data) {\r\n        const formData = new FormData();\r\n\r\n        utils.forEach(data, (value, key) => {\r\n            if (utils.isFileList(value)) {\r\n                this._hasFile = true;\r\n\r\n                utils.forEach(Array.from(value), (file) => {\r\n                    formData.append(`${key}[]`, file);\r\n                });\r\n            } else if (\r\n                utils.isArray(value) &&\r\n                value.every((file) => utils.isFile(file))\r\n            ) {\r\n                this._hasFile = true;\r\n                value.forEach((file) => {\r\n                    formData.append(`${key}[]`, file);\r\n                });\r\n            } else {\r\n                if (utils.isFile(value)) {\r\n                    this._hasFile = true;\r\n                }\r\n                formData.append(key, value);\r\n            }\r\n        });\r\n\r\n        return formData;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * Loops through the rules and applies the necessary validation for each attribute\r\n     */\r\n\r\n    parseRules(rules) {\r\n        if (!utils.isPlainObject(rules)) {\r\n            throw new TypeError(\"Argement 2 (rules) must be an object\");\r\n        }\r\n        utils.forEach(rules, (rule, attribute) => {\r\n            this.start({\r\n                rule,\r\n                attribute,\r\n            });\r\n        });\r\n        \r\n    }\r\n\r\n    /**\r\n     * Infers the type of the data (e.g., array, object, numeric, file, etc.)\r\n     *\r\n     * @param {*} data\r\n     * @returns {String}\r\n     */\r\n\r\n    detectType(data) {\r\n        if (utils.isArray(data)) return data.every(item => utils.isFile(item)) ? \"files\":\"array\";\r\n        else if (utils.isBlob(data)) return \"blob\";\r\n        else if (utils.isPlainObject(data)) return \"object\";\r\n        else if (utils.isNumber(data)) return \"numeric\";\r\n        else if (utils.isBoolean(data)) return \"boolean\";\r\n        else if (utils.isFile(data)) return \"file\";\r\n        else if (utils.isFileList(data)) return \"files\";\r\n        else if (utils.isString(data)) return \"string\";\r\n        else {\r\n            const date = new Date(data);\r\n            if (!isNaN(date.getFullYear())) return 'date';\r\n            try {\r\n                let d = JSON.parse(data);\r\n                if (utils.isArray(d) || utils.isObject(d)) return 'json';\r\n                return typeof d;\r\n            } catch(e){}\r\n        }\r\n        return \"any\";\r\n    }\r\n\r\n    /**\r\n     * Orders the properties of an array or object based on specified patterns.\r\n     *\r\n     * @param {Array|Object} input - The array or object to be categorized and ordered.\r\n     * @param {Object} patterns - The patterns to categorize the properties.\r\n     * @param {Object} defaults - The default values to ensure presence if necessary.\r\n     * @returns {Array|Object} - A new array or object with properties ordered according to the patterns.\r\n     */\r\n    orderRules(attribute, input) {\r\n\r\n        const order = utils.memorize(() => {\r\n            const Pattern = (arr) => new RegExp(`^(${arr.join(\"|\")})$`);\r\n            const patterns = {\r\n                types: Pattern(FormGuard.registers.types),\r\n                stabilizers: Pattern(FormGuard.registers.stabilizers),\r\n                fillables: Pattern(FormGuard.registers.fillables),\r\n            };\r\n    \r\n    \r\n            if (utils.isString(input)) {\r\n                const rules = {};\r\n                const split = input.split(\"|\");\r\n                split.forEach((item) => {\r\n                    let [rule, args] = item.split(\":\");\r\n                    args = !args ? true : args.split(\",\");\r\n                    rules[rule] = args.length === 0 ? true : args;\r\n                });\r\n    \r\n                return this.orderRules(attribute, rules);\r\n            }\r\n            else if (utils.isArray(input)) {\r\n                if (input.some(item => utils.isString(item) && item.indexOf(':') > 0)) {\r\n                    input = this.arrayToObject(input);\r\n                }                        \r\n            }\r\n\r\n\r\n    \r\n            const categorized = this.categorizeRules(input, patterns);\r\n    \r\n            const orderedRules = utils.isArray(input)\r\n                ? this.createOrderedArray(categorized)\r\n                : this.createOrderedObject(categorized, input);\r\n    \r\n    \r\n            return orderedRules;\r\n        }, attribute);\r\n        return order();\r\n        \r\n    }\r\n\r\n    arrayToObject(input) {\r\n        const obj = {};\r\n\r\n        input.forEach(item => {\r\n            if (utils.isFunction(item)) {\r\n            \r\n                let name = item.name || 'anonymous';\r\n                obj[name] = item;\r\n            }\r\n            else if (utils.isString(item)) {\r\n                const splt = item.split(\":\");\r\n                let name = splt[0];\r\n                let args = true;\r\n\r\n                if (splt.length > 1) {\r\n                    args = splt[1].split(',').map(utils.normalize);\r\n                }\r\n                obj[name] = args;              \r\n            }\r\n        });\r\n        return obj;\r\n    }\r\n\r\n    categorizeRules(input, patterns) {\r\n        const categorized = {\r\n            types: [],\r\n            stabilizers: [],\r\n            fillables: [],\r\n            others: [],\r\n        };\r\n\r\n        (utils.isArray(input) ? input : Object.keys(input)).forEach((item) => {\r\n            let matched = false;\r\n            for (const [key, pattern] of Object.entries(patterns)) {\r\n                if (item && pattern.test(item)) {\r\n                    categorized[key].push(item);\r\n                    matched = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!matched) categorized.others.push(item);\r\n        });\r\n\r\n        return categorized;\r\n    }\r\n\r\n    createOrderedArray(categorized) {\r\n        let order = [];\r\n\r\n        [\"fillables\", \"types\", \"stabilizers\"].forEach((key) => {\r\n            if (categorized[key] && categorized[key].length > 0) {\r\n                order.push(\r\n                    key === \"stabilizers\"\r\n                        ? categorized.stabilizers[0]\r\n                        : categorized[key][0]\r\n                );\r\n            }\r\n        });\r\n\r\n        return [\r\n            ...order,\r\n            ...categorized.others,\r\n            \"successfully__passed__validation\",\r\n        ];\r\n    }\r\n\r\n    createOrderedObject(categorized, input) {\r\n        const orders = {};\r\n\r\n        [\"fillables\", \"types\", \"stabilizers\"].forEach((order) => {\r\n            const item = categorized[order].map((key) => [\r\n                key,\r\n                input[key] || true,\r\n            ]);\r\n\r\n            if (item.length > 0) {\r\n                Object.assign(\r\n                    orders,\r\n                    Object.fromEntries(\r\n                        order === \"stabilizers\" ? item : [item[0]]\r\n                    )\r\n                );\r\n            }\r\n        });\r\n\r\n        return {\r\n            ...orders,\r\n            ...Object.fromEntries(\r\n                categorized.others.map((key) => [key, input[key]])\r\n            ),\r\n            successfully__passed__validation: true,\r\n        };\r\n    }\r\n\r\n    appendRule(attribute, rule, callback, methodArgs) {\r\n        const [method, arg] = methodArgs;\r\n        const args = methodArgs;\r\n        if (method === 'fill' && arg.length > 0) {\r\n            return this.setData({attribute}, arg[0]);\r\n        }\r\n        if (!(attribute in this._rules)) {\r\n            this._rules[attribute] = [];\r\n        }\r\n        if (rule.length === 0) {\r\n            rule = \"custom\";\r\n        }\r\n\r\n\r\n        this._rules[attribute].push({\r\n            rule,\r\n            callback,\r\n            methodArgs,\r\n            args,\r\n            arg\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Starts the validation process for a given rule and attribute.\r\n     *\r\n     * @param {Object} config - Configuration object containing rule and attribute.\r\n     * @param {string|Object} config.rule - Validation rule or rules to process.\r\n     * @param {string} config.attribute - The attribute to validate.\r\n     */\r\n\r\n    start({ rule, attribute }) {\r\n        const fail = (message) => {\r\n            throw new KnownError(message);\r\n        };\r\n\r\n        rule = this.orderRules(attribute, rule);\r\n\r\n        let type = this.inferType({ rule, attribute });\r\n\r\n        const processItem = async (method, args) => {\r\n            const fnc = utils.isFunction(method)\r\n                ? method\r\n                : utils.isFunction(args)\r\n                ? args\r\n                : false;\r\n\r\n            if ([\"integer\"].includes(type)) {\r\n                type = \"numeric\";\r\n            }\r\n\r\n            return await this.enact({\r\n                method,\r\n                fnc,\r\n                args,\r\n                fail,\r\n                attribute,\r\n                type,\r\n            });\r\n        };\r\n\r\n        if (utils.isArray(rule)) {\r\n            for (const method of rule) {\r\n                let rule = method;\r\n                if (utils.isFunction(method)) {\r\n                    rule = method.name;\r\n                }\r\n                this.appendRule(attribute, rule, processItem, [method]);\r\n            }\r\n        } else if (utils.isPlainObject(rule)) {\r\n            for (const [method, args] of Object.entries(rule)) {\r\n                if (utils.isFunction(args)) {\r\n                    // FormGuard.addCustomRules({ [method]: args });\r\n                }\r\n\r\n\r\n                this.appendRule(attribute, method, processItem, [method, args]);\r\n            }\r\n        } else {\r\n            throw new ValidationError(\"Failed to process validation rules\");\r\n        }\r\n    }\r\n\r\n    inferType(obj) {\r\n        const types = FormGuard.registers.types;\r\n\r\n        const matchedType = (\r\n            utils.isArray(obj.rule) ? obj.rule : Object.keys(obj.rule)\r\n        ).find((item) => types.includes(item));\r\n\r\n        if (matchedType) {\r\n            return matchedType;\r\n        }\r\n        const data = this.getData(obj);\r\n        const isNumeric = utils.isNumeric(data);\r\n\r\n        if (utils.isArray(data))\r\n            return data.every((file) => utils.isFile(file)) ? \"files\" : \"array\";\r\n        else if (utils.isPlainObject(data)) return \"object\";\r\n        else if (isNumeric) {\r\n            this.setData(obj, isNumeric);\r\n            return \"numeric\";\r\n        } else if (utils.isFile(data)) return \"file\";\r\n        else if (utils.isFileList(data)) return \"files\";\r\n        else if (utils.isString(data)) return \"string\";\r\n        return \"any\";\r\n    }\r\n\r\n    async enact({ method, attribute, args, fnc, type, required, fail }) {\r\n        let rule = method;\r\n\r\n        if (utils.isString(method) && method.indexOf(\":\") >= 0) {\r\n            [rule, args] = method.split(\":\");\r\n            args = args.split(\",\");\r\n        } else if (utils.isFunction(method)) {\r\n\r\n            rule = method.name || 'anonymous';\r\n        }\r\n\r\n\r\n        let message = `validation.${\r\n            rule || \"custom\" + (utils.isFunction(method) ? \"Callback\" : \"Rule\")\r\n        }`;\r\n\r\n        const errorMessage = (msg) => {\r\n            if (!utils.isString(rule)) {\r\n                return message;\r\n            }\r\n            return this.getUserMessages({attribute, type, rule}, null, msg || message);\r\n        };\r\n\r\n        let parameters = [];\r\n        \r\n        if (utils.isArray(args)) {\r\n            parameters = args.map(utils.normalize);\r\n        }\r\n\r\n        const apply_callback = async (fnc, message) => {\r\n            try {\r\n                let response = await fnc({\r\n                    query: this._data,\r\n                    value: this._data[attribute],\r\n                    parameters,\r\n                    message,\r\n                    type,\r\n                    attribute,\r\n                    fail,\r\n                });\r\n\r\n\r\n                if (utils.isPlainObject(response) && utils.isString(response[FormGuard.locale])) {\r\n                    throw new KnownError(response[FormGuard.locale]);\r\n                }\r\n\r\n                else if (response === false || utils.isString(response)) {\r\n                    throw new KnownError(response || errorMessage());\r\n                }\r\n\r\n                return response;\r\n            } catch (err) {\r\n                this._errors[attribute] = errorMessage();\r\n\r\n                if (err instanceof KnownError) {\r\n                    if (utils.isString(err.message)) {\r\n                        this._errors[attribute] = errorMessage(err.message);\r\n                    }\r\n                    if (utils.isPlainObject(err.message) && utils.isString(err.message[FormGuard.locale])) {\r\n                        this._errors[attribute] = errorMessage(err.message[FormGuard.locale]);\r\n                    }\r\n                }\r\n                \r\n                else if (err instanceof ValidationError) {\r\n                    throw new ValidationError(err.message);\r\n                } \r\n            }\r\n        };\r\n\r\n        try {\r\n            if (utils.isFunction(fnc)) {\r\n                if (this.skippedValidation({ attribute, required })) return;\r\n\r\n                await apply_callback(fnc, message);\r\n            } else if (rule && rule in this) {\r\n                args = [\r\n                    {\r\n                        rule,\r\n                        method: rule,\r\n                        attribute,\r\n                        type,\r\n                        required,\r\n                        fail,\r\n                    },\r\n                ].concat(args);\r\n                const fun = this[rule];\r\n\r\n                await fun.apply(this, args);\r\n\r\n                // this[rule].apply(this, args);\r\n            } else if (utils.isString(rule) && rule in FormGuard) {\r\n                let matched = false;\r\n\r\n                if (utils.isFunction(FormGuard[rule])) {\r\n                    message = this.getUserMessages({attribute, rule, type});\r\n                    \r\n                    await apply_callback(FormGuard[rule], message);\r\n                    matched = true;\r\n                }\r\n                if (!matched) {\r\n                    FormGuard.log(\"warn\", `Validation Rule \"${rule}\" is not valid`);\r\n                }\r\n            }\r\n            else {\r\n                FormGuard.log(\"warn\", `Validation Rule \"${rule}\" is not defined`);\r\n\r\n            }\r\n        } catch (e) {\r\n            if (FormGuard._debug) {\r\n                console.error(e);\r\n                throw e;\r\n            }\r\n            else {\r\n                throw new ValidationError(\r\n                    'An error occurred'\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    \r\n\r\n    skippedValidation(obj) {\r\n        return (\r\n            this._skips.includes(obj.attribute) ||\r\n            // (!this.getData(obj) && !obj.required) ||\r\n            obj.attribute in this._errors\r\n        );\r\n    }\r\n\r\n    loadErrorMessage(obj, message) {\r\n\r\n        \r\n        if (!utils.isString(obj.rule)) {\r\n            obj.rule = method;\r\n        }\r\n\r\n        if (!utils.isString(message)) {\r\n            message = this.getUserMessages(obj);\r\n        }\r\n        \r\n\r\n        this.skipNextValidation(obj);\r\n\r\n        const attrs = {\r\n            ...obj,\r\n            attribute: this.getAttribute(obj.attribute),\r\n        };\r\n        message = message.replace(\r\n            /:([a-zA-Z_]+)/g,\r\n            (_, key) => attrs[key] || key\r\n        );\r\n        this._errors[obj.attribute] = message;\r\n    }\r\n\r\n\r\n    getData(obj) {\r\n        if (!utils.isObject(obj)) {\r\n            return this._data;\r\n        }\r\n        return this._data[obj.attribute];\r\n    }\r\n\r\n    setData(obj, value) {\r\n        this._data[obj.attribute] = value;\r\n    }\r\n    removeData(obj) {\r\n        delete this._data[obj.attribute];\r\n    }\r\n\r\n    skipNextValidation(obj) {\r\n        this._skips.push(obj.attribute);\r\n    }\r\n\r\n    clearErrorMessage(obj) {\r\n        if (this._errors[obj.attribute]) {\r\n            delete this._errors[obj.attribute];\r\n        }\r\n    }\r\n\r\n    hasError(obj) {\r\n        return !!this._errors[obj.attribute];\r\n    }\r\n\r\n    /**\r\n     * @param obj {Object}\r\n     *\r\n     * @usage\r\n     * FormGuard.setAttributes({\r\n     *    name: 'Full Name',\r\n     *    email: 'Email Address'\r\n     * });\r\n     *\r\n     * @returns void\r\n     */\r\n\r\n     static getKeys(thing){\r\n        const pattern = /([^$]+)/g;\r\n        const matched = thing.match(pattern);\r\n\r\n        if (!matched || matched.length !== 2) {\r\n            return [thing, system_locale];\r\n        }\r\n        return matched;\r\n    }\r\n\r\n    getAttribute(name) {\r\n        if (utils.isPlainObject(this._attributes)) {\r\n            const locale = this._attributes[FormGuard.locale];\r\n\r\n            if (utils.isPlainObject(locale)) {\r\n                return locale[name] || name;\r\n            }\r\n        }\r\n        return name;\r\n    }\r\n\r\n\r\n\r\n    setAttributes(obj) {\r\n        if (!utils.isObject(this._attributes)) {\r\n            this._attributes = {};\r\n        }\r\n\r\n        if (utils.isObject(obj)) {\r\n            obj = {\r\n                ...(utils.isPlainObject(config.attributes) ? config.attributes : {}),\r\n                ...obj \r\n            };\r\n            utils.forEach(obj, (value, key) => {\r\n                const [message_key, locale] = FormGuard.getKeys(key);\r\n                this._attributes[locale] = {\r\n                    ...(utils.isPlainObject(this._attributes[locale]) ? this._attributes[locale] : {}),\r\n                    [message_key]: value\r\n                };\r\n            })\r\n            \r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    snakeCase(...args) {\r\n        args = args.filter(arg => utils.isString(arg))\r\n        \r\n        return args\r\n            .map((arg, i) =>\r\n                i === 0\r\n                    ? arg.toLowerCase()\r\n                    : arg.charAt(0).toUpperCase() + arg.slice(1).toLowerCase()\r\n            )\r\n            .join(\"\");\r\n    }\r\n\r\n    async empty(data) {\r\n        const matcher = [\r\n            data === undefined,\r\n            data === null,\r\n            utils.isString(data) && utils.trim(data) === \"\",\r\n            utils.isArray(data) && data.length === 0,\r\n            utils.isObject(data) && data && Object.keys(data).length === 0,\r\n        ];\r\n\r\n        return matcher.some((item) => item);\r\n    }\r\n\r\n\r\n    loadFallbackMessages(fallback_messages) {\r\n        FormGuard._fallback_messages = FormGuard._translations[FormGuard.locale] || utils.castObject(fallback_messages, {});\r\n    }\r\n    \r\n    static setPriority(name, priority) {\r\n        const priors = {\r\n            p1: 'fillables',\r\n            p2: 'types',\r\n            p3: 'stabilizers',\r\n        }\r\n        const priorities = [\"fillables\", \"types\", \"stabilizers\"];\r\n        priority = utils.castNumber(priority, 4);\r\n\r\n        this.resetPriority(name);\r\n        const prior = `p${priority}`;\r\n\r\n\r\n        if (priors[prior]) {\r\n            const order = priors[prior];\r\n            this.registers[order].push(name);\r\n\r\n        }\r\n    }\r\n\r\n    static resetPriority(name) {\r\n        \r\n        for(const [registry, orders] of Object.entries(this.registers)) {\r\n            const order = orders.indexOf(name);\r\n            if (order >= 0) {\r\n                this.registers[registry].splice(order, 1);\r\n            }\r\n        }\r\n    }\r\n\r\n    static remove(name) {\r\n        this.resetPriority(name);\r\n\r\n        if (name in this) {\r\n            delete this[name];\r\n        }\r\n    }\r\n\r\n\r\n    static add(custom_rules, options) {\r\n        if (utils.isString(custom_rules)) {\r\n            if (utils.isPlainObject(options)) {\r\n                this.add({\r\n                    [custom_rules]: options, \r\n                });\r\n            }\r\n            else if (utils.isFunction(options)) {\r\n                this.add({\r\n                    [custom_rules]: {\r\n                        fn: options \r\n                    }\r\n                });\r\n                // this[custom_rules] = options;\r\n            }\r\n        }   \r\n\r\n        else if (utils.isArray(custom_rules)) {\r\n            utils.forEach(custom_rules, rules => {\r\n                if (utils.isPlainObject(rules) && utils.isString(rules.name)) {\r\n                    this.add({[rules.name]: rules})\r\n                }\r\n                else if (!utils.isPlainObject(rules)) {\r\n                    this.log('warn', 'Rules should be an object');\r\n                }\r\n                else if (!utils.isString(rules.name)) {\r\n                    this.log('warn', 'Rule name is missing');\r\n                }\r\n            });\r\n        }\r\n\r\n        else if (utils.isPlainObject(custom_rules)) {\r\n\r\n            utils.forEach(custom_rules, (options, name) => {\r\n                if (utils.isFunction(options)) {\r\n                    this[name] = options;\r\n                    return;\r\n                }\r\n                \r\n                const fn = eval(`(function ${name}(data){return options.fn(data);})`)\r\n                // const fn = options.fn;\r\n                \r\n                \r\n                let messages = utils.isString(options.message) ? {[name]:options.message} : {};\r\n\r\n                if (utils.isPlainObject(options.messages)) {\r\n                    messages = {\r\n                        ...(Object.fromEntries(\r\n                            Object.entries(options.messages)\r\n                                .map(([locale, message]) => [`${name}$${locale}`, message])\r\n                        ))\r\n                    }\r\n                }\r\n                \r\n                \r\n                if (utils.isFunction(fn)) {\r\n                    this.setSystemMessages(messages, name);\r\n                    this.setPriority(name, options.priority);\r\n                    delete this[name];\r\n                    this[name] = fn;\r\n                }\r\n                else {\r\n                    this.log('warn', `${name} fn must be a function`);\r\n                }\r\n            })\r\n            \r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    \r\n}","'use strict';\r\n\r\n\r\n// utils is a library of generic helper functions non-specific to axios\r\n\r\nconst {toString} = Object.prototype;\r\nconst {getPrototypeOf} = Object;\r\n\r\nconst kindOf = (cache => thing => {\r\n    const str = toString.call(thing);\r\n    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());\r\n})(Object.create(null));\r\n\r\nconst kindOfTest = (type) => {\r\n  type = type.toLowerCase();\r\n  return (thing) => kindOf(thing) === type\r\n}\r\n\r\n\r\n\r\nconst typeOfTest = type => (thing, falseValue = false) => typeof thing === type ? true : falseValue;\r\n\r\n/**\r\n * Determine if a value is an Array\r\n *\r\n * @param {Object} val The value to test\r\n *\r\n * @returns {boolean} True if value is an Array, otherwise false\r\n */\r\nconst {isArray} = Array;\r\n\r\n/**\r\n * Determine if a value is undefined\r\n *\r\n * @param {*} val The value to test\r\n *\r\n * @returns {boolean} True if the value is undefined, otherwise false\r\n */\r\nconst isUndefined = typeOfTest('undefined');\r\n\r\n/**\r\n * Determine if a value is a Buffer\r\n *\r\n * @param {*} val The value to test\r\n *\r\n * @returns {boolean} True if value is a Buffer, otherwise false\r\n */\r\nfunction isBuffer(val) {\r\n  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)\r\n    && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);\r\n}\r\n\r\n/**\r\n * Determine if a value is an ArrayBuffer\r\n *\r\n * @param {*} val The value to test\r\n *\r\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\r\n */\r\nconst isArrayBuffer = kindOfTest('ArrayBuffer');\r\n\r\n\r\n/**\r\n * Determine if a value is a view on an ArrayBuffer\r\n *\r\n * @param {*} val The value to test\r\n *\r\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\r\n */\r\nfunction isArrayBufferView(val) {\r\n  let result;\r\n  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {\r\n    result = ArrayBuffer.isView(val);\r\n  } else {\r\n    result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * Determine if a value is a String\r\n *\r\n * @param {*} val The value to test\r\n *\r\n * @returns {boolean} True if value is a String, otherwise false\r\n */\r\nconst isString = typeOfTest('string');\r\n\r\n/**\r\n * Determine if a value is a Function\r\n *\r\n * @param {*} val The value to test\r\n * @returns {boolean} True if value is a Function, otherwise false\r\n */\r\nconst isFunction = typeOfTest('function');\r\n\r\n/**\r\n * Determine if a value is a Number\r\n *\r\n * @param {*} val The value to test\r\n *\r\n * @returns {boolean} True if value is a Number, otherwise false\r\n */\r\nconst isNumber = typeOfTest('number');\r\n\r\n/**\r\n * Determine if a value is an Object\r\n *\r\n * @param {*} thing The value to test\r\n *\r\n * @returns {boolean} True if value is an Object, otherwise false\r\n */\r\nconst isObject = (thing, falseValue = false) => thing !== null && typeof thing === 'object' ? true : falseValue;\r\n\r\n/**\r\n * Determine if a value is a Boolean\r\n *\r\n * @param {*} thing The value to test\r\n * @returns {boolean} True if value is a Boolean, otherwise false\r\n */\r\nconst isBoolean = thing => thing === true || thing === false;\r\n\r\n/**\r\n * Determine if a value is a plain Object\r\n *\r\n * @param {*} val The value to test\r\n *\r\n * @returns {boolean} True if value is a plain Object, otherwise false\r\n */\r\nconst isPlainObject = (val, returnValue = false) => {\r\n  if (kindOf(val) !== 'object') {\r\n    return returnValue;\r\n  }\r\n\r\n  const prototype = getPrototypeOf(val);\r\n  const m = (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);\r\n  return m ? m : returnValue;\r\n}\r\n\r\nconst castType = (type) => {\r\n  const parsers = {\r\n    object: isPlainObject,\r\n    string: isString,\r\n    boolean: isBoolean,\r\n    number: isNumber,\r\n    array: isArray,\r\n    function: isFunction,\r\n  };\r\n  const defaults = {\r\n    object: {},\r\n    string: '',\r\n    boolean: false,\r\n    number: 0,\r\n    function: () => {},\r\n    array: []\r\n  }\r\n  let _parser = parsers.string;\r\n  let _cast = defaults.string;\r\n\r\n  if (parsers[type]) {\r\n    _parser = parsers[type]\r\n    _cast = defaults[type];\r\n  }\r\n   \r\n  return (thing, cast) => {\r\n    if (_parser(thing)) {\r\n      return thing;\r\n    }\r\n    return cast||_cast;\r\n  }\r\n};\r\nconst castNumber = castType('number');\r\nconst castObject = castType('object');\r\nconst castString = castType('string');\r\nconst castArray = castType('array');\r\nconst castBoolean = castType('boolean');\r\nconst castFunction = castType('function');\r\n\r\n/**\r\n * Determine if a value is a Date\r\n *\r\n * @param {*} val The value to test\r\n *\r\n * @returns {boolean} True if value is a Date, otherwise false\r\n */\r\nconst isDate = kindOfTest('Date');\r\n\r\n/**\r\n * Determine if a value is a File\r\n *\r\n * @param {*} val The value to test\r\n *\r\n * @returns {boolean} True if value is a File, otherwise false\r\n */\r\nconst isFile = kindOfTest('File');\r\n\r\n/**\r\n * Determine if a value is a Blob\r\n *\r\n * @param {*} val The value to test\r\n *\r\n * @returns {boolean} True if value is a Blob, otherwise false\r\n */\r\nconst isBlob = kindOfTest('Blob');\r\n\r\n/**\r\n * Determine if a value is a FileList\r\n *\r\n * @param {*} val The value to test\r\n *\r\n * @returns {boolean} True if value is a File, otherwise false\r\n */\r\nconst isFileList = kindOfTest('FileList');\r\n\r\n/**\r\n * Determine if a value is a Stream\r\n *\r\n * @param {*} val The value to test\r\n *\r\n * @returns {boolean} True if value is a Stream, otherwise false\r\n */\r\nconst isStream = (val) => isObject(val) && isFunction(val.pipe);\r\n\r\n/**\r\n * Determine if a value is a FormData\r\n *\r\n * @param {*} thing The value to test\r\n *\r\n * @returns {boolean} True if value is an FormData, otherwise false\r\n */\r\nconst isFormData = (thing) => {\r\n  let kind;\r\n  return thing && (\r\n    (typeof FormData === 'function' && thing instanceof FormData) || (\r\n      isFunction(thing.append) && (\r\n        (kind = kindOf(thing)) === 'formdata' ||\r\n        // detect form-data instance\r\n        (kind === 'object' && isFunction(thing.toString) && thing.toString() === '[object FormData]')\r\n      )\r\n    )\r\n  )\r\n}\r\n\r\n/**\r\n * Determine if a value is a URLSearchParams object\r\n *\r\n * @param {*} val The value to test\r\n *\r\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\r\n */\r\nconst isURLSearchParams = kindOfTest('URLSearchParams');\r\n\r\nconst [isReadableStream, isRequest, isResponse, isHeaders] = ['ReadableStream', 'Request', 'Response', 'Headers'].map(kindOfTest);\r\n\r\n/**\r\n * Trim excess whitespace off the beginning and end of a string\r\n *\r\n * @param {String} str The String to trim\r\n *\r\n * @returns {String} The String freed of excess whitespace\r\n */\r\nconst trim = (str) => str.trim ?\r\n  str.trim() : str.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\r\n\r\nconst recursiveTrim = (str) => {\r\n  if (isString(str)) return trim(str);\r\n\r\n  if (isArray(str)) {\r\n    let newArray = [];\r\n    for(var i = 0; i < str.length; i++) {\r\n      newArray.push(isString(str[i]) ? trim(str[i]) : recursiveTrim(str[i]));\r\n    }\r\n    return newArray;\r\n  }\r\n  else if (isPlainObject(str)) {\r\n    return Object.fromEntries(\r\n      Object.entries(str).map(([key, value]) => [\r\n        key,\r\n        recursiveTrim(value)\r\n      ])\r\n    );\r\n  }\r\n  return str;\r\n}\r\n\r\n/**\r\n * Extend List\r\n */\r\nconst enList = (list, extension) => {\r\n  for (var _len2 = list.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\r\n    args[_key2] = list[_key2];\r\n  }\r\n  if (isUndefined(extension)) {\r\n    return args;\r\n  }\r\n  else if (!isArray(extension)) {\r\n      extension = [extension];\r\n  }\r\n\r\n  const aLength = args.length;\r\n  const eLength = extension.length;\r\n  if (aLength >= eLength || eLength === 0) return args;\r\n\r\n  return extension.map((ext, i) => i + 1 > aLength ? ext : args[i])\r\n\r\n};\r\n\r\n/**\r\n * Iterate over an Array or an Object invoking a function for each item.\r\n *\r\n * If `obj` is an Array callback will be called passing\r\n * the value, index, and complete array for each item.\r\n *\r\n * If 'obj' is an Object callback will be called passing\r\n * the value, key, and complete object for each property.\r\n *\r\n * @param {Object|Array} obj The object to iterate\r\n * @param {Function} fn The callback to invoke for each item\r\n *\r\n * @param {Boolean} [allOwnKeys = false]\r\n * @returns {any}\r\n */\r\nfunction forEach(obj, fn, {allOwnKeys = false} = {}) {\r\n  // Don't bother if no value provided\r\n  if (obj === null || typeof obj === 'undefined') {\r\n    return;\r\n  }\r\n\r\n  let i;\r\n  let l;\r\n\r\n  // Force an array if not already something iterable\r\n  if (typeof obj !== 'object') {\r\n    /*eslint no-param-reassign:0*/\r\n    obj = [obj];\r\n  }\r\n\r\n  if (isArray(obj)) {\r\n    // Iterate over array values\r\n    for (i = 0, l = obj.length; i < l; i++) {\r\n      fn.call(null, obj[i], i, obj);\r\n    }\r\n  } else {\r\n    // Iterate over object keys\r\n    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);\r\n    const len = keys.length;\r\n    let key;\r\n\r\n    for (i = 0; i < len; i++) {\r\n      key = keys[i];\r\n      fn.call(null, obj[key], key, obj);\r\n    }\r\n  }\r\n}\r\n\r\nfunction findKey(obj, key) {\r\n  key = key.toLowerCase();\r\n  const keys = Object.keys(obj);\r\n  let i = keys.length;\r\n  let _key;\r\n  while (i-- > 0) {\r\n    _key = keys[i];\r\n    if (key === _key.toLowerCase()) {\r\n      return _key;\r\n    }\r\n  }\r\n  return null;\r\n}\r\n\r\nconst _global = (() => {\r\n  /*eslint no-undef:0*/\r\n  if (typeof globalThis !== \"undefined\") return globalThis;\r\n  return typeof self !== \"undefined\" ? self : (typeof window !== 'undefined' ? window : global)\r\n})();\r\n\r\nconst isContextDefined = (context) => !isUndefined(context) && context !== _global;\r\n\r\n/**\r\n * Accepts varargs expecting each argument to be an object, then\r\n * immutably merges the properties of each object and returns result.\r\n *\r\n * When multiple objects contain the same key the later object in\r\n * the arguments list will take precedence.\r\n *\r\n * Example:\r\n *\r\n * ```js\r\n * var result = merge({foo: 123}, {foo: 456});\r\n * console.log(result.foo); // outputs 456\r\n * ```\r\n *\r\n * @param {Object} obj1 Object to merge\r\n *\r\n * @returns {Object} Result of all merge properties\r\n */\r\nfunction merge(/* obj1, obj2, obj3, ... */) {\r\n  const {caseless} = isContextDefined(this) && this || {};\r\n  const result = {};\r\n  const assignValue = (val, key) => {\r\n    const targetKey = caseless && findKey(result, key) || key;\r\n    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {\r\n      result[targetKey] = merge(result[targetKey], val);\r\n    } else if (isPlainObject(val)) {\r\n      result[targetKey] = merge({}, val);\r\n    } else if (isArray(val)) {\r\n      result[targetKey] = val.slice();\r\n    } else {\r\n      result[targetKey] = val;\r\n    }\r\n  }\r\n\r\n  for (let i = 0, l = arguments.length; i < l; i++) {\r\n    arguments[i] && forEach(arguments[i], assignValue);\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * Extends object a by mutably adding to it the properties of object b.\r\n *\r\n * @param {Object} a The object to be extended\r\n * @param {Object} b The object to copy properties from\r\n * @param {Object} thisArg The object to bind function to\r\n *\r\n * @param {Boolean} [allOwnKeys]\r\n * @returns {Object} The resulting value of object a\r\n */\r\nconst extend = (a, b, thisArg, {allOwnKeys}= {}) => {\r\n  forEach(b, (val, key) => {\r\n    if (thisArg && isFunction(val)) {\r\n      a[key] = bind(val, thisArg);\r\n    } else {\r\n      a[key] = val;\r\n    }\r\n  }, {allOwnKeys});\r\n  return a;\r\n}\r\n\r\n\r\n/**\r\n * Inherit the prototype methods from one constructor into another\r\n * @param {function} constructor\r\n * @param {function} superConstructor\r\n * @param {object} [props]\r\n * @param {object} [descriptors]\r\n *\r\n * @returns {void}\r\n */\r\nconst inherits = (constructor, superConstructor, props, descriptors) => {\r\n  constructor.prototype = Object.create(superConstructor.prototype, descriptors);\r\n  constructor.prototype.constructor = constructor;\r\n  Object.defineProperty(constructor, 'super', {\r\n    value: superConstructor.prototype\r\n  });\r\n  props && Object.assign(constructor.prototype, props);\r\n}\r\n\r\n\r\n\r\n/**\r\n * Returns new array from array like object or null if failed\r\n *\r\n * @param {*} [thing]\r\n *\r\n * @returns {?Array}\r\n */\r\nconst toArray = (thing) => {\r\n  if (!thing) return null;\r\n  if (isArray(thing)) return thing;\r\n  let i = thing.length;\r\n  if (!isNumber(i)) return null;\r\n  const arr = new Array(i);\r\n  while (i-- > 0) {\r\n    arr[i] = thing[i];\r\n  }\r\n  return arr;\r\n}\r\n\r\n/**\r\n * Checking if the Uint8Array exists and if it does, it returns a function that checks if the\r\n * thing passed in is an instance of Uint8Array\r\n *\r\n * @param {TypedArray}\r\n *\r\n * @returns {Array}\r\n */\r\n// eslint-disable-next-line func-names\r\nconst isTypedArray = (TypedArray => {\r\n  // eslint-disable-next-line func-names\r\n  return thing => {\r\n    return TypedArray && thing instanceof TypedArray;\r\n  };\r\n})(typeof Uint8Array !== 'undefined' && getPrototypeOf(Uint8Array));\r\n\r\n/**\r\n * For each entry in the object, call the function with the key and value.\r\n *\r\n * @param {Object<any, any>} obj - The object to iterate over.\r\n * @param {Function} fn - The function to call for each entry.\r\n *\r\n * @returns {void}\r\n */\r\nconst forEachEntry = (obj, fn) => {\r\n  const generator = obj && obj[Symbol.iterator];\r\n\r\n  const iterator = generator.call(obj);\r\n\r\n  let result;\r\n\r\n  while ((result = iterator.next()) && !result.done) {\r\n    const pair = result.value;\r\n    fn.call(obj, pair[0], pair[1]);\r\n  }\r\n}\r\n\r\n\r\n\r\n/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */\r\nconst isHTMLForm = kindOfTest('HTMLFormElement');\r\n\r\nconst toCamelCase = str => {\r\n  return str.toLowerCase().replace(/[-_\\s]([a-z\\d])(\\w*)/g,\r\n    function replacer(m, p1, p2) {\r\n      return p1.toUpperCase() + p2;\r\n    }\r\n  );\r\n};\r\n\r\n/* Creating a function that will check if an object has a property. */\r\nconst hasOwnProperty = (({hasOwnProperty}) => (obj, prop) => hasOwnProperty.call(obj, prop))(Object.prototype);\r\n\r\n/**\r\n * Determine if a value is a RegExp object\r\n *\r\n * @param {*} val The value to test\r\n *\r\n * @returns {boolean} True if value is a RegExp object, otherwise false\r\n */\r\nconst isRegExp = kindOfTest('RegExp');\r\n\r\nconst reduceDescriptors = (obj, reducer) => {\r\n  const descriptors = Object.getOwnPropertyDescriptors(obj);\r\n  const reducedDescriptors = {};\r\n\r\n  forEach(descriptors, (descriptor, name) => {\r\n    let ret;\r\n    if ((ret = reducer(descriptor, name, obj)) !== false) {\r\n      reducedDescriptors[name] = ret || descriptor;\r\n    }\r\n  });\r\n\r\n  Object.defineProperties(obj, reducedDescriptors);\r\n}\r\n\r\n/**\r\n * Makes all methods read-only\r\n * @param {Object} obj\r\n */\r\n\r\nconst freezeMethods = (obj) => {\r\n  reduceDescriptors(obj, (descriptor, name) => {\r\n    // skip restricted props in strict mode\r\n    if (isFunction(obj) && ['arguments', 'caller', 'callee'].indexOf(name) !== -1) {\r\n      return false;\r\n    }\r\n\r\n    const value = obj[name];\r\n\r\n    if (!isFunction(value)) return;\r\n\r\n    descriptor.enumerable = false;\r\n\r\n    if ('writable' in descriptor) {\r\n      descriptor.writable = false;\r\n      return;\r\n    }\r\n\r\n    if (!descriptor.set) {\r\n      descriptor.set = () => {\r\n        throw Error('Can not rewrite read-only method \\'' + name + '\\'');\r\n      };\r\n    }\r\n  });\r\n}\r\n\r\n\r\nconst isAsyncFn = kindOfTest('AsyncFunction');\r\n\r\nconst isThenable = (thing) =>\r\n  thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);\r\n\r\n\r\n\r\n\r\nconst parallel = async (...tasks) => {\r\n  await Promise.all(tasks.map((task) => task()));\r\n}\r\n\r\nconst series = async (...tasks) => {\r\n    for (const task of tasks) {\r\n        await task();\r\n    }\r\n}\r\n\r\nconst race = async (tasks) => {\r\n  return await Promise.race(tasks);\r\n}\r\n\r\nconst delay =  (ms) => {\r\n  return new Promise((resolve) => setTimeout(resolve, ms));\r\n}\r\n\r\n\r\n\r\nconst join = (array, glue, finalGlue = '') => {\r\n    if (finalGlue === '') {\r\n      return array.join(glue);\r\n    }\r\n\r\n    if (array.length === 0) {\r\n        return '';\r\n    }\r\n\r\n    if (array.length === 1) {\r\n        return array[0];\r\n    }\r\n\r\n    const finalItem = array.pop();\r\n\r\n    return array.join(glue) + finalGlue + finalItem;\r\n}\r\n\r\nconst format_date = (strdate, format, type = \"datetime\") => {\r\n  \r\n  const placeholders = {\r\n      date: \"yyyy-mm-dd\",\r\n      datetime: \"yyyy-mm-dd H:i:s\",\r\n      time: \"H:i:s a\",\r\n  };\r\n  const matchers = /(yyyy|mm|dd|h|i|s|a)/gi;\r\n  \r\n  const placeholder = placeholders[type] || placeholders.datetime;\r\n  if (!isString(format)) {\r\n      format = placeholder;\r\n  }\r\n\r\n  const date = isDate(strdate) ? strdate : new Date(strdate);\r\n\r\n  const padZero = (n) => (n < 10 ? `0${n}` : n);\r\n\r\n  const yyyy = date.getFullYear();\r\n  if (isNaN(yyyy)) {\r\n    return null;\r\n  }\r\n  const mm = padZero(date.getMonth() + 1);\r\n  const i = padZero(date.getMinutes() || 0);\r\n  const dd = padZero(date.getDate());\r\n  const hours = date.getHours();\r\n  let a = \"am\";\r\n  let A = \"AM\";\r\n  let h = hours;\r\n\r\n  if (h > 12) {\r\n      h -= 12;\r\n      a = \"pm\";\r\n      A = \"PM\";\r\n  }\r\n  h = padZero(h);\r\n  const H = padZero(hours);\r\n  const s = padZero(date.getSeconds() || 0);\r\n  const pattern = /([a-zA-Z]+)/g;\r\n  const [MM, S, YYYY, DD, I] = [mm, s, yyyy, dd, i];\r\n\r\n  const dateObj = { yyyy, YYYY, mm, MM, s, S, h, H, a, A, dd, DD, i, I };\r\n  \r\n  return format.replace(matchers, $1 => dateObj[$1] || $1);\r\n\r\n}\r\n\r\n\r\nconst retry = async (fn, options = {}) => {\r\n  if (isPlainObject(options)) {\r\n      options = {};\r\n  }\r\n  options = {\r\n      limit: 3,\r\n      retryIF: () => true,\r\n      timeout: 1000,\r\n      maxTimeout: 8000,\r\n      delay: false,\r\n      ...options\r\n  };\r\n  options.timeout = options.timeout || 0;\r\n  let lastError;\r\n  for (let i = 0; i < options.limit; i++) {\r\n      const nextDelay = Math.min(options.timeout * Math.pow(2, i), options.maxTimeout);\r\n      try {\r\n          return await fn({counter: i + 1, next:nextDelay});\r\n      } catch (error) {\r\n          lastError = error;\r\n          if (!options.retryIF(error)) {\r\n              throw error;\r\n          }\r\n          if (i < options.limit - 1) {\r\n              const delay = options.delay ? 1 : 0;\r\n              \r\n              await new Promise((resolve) => setTimeout(resolve, nextDelay * delay));\r\n          }\r\n      }\r\n  }\r\n  throw lastError;\r\n};\r\n\r\nconst combineArrayToObject =  (keys, values = [], defaultValue) => {\r\n  if (!isArray(keys) || !isArray(values)) return [];\r\n\r\n  return keys.reduce((acc, key, i) => {\r\n      acc[key] = !isUndefined(values[i]) ? values[i] : defaultValue;\r\n      return acc;\r\n  }, {});\r\n}\r\n\r\n\r\n\r\nconst isNumeric = (thing) => {\r\n  if (!isNumber(thing)) {\r\n    if (!isString(thing) || !/^[-]?\\d*(\\.\\d+)?$/.test(thing)) {\r\n      return false;\r\n    }\r\n    thing = parseFloat(thing);\r\n  }\r\n  return isNaN(thing) ? false : thing;\r\n}\r\n\r\nconst isInteger = (thing) => {\r\n  thing = isNumeric(thing);\r\n  if (thing && thing % 1 === 0) {\r\n    return thing;\r\n  }\r\n  return false;\r\n};\r\n\r\nconst isDecimal = (thing) => (isNumeric(thing) && !isInteger(thing)) || (isString(thing) && /^[-]?\\d*(\\.\\d+)?$/.test(thing));\r\n\r\n\r\n\r\nconst objectGet = (obj) => {\r\n  let data = obj;\r\n  for (var i = 1; i < arguments.length; i++) {\r\n    if (isPlainObject(data)) {\r\n      data = data[arguments[i]];\r\n    } else {\r\n      return;\r\n    }\r\n  }\r\n  return data;\r\n};\r\n\r\n\r\n\r\n\r\n\r\nconst isLength = (value) => isNumber(value) && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\r\n\r\nconst len = value => {\r\n  if (isArray(value) || isString(value)) return value.length;\r\n\r\n  if (isPlainObject(value)) {\r\n    return Object.keys(value).length;\r\n  }\r\n\r\n  return 0;\r\n};\r\n\r\nconst isArrayLike = (value) => value != null && isLength(value.length) && !isFunction(value);\r\nconst isObjectMethod = (name)=> typeof Object === 'function' ? typeof Object[name] === 'function' : false;\r\n\r\n\r\nconst zip =  (keys, values, defaultValue) => {\r\n  try {\r\n  if (typeof values === 'undefined') {\r\n      return Object.fromEntries(keys);\r\n  }\r\nif (!Array.isArray(keys) || !Array.isArray(values)) return [];\r\n\r\n\r\nreturn keys.reduce((acc, key, i) => {\r\n    if (isString(key)) {\r\n      acc[key] = values[i] !== undefined ? values[i] : defaultValue;\r\n    }\r\n  \r\n    else if (isArray(key) && key.length > 0) {\r\n      acc[key[0]] = key.length > 1 ? key[1] : undefined;\r\n    }\r\n    return acc;\r\n}, {});\r\n  } catch(e){return [];}\r\n}\r\n\r\n\r\n\r\n\r\nconst interval = (fnc, options) => {\r\n  let intervalId;\r\n  let time = Date.now();\r\n\r\n  if (typeof options === 'number') {\r\n      options = { delay: options };\r\n  }\r\n  else if (typeof options !== 'object' || options === null) {\r\n      options = {};\r\n  }\r\n  options = { delay: 5000, ...options}\r\n  \r\n  \r\n  return (...args) => {\r\n      const context = this;\r\n      intervalId && clearInterval(intervalId);\r\n   \r\n      intervalId = setInterval(() => {\r\n      args = [Date.now() - time].concat(args);\r\n\r\n          fnc.apply(context, args);\r\n      }, options.delay);\r\n\r\n      return intervalId;\r\n\r\n  };\r\n\r\n}\r\n\r\nconst poll = (fnc, delay = 60000) => {\r\n  interval(fnc, delay)();\r\n}\r\n\r\nconst memorize = (fn, cacheKey) => {\r\n  const cache = {};\r\n  return (...args) => {\r\n      const key = cacheKey || JSON.stringify(args);\r\n      if (cache[key]) {\r\n          return cache[key];\r\n      }\r\n      const result = fn(...args);\r\n      cache[key] = result;\r\n      return result;\r\n  };\r\n};\r\n//freezeMethods\r\nconst throttle = (fn, delay) => {\r\n  let lastCall = 0;\r\n  return (...args) => {\r\n      const now = new Date().getTime();\r\n      if (now - lastCall < delay) {\r\n          return;\r\n      }\r\n      lastCall = now;\r\n      return fn(...args);\r\n  };\r\n};\r\n\r\n\r\n\r\nconst normalize = memorize(data => {\r\n  if (isPlainObject(data)) {\r\n    return Object.fromEntries(\r\n      Object.entries(data)\r\n        .map(([key, value]) => [key, normalize(value)])\r\n    )\r\n  }\r\n  else if (isArray(data)) {\r\n    return data.map(item => normalize(item))\r\n  }\r\n  else if (isString(data)) {\r\n    try {\r\n      const parsed = JSON.parse(trim(data));\r\n\r\n      return normalize(parsed);\r\n\r\n    } catch(e) {}\r\n  }\r\n  return data;\r\n});\r\n\r\n// const isEmpty = (data) => {\r\n//   const matcher = [\r\n//       isUndefined(data),\r\n//       data === null,\r\n//       isString(data) && trim(data) === \"\",\r\n//       isArray(data) && data.length === 0,\r\n//       isPlainObject(data) && data && Object.keys(data).length === 0,\r\n//   ];\r\n\r\n//   return matcher.some((item) => item);\r\n// };\r\n\r\n\r\nconst isSet = value => {\r\n  if (isArray(value)) return !!value.length;\r\n\r\n  if (value === undefined || value === null) {\r\n    return false;\r\n  }\r\n  if (isString(value)) {\r\n    return !!trim(value).length;\r\n  }\r\n\r\n  if (value === false) {\r\n    return true;\r\n  }\r\n\r\n  if (value instanceof Date) {\r\n    return !isNaN(value.getTime());\r\n  }\r\n\r\n  if (typeof value === 'object') {\r\n    for (let _ in value) return true;\r\n\r\n    return false;\r\n  }\r\n\r\n  return !!String(value).length;\r\n};\r\n\r\nconst isEmpty = value => !isSet(value);\r\n\r\n\r\n\r\nconst generateUUID = (format = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx') => format.replace(/[xy]/g, (c) => {\r\n      const r = Math.random() * 16 | 0;\r\n      const v = c === 'x' ? r : (r & 0x3 | 0x8);\r\n      return v.toString(16);\r\n});\r\n\r\nconst randomInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;\r\n\r\n\r\nconst deepClone = (obj) => {\r\n  if (obj === null || typeof obj !== 'object') {\r\n      return obj;\r\n  }\r\n  if (Array.isArray(obj)) {\r\n      return obj.map(item => deepClone(item));\r\n  }\r\n  const clone = {};\r\n  for (const key in obj) {\r\n      if (obj.hasOwnProperty(key)) {\r\n          clone[key] = deepClone(obj[key]);\r\n      }\r\n  }\r\n  return clone;\r\n};\r\n\r\n\r\nconst isEmail = (str) => (\r\n  isString(str) && \r\n  /^(?:[A-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[A-z0-9!#$%&'*+/=?^_`{|}~-]+)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9]{2,}(?:[a-z0-9-]*[a-z0-9])?|\\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])$/i.test(str)\r\n);\r\n\r\nconst isUuid = (str) => (\r\n  isString(str) &&\r\n  /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/.test(str)\r\n);\r\n\r\nconst isUrl = (str) => (\r\n  isString(str) &&\r\n  /^(?:(?:(?:https?|ftp):)?\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z0-9\\u00a1-\\uffff][a-z0-9\\u00a1-\\uffff_-]{0,62})?[a-z0-9\\u00a1-\\uffff]\\.)+(?:[a-z\\u00a1-\\uffff]{2,}\\.?))(?::\\d{2,5})?(?:[/?#]\\S*)?$/i.test(str)\r\n);\r\n\r\nconst isIpAddress = (str) => (\r\n  isString(str) &&\r\n  /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(str)\r\n);\r\n\r\nconst isObj = (obj, ifNotReturn = {}) => {\r\n  if (!isPlainObject(obj)) {\r\n    return ifNotReturn;\r\n  }\r\n  return obj;\r\n}\r\n\r\nconst wrap = (value) => {\r\n  if (isArray(value)) {\r\n    return value;\r\n  }\r\n  if (isUndefined(value)) {\r\n    return [];\r\n  }\r\n  else if (isString(value)) {\r\n    return [value];\r\n  }\r\n  try {\r\n    return Array.from(value);\r\n  } catch(e) {}\r\n};\r\n\r\nclass Observer {\r\n    constructor() {\r\n    this.callbacks = [];\r\n    }\r\n\r\n    /**\r\n    Register a callback to be eecuted when the observed value changes.\r\n    @params {Function} callback\r\n    */\r\n    watch(predictive, callback) {\r\n      this.callbacks.push([callback, predictive]);\r\n    }\r\n\r\n    /**\r\n     * Notify all registered callbacks of a value change.\r\n     * @param {*} newValue\r\n     * @param {*} oldValue\r\n    */\r\n    notify(newValue, oldValue) {\r\n      console.log({newValue, oldValue})\r\n      this.callbacks.forEach((callback) => callback[0](newValue, oldValue));\r\n    }\r\n\r\n\r\n  /**\r\n   * Create a proxied object to observe changes\r\n   * @param {*} initialValue\r\n   * @returns {Proxy}\r\n   */\r\n\r\n  createProxy(initialValue) {\r\n      return new Proxy({value:initialValue}, {\r\n        set: (target, property, newValue) => {\r\n          const oldValue = target.value;\r\n          target.value = newValue;\r\n          \r\n          this.notify(newValue, oldValue);\r\n          return true;\r\n        },\r\n      });\r\n  }\r\n}\r\nconst observer = new Observer();\r\n\r\nconst reactive = (initials) => {\r\n    return observer.createProxy(initials);\r\n}\r\n\r\nconst watch = (predictive, callback) => {\r\n  observer.watch(predictive, callback);\r\n}\r\n\r\n// *********************\r\n\r\nexport default {\r\n  isObj,\r\n  deepClone,\r\n  memorize,\r\n  throttle,\r\n  isObjectMethod,\r\n  generateUUID,\r\n  randomInt,\r\n  interval,\r\n  poll,\r\n  observer,\r\n  reactive,\r\n  watch,\r\n  zip,\r\n  isLength,\r\n  isArrayLike,\r\n  objectGet,\r\n  join,\r\n  isNumeric,\r\n  isInteger,\r\n  combineArrayToObject,\r\n  race,\r\n  parallel,\r\n  series,\r\n  retry,\r\n  delay,\r\n  isArray,\r\n  isArrayBuffer,\r\n  isBuffer,\r\n  isFormData,\r\n  isArrayBufferView,\r\n  isString,\r\n  isNumber,\r\n  isBoolean,\r\n  isObject,\r\n  isPlainObject,\r\n  isReadableStream,\r\n  isRequest,\r\n  isResponse,\r\n  isHeaders,\r\n  isUndefined,\r\n  isDate,\r\n  isFile,\r\n  isBlob,\r\n  isRegExp,\r\n  isFunction,\r\n  isStream,\r\n  isURLSearchParams,\r\n  isTypedArray,\r\n  isFileList,\r\n  forEach,\r\n  merge,\r\n  extend,\r\n  trim,\r\n  inherits,\r\n  kindOf,\r\n  kindOfTest,\r\n  toArray,\r\n  forEachEntry,\r\n  isHTMLForm,\r\n  hasOwnProperty,\r\n  hasOwnProp: hasOwnProperty, // an alias to avoid ESLint no-prototype-builtins detection\r\n  reduceDescriptors,\r\n  freezeMethods,\r\n  toCamelCase,\r\n  findKey,\r\n  global: _global,\r\n  isContextDefined,\r\n  isAsyncFn,\r\n  isThenable,\r\n  isEmpty,\r\n  isSet,\r\n  isDecimal,\r\n  isEmail,\r\n  isUuid,\r\n  isUrl,\r\n  isIpAddress,\r\n  \r\n  castNumber,\r\n  castString,\r\n  castObject,\r\n  castArray,\r\n  castBoolean,\r\n  castFunction,\r\n  enList,\r\n  \r\n\r\n  normalize,\r\n  wrap,\r\n  format_date\r\n};","export default {\n    accepted: \"يجب قبول :attribute.\",\n    date: \"يجب أن يكون الحقل تاريخاً صالحاً.\",\n    url: \"يجب أن يكون الحقل رابطاً صالحاً.\",\n    ip: \"يجب أن يكون الحقل عنوان IP صالحاً.\",\n    uuid: \"يجب أن يكون الحقل UUID صالحاً.\",\n    integer: \"يجب أن يكون الحقل عدداً صحيحاً.\",\n    alpha_spaces: \"يمكن أن يحتوي الحقل على أحرف ومسافات فقط.\",\n    timezone: \"يجب أن يكون الحقل منطقة زمنية صالحة.\",\n    credit_card: \"يجب أن يكون الحقل رقم بطاقة ائتمان صالح.\",\n    phone: \"يجب أن يكون الحقل رقم هاتف صالح.\",\n    contains: \"يجب أن يحتوي الحقل على :value.\",\n    not_contains: \"يجب ألا يحتوي الحقل على :value.\",\n    min: {\n        numeric: \"يجب ألا يقل عن :min.\",\n        string: \"يجب ألا يقل الطول عن :min حرفاً.\",\n        array: \"يجب أن يحتوي على :min عناصر على الأقل.\",\n        file: \"يجب ألا يقل حجم الملف عن :min بايت.\",\n        files: \"يجب ألا يقل حجم الملفات عن :min بايت.\",\n    },\n    unique: \"يجب أن يكون فريداً.\",\n    exists: \"يجب أن يكون موجوداً في البيانات.\",\n    max: {\n        numeric: \"يجب ألا يزيد عن :max.\",\n        string: \"يجب ألا يزيد الطول عن :max حرفاً.\",\n        array: \"يجب ألا يحتوي على أكثر من :max عناصر.\",\n        file: \"يجب ألا يتجاوز حجم الملف :max بايت.\",\n        files: \"يجب ألا يتجاوز حجم الملفات :max بايت.\",\n    },\n    image: \"يجب أن يكون :attribute صورة.\",\n    video: \"يجب أن يكون :attribute فيديو.\",\n    audio: \"يجب أن يكون :attribute صوتاً.\",\n    digits: \"يجب أن يحتوي :attribute على :digits رقم.\",\n    file: \"يجب أن يكون :attribute ملفاً.\",\n    files: \"يجب اختيار ملف واحد على الأقل لـ :attribute.\",\n    filled: \"يجب أن يحتوي :attribute على قيمة.\",\n    mimes: \"يجب أن يكون ملفاً من النوع: :values.\",\n    mimetypes: \"يجب أن يكون ملفاً من النوع: :values.\",\n    gt: {\n        numeric: \"يجب أن يكون أكبر من :gt.\",\n        string: \"يجب أن يزيد الطول عن :gt حروف.\",\n        array: \"يجب أن يحتوي على أكثر من :gt عناصر.\",\n        file: \"يجب أن يزيد حجم الملف عن :gt بايت.\",\n        files: \"يجب أن يزيد حجم الملفات عن :gt بايت.\",\n    },\n    lt: {\n        numeric: \"يجب أن يكون أقل من :lt.\",\n        string: \"يجب أن يقل الطول عن :lt حروف.\",\n        array: \"يجب أن يحتوي على أقل من :lt عناصر.\",\n        file: \"يجب أن يقل حجم الملف عن :lt بايت.\",\n        files: \"يجب أن يقل حجم الملفات عن :lt بايت.\",\n    },\n    gte: {\n        numeric: \"يجب أن يكون أكبر من أو يساوي :gte.\",\n        string: \"يجب أن يكون الطول :gte حروف أو أكثر.\",\n        array: \"يجب أن يحتوي على :gte عناصر على الأقل.\",\n        file: \"يجب أن يكون حجم الملف :gte بايت أو أكثر.\",\n        files: \"يجب أن يكون حجم الملفات :gte بايت أو أكثر.\",\n    },\n    lte: {\n        numeric: \"يجب أن يكون أقل من أو يساوي :lte.\",\n        string: \"يجب أن يكون الطول :lte حروف أو أقل.\",\n        array: \"يجب ألا يحتوي على أكثر من :lte عناصر.\",\n        file: \"يجب ألا يتجاوز حجم الملف :lte بايت.\",\n        files: \"يجب ألا يتجاوز حجم الملفات :lte بايت.\",\n    },\n    alpha: \"يجب أن يحتوي الحقل على حروف فقط.\",\n    alpha_: \"يمكن أن يحتوي الحقل على أحرف وشرطات سفلية فقط.\",\n    alpha_dash: \"يمكن أن يحتوي الحقل على أحرف وأرقام وشرطات وشرطات سفلية فقط.\",\n    alpha_num: \"يمكن أن يحتوي الحقل على أحرف وأرقام فقط.\",\n    boolean: \"يجب أن يكون الحقل قيمة منطقية.\",\n    confirmed: \"تأكيد الحقل غير مطابق.\",\n    between: {\n        numeric: \"يجب أن يكون بين :min و :max.\",\n        string: \"يجب أن يكون الطول بين :min و :max حروف.\",\n        array: \"يجب أن يحتوي بين :min و :max عناصر.\",\n        file: \"يجب أن يكون حجم الملف بين :min و :max بايت.\",\n        files: \"يجب أن يكون حجم الملفات بين :min و :max بايت.\",\n    },\n    password: {\n        length: \"يجب ألا يقل طول كلمة المرور عن :length حرفاً.\",\n        letters: \"يجب أن تحتوي كلمة المرور على حرف واحد على الأقل.\",\n        mixed: \"يجب أن تحتوي كلمة المرور على حرف كبير وصغير على الأقل.\",\n        numbers: \"يجب أن تحتوي كلمة المرور على رقم واحد على الأقل.\",\n        symbols: \"يجب أن تحتوي كلمة المرور على رمز واحد على الأقل.\",\n        uncompromised: \"كلمة المرور هذه قد ظهرت في تسريب. الرجاء اختيار كلمة مرور أخرى.\",\n    },\n    email: \"يجب أن يكون الحقل بريد إلكتروني صالحاً.\",\n    in_array: \"يجب أن يكون قيمة الحقل واحدة من: :values.\",\n    in: \"يجب أن تكون قيمة الحقل واحدة من: :values.\",\n    regex: \"تنسيق الحقل غير صالح.\",\n    same: \"يجب أن يتطابق الحقل مع :other.\",\n    ends_with: \"يجب أن ينتهي الحقل بأحد القيم: :values.\",\n    starts_with: \"يجب أن يبدأ الحقل بأحد القيم: :values.\",\n    not_in: \"يجب ألا تكون قيمة الحقل واحدة من: :values.\",\n    required_if: \"الحقل مطلوب عندما يكون :other هو :value.\",\n    required: \"هذا الحقل مطلوب.\",\n    uppercase: \"يجب أن يحتوي الحقل على أحرف كبيرة فقط.\",\n    lowercase: \"يجب أن يحتوي الحقل على أحرف صغيرة فقط.\",\n    range: \"يجب أن يكون بين :min و :max.\",\n    multiple_of: \"يجب أن يكون من مضاعفات :number.\",\n    active_url: \"العنوان :attribute ليس رابطاً صالحاً.\",\n    numeric: \"يجب أن يكون :attribute رقماً.\",\n    pattern: \"يجب أن يكون النمط :pattern.\",\n    required_unless: \"هذا الحقل مطلوب إلا إذا كان :other ضمن :values.\",\n    required_with: \"هذا الحقل مطلوب عند تواجد :values.\",\n    required_with_all: \"هذا الحقل مطلوب عند تواجد :values.\",\n    required_without: \"هذا الحقل مطلوب عند عدم تواجد :values.\",\n    required_without_all: \"هذا الحقل مطلوب عند عدم تواجد أي من :values.\",\n    after: \"يجب أن يكون :attribute تاريخاً بعد :date.\",\n    before: \"يجب أن يكون :attribute تاريخاً قبل :date.\",\n};","export default {\n    accepted: \"Das Feld :attribute muss akzeptiert werden.\",\n    date: \"Das Feld muss ein gültiges Datum sein.\",\n    url: \"Das Feld muss eine gültige URL sein.\",\n    ip: \"Das Feld muss eine gültige IP-Adresse sein.\",\n    uuid: \"Das Feld muss eine gültige UUID sein.\",\n    integer: \"Das Feld muss eine ganze Zahl sein.\",\n    alpha_spaces: \"Das Feld darf nur Buchstaben und Leerzeichen enthalten.\",\n    timezone: \"Das Feld muss eine gültige Zeitzone sein.\",\n    credit_card: \"Das Feld muss eine gültige Kreditkartennummer sein.\",\n    phone: \"Das Feld muss eine gültige Telefonnummer sein.\",\n    contains: \"Das Feld muss :value enthalten.\",\n    not_contains: \"Das Feld darf :value nicht enthalten.\",\n    min: {\n        numeric: \"Der Wert muss mindestens :min sein.\",\n        string: \"Der Text muss mindestens :min Zeichen lang sein.\",\n        array: \"Das Array muss mindestens :min Elemente enthalten.\",\n        file: \"Die Datei muss mindestens :min Bytes groß sein.\",\n        files: \"Die Dateien müssen mindestens :min Bytes groß sein.\",\n    },\n    unique: \"Der Wert muss eindeutig sein.\",\n    exists: \"Der Wert muss im Datensatz vorhanden sein.\",\n    max: {\n        numeric: \"Der Wert darf nicht größer als :max sein.\",\n        string: \"Der Text darf nicht länger als :max Zeichen sein.\",\n        array: \"Das Array darf nicht mehr als :max Elemente enthalten.\",\n        file: \"Die Datei darf nicht größer als :max Bytes sein.\",\n        files: \"Die Dateien dürfen nicht größer als :max Bytes sein.\",\n    },\n    image: \"Das Feld :attribute muss ein Bild sein.\",\n    video: \"Das Feld :attribute muss ein Video sein.\",\n    audio: \"Das Feld :attribute muss eine Audiodatei sein.\",\n    digits: \"Das Feld :attribute muss :digits Ziffern haben.\",\n    file: \"Das Feld :attribute muss eine Datei sein.\",\n    files: \"Das Feld :attribute erfordert mindestens eine Datei.\",\n    filled: \"Das Feld :attribute muss einen Wert enthalten.\",\n    mimes: \"Das Feld :attribute muss eine Datei des Typs sein: :values.\",\n    mimetypes: \"Das Feld :attribute muss eine Datei des Typs sein: :values.\",\n    gt: {\n        numeric: \"Der Wert muss größer als :gt sein.\",\n        string: \"Der Text muss länger als :gt Zeichen sein.\",\n        array: \"Das Array muss mehr als :gt Elemente enthalten.\",\n        file: \"Die Datei muss größer als :gt Bytes sein.\",\n        files: \"Die Dateien müssen größer als :gt Bytes sein.\",\n    },\n    lt: {\n        numeric: \"Der Wert muss kleiner als :lt sein.\",\n        string: \"Der Text muss kürzer als :lt Zeichen sein.\",\n        array: \"Das Array muss weniger als :lt Elemente enthalten.\",\n        file: \"Die Datei muss kleiner als :lt Bytes sein.\",\n        files: \"Die Dateien müssen kleiner als :lt Bytes sein.\",\n    },\n    gte: {\n        numeric: \"Der Wert muss mindestens :gte sein.\",\n        string: \"Der Text muss mindestens :gte Zeichen lang sein.\",\n        array: \"Das Array muss mindestens :gte Elemente enthalten.\",\n        file: \"Die Datei muss mindestens :gte Bytes groß sein.\",\n        files: \"Die Dateien müssen mindestens :gte Bytes groß sein.\",\n    },\n    lte: {\n        numeric: \"Der Wert darf höchstens :lte sein.\",\n        string: \"Der Text darf höchstens :lte Zeichen lang sein.\",\n        array: \"Das Array darf höchstens :lte Elemente enthalten.\",\n        file: \"Die Datei darf höchstens :lte Bytes groß sein.\",\n        files: \"Die Dateien dürfen höchstens :lte Bytes groß sein.\",\n    },\n    alpha: \"Das Feld darf nur Buchstaben enthalten.\",\n    alpha_: \"Das Feld darf nur Buchstaben und Unterstriche enthalten.\",\n    alpha_dash: \"Das Feld darf nur Buchstaben, Zahlen, Bindestriche und Unterstriche enthalten.\",\n    alpha_num: \"Das Feld darf nur Buchstaben und Zahlen enthalten.\",\n    boolean: \"Das Feld muss ein boolescher Wert sein.\",\n    confirmed: \"Die Bestätigung des Feldes stimmt nicht überein.\",\n    between: {\n        numeric: \"Der Wert muss zwischen :min und :max liegen.\",\n        string: \"Der Text muss zwischen :min und :max Zeichen lang sein.\",\n        array: \"Das Array muss zwischen :min und :max Elemente enthalten.\",\n        file: \"Die Datei muss zwischen :min und :max Bytes groß sein.\",\n        files: \"Die Dateien müssen zwischen :min und :max Bytes groß sein.\",\n    },\n    password: {\n        length: \"Das Passwort muss mindestens :length Zeichen lang sein.\",\n        letters: \"Das Passwort muss mindestens einen Buchstaben enthalten.\",\n        mixed: \"Das Passwort muss mindestens einen Groß- und einen Kleinbuchstaben enthalten.\",\n        numbers: \"Das Passwort muss mindestens eine Zahl enthalten.\",\n        symbols: \"Das Passwort muss mindestens ein Symbol enthalten.\",\n        uncompromised: \"Das angegebene Passwort wurde in einer Datenpanne gefunden. Bitte wählen Sie ein anderes Passwort.\",\n    },\n    email: \"Das Feld muss eine gültige E-Mail-Adresse sein.\",\n    in_array: \"Der Wert des Feldes muss einer der folgenden sein: :values.\",\n    in: \"Der Wert des Feldes muss einer der folgenden sein: :values.\",\n    regex: \"Das Format des Feldes ist ungültig.\",\n    same: \"Das Feld muss mit dem Feld :other übereinstimmen.\",\n    ends_with: \"Das Feld muss mit einem der folgenden enden: :values.\",\n    starts_with: \"Das Feld muss mit einem der folgenden beginnen: :values.\",\n    not_in: \"Der Wert des Feldes darf keiner der folgenden sein: :values.\",\n    required_if: \"Das Feld ist erforderlich, wenn :other :value ist.\",\n    required: \"Das Feld ist erforderlich.\",\n    uppercase: \"Das Feld darf nur Großbuchstaben enthalten.\",\n    lowercase: \"Das Feld darf nur Kleinbuchstaben enthalten.\",\n    url: \"Das Feld muss eine gültige URL sein.\",\n    uuid: \"Das Feld muss eine gültige UUID sein.\",\n    range: \"Der Wert muss zwischen :min und :max liegen.\",\n    multiple_of: \"Der Wert muss ein Vielfaches von :number sein.\",\n    active_url: \"Das Feld :attribute ist keine gültige URL.\",\n    numeric: \"Das Feld :attribute muss eine Zahl sein.\",\n    pattern: \"Das erwartete Muster ist :pattern.\",\n    required_unless: \"Das Feld :attribute ist erforderlich, es sei denn, :other befindet sich in :values.\",\n    required_with: \"Das Feld :attribute ist erforderlich, wenn :values vorhanden ist.\",\n    required_with_all: \"Das Feld :attribute ist erforderlich, wenn :values vorhanden sind.\",\n    required_without: \"Das Feld :attribute ist erforderlich, wenn :values nicht vorhanden ist.\",\n    required_without_all: \"Das Feld :attribute ist erforderlich, wenn keines der :values vorhanden ist.\",\n    after: \"Das Feld :attribute muss ein Datum nach :date sein.\",\n    before: \"Das Feld :attribute muss ein Datum vor :date sein.\",\n};","export default {\r\n    accepted: \"The :attribute must be accepted.\",\r\n    date: \"The :attribute field must be a valid date.\",\r\n    url: \"The :attribute field must be a valid URL.\",\r\n    ip: \"The :attribute field must be a valid IP address.\",\r\n    uuid: \"The :attribute field must be a valid UUID.\",\r\n    integer: \"The :attribute field must be an integer.\",\r\n    alpha_spaces: \"The :attribute field may only contain letters and spaces.\",\r\n    timezone: \"The :attribute field must be a valid timezone.\",\r\n    credit_card: \"The :attribute field must be a valid credit card number.\",\r\n    phone: \"The :attribute field must be a valid phone number.\",\r\n    contains: \"The :attribute field must contain :value.\",\r\n    not_contains: \"The :attribute field must not contain :value.\",\r\n    min: {\r\n        numeric: \"The :attribute field value must be at least :min.\",\r\n        string: \"The :attribute field length must be at least :min characters.\",\r\n        array: \"The :attribute field must have at least :min items.\",\r\n        file: \"The :attribute field file size must be at least :min bytes.\",\r\n        files: \"The :attribute files sizes must be at least :min bytes.\",\r\n    },\r\n    unique: \"The :attribute field value must be unique.\",\r\n    exists: \"The :attribute field value must exist in the dataset.\",\r\n    max: {\r\n        numeric: \"The :attribute field value must not be greater than :max.\",\r\n        string: \"The :attribute field length must not be greater than :max characters.\",\r\n        array: \"The :attribute field must not have more than :max items.\",\r\n        file: \"The :attribute field file size must not exceed :max bytes.\",\r\n        files: \"The :attribute files sizes must not exceed :max bytes.\",\r\n    },\r\n    image: \"The :attribute must be an image.\",\r\n    video: \"The :attribute must be an video.\",\r\n    audio: \"The :attribute must be an audio.\",\r\n    digits: \"The :attribute must be :digits digits.\",\r\n    file: \"The :attribute must be a file.\",\r\n    files: \"The :attribute expects at least a file to be selected\",\r\n    filled: \"The :attribute field must have a value.\",\r\n    mimes: \"The :attribute must be a file of type: :values.\",\r\n    mimetypes: \"The :attribute must be a file of type: :values.\",\r\n    gt: {\r\n        numeric: \"The :attribute field value must be greater than :gt.\",\r\n        string: \"The :attribute length must be greater than :gt characters.\",\r\n        array: \"The :attribute must have more than :gt items.\",\r\n        file: \"The :attribute file size must be greater than :gt bytes.\",\r\n        files: \"The :attribute files sizes must be greater than :gt bytes.\",\r\n    },\r\n    lt: {\r\n        numeric: \"The :attribute field value must be less than :lt.\",\r\n        string: \"The :attribute field length must be less than :lt characters.\",\r\n        array: \"The :attribute array must have fewer than :lt items.\",\r\n        file: \"The :attribute file size must be less than :lt bytes.\",\r\n        files: \"The :attribute files sizes must be less than :lt bytes.\",\r\n    },\r\n    gte: {\r\n        numeric: \"The :attribute field value must be greater than or equal to :gte.\",\r\n        string: \"The :attribute field length must be greater than or equal to :gte characters.\",\r\n        array: \"The :attribute array must have at least :gte items.\",\r\n        file: \"The :attribute file size must be greater than or equal to :gte bytes.\",\r\n        files: \"The :attribute files sizes must be greater than or equal to :gte bytes.\",\r\n    },\r\n    lte: {\r\n        numeric: \"The :attribute field value must be less than or equal to :lte.\",\r\n        string: \"The :attributee field charater length must be less than or equal to :lte characters.\",\r\n        array: \"The :attribute field must have at most :lte items.\",\r\n        file: \"The :attribute field file size must be less than or equal to :lte bytes.\",\r\n        files: \"The :attribute files sizes must be less than or equal to :lte bytes.\",\r\n    },\r\n    alpha: \"The :attribute field may only contain alphabets\",\r\n    alpha_underscore: \"The :attribute field may only contain letters and underscores.\",\r\n    alpha_dash:\r\n        \"The :attribute field may only contain letters, numbers, dashes, and underscores.\",\r\n    alpha_num: \"The :attribute field may only contain letters and numbers.\",\r\n    boolean: \"The :attribute field must be a boolean value.\",\r\n    confirmed: \"The :attribute field confirmation does not match.\",\r\n    between: {\r\n        numeric: \"The :attribute field value must be between :min and :max.\",\r\n        string: \"The length for the :attribute field must be between :min and :max characters.\",\r\n        array: \"The :attribute field must have between :min and :max items.\",\r\n        file: \"The file size must be between :min and :max bytes.\",\r\n        files: \"The files sizes must be between :min and :max bytes.\",\r\n    },\r\n    password: {\r\n        length: \"The Password must be at least :length characters.\",\r\n        letters: \"The Password must contain at least one letter.\",\r\n        mixed: \"The Password must contain at least one uppercase and one lowercase letter.\",\r\n        numbers: \"The Password must contain at least one number.\",\r\n        symbols: \"The Password must contain at least one symbol.\",\r\n        uncompromised:\r\n            \"The given Password has appeared in a data leak. Please choose a different :attribute.\",\r\n    },\r\n    email: \"The :attribute field must be a valid email address.\",\r\n    in_array: \"The :attribute field value must be one of the following: :values.\",\r\n    in: \"The :attribute field value must be one of the following: :values.\",\r\n    regex: \"The :attribute field format is invalid.\",\r\n    same: \"The :attribute field must match the :other field.\",\r\n    ends_with: \"The :attribute field must end with one of the following: :values.\",\r\n    starts_with:\r\n        \"The :attribute field must start with one of the following: :values.\",\r\n    not_in: \"The :attribute field value must not be one of the following: :values.\",\r\n    required_if: \"The :attribute field is required when :other is :value.\",\r\n    required: \"The :attribute field is required.\",\r\n    uppercase: \"The :attribute field must be uppercase letters only.\",\r\n    lowercase: \"The :attribute field must be lowercase letters only.\",\r\n    url: \"The :attribute field must be a valid URL.\",\r\n    uuid: \"The :attribute field must be a valid UUID.\",\r\n    range: \"The :attribute field value must be between :min and :max.\",\r\n    multiple_of: \"The :attribute field value must be a multiple of :number.\",\r\n    active_url: \"The :attribute field contain an invalid URL.\",\r\n    numeric: \"The :attribute field must have a number.\",\r\n    pattern: \"The :attribute field expected pattern is :pattern\",\r\n    required_unless:\r\n        \"The :attribute field is required unless :other is in :values.\",\r\n    required_with:\r\n        \"The :attribute field is required when :values is present.\",\r\n    required_with_all:\r\n        \"The :attribute field is required when :values are present.\",\r\n    required_without:\r\n        \"The :attribute field is required when :values is not present.\",\r\n    required_without_all:\r\n        \"The :attribute field is required when none of :values are present.\",\r\n    after: 'The :attribute field must be a date after :date.',\r\n    before: 'The :attribute field must be a date before :date.',\r\n};","export default {\n    accepted: \"El campo :attribute debe ser aceptado.\",\n    date: \"El campo debe ser una fecha válida.\",\n    url: \"El campo debe ser una URL válida.\",\n    ip: \"El campo debe ser una dirección IP válida.\",\n    uuid: \"El campo debe ser un UUID válido.\",\n    integer: \"El campo debe ser un número entero.\",\n    alpha_spaces: \"El campo solo puede contener letras y espacios.\",\n    timezone: \"El campo debe ser una zona horaria válida.\",\n    credit_card: \"El campo debe ser un número de tarjeta de crédito válido.\",\n    phone: \"El campo debe ser un número de teléfono válido.\",\n    contains: \"El campo debe contener :value.\",\n    not_contains: \"El campo no debe contener :value.\",\n    min: {\n        numeric: \"El valor debe ser al menos :min.\",\n        string: \"El texto debe tener al menos :min caracteres.\",\n        array: \"El arreglo debe tener al menos :min elementos.\",\n        file: \"El archivo debe tener al menos :min bytes.\",\n        files: \"Los archivos deben tener al menos :min bytes.\",\n    },\n    unique: \"El valor debe ser único.\",\n    exists: \"El valor debe existir en el conjunto de datos.\",\n    max: {\n        numeric: \"El valor no debe ser mayor que :max.\",\n        string: \"El texto no debe tener más de :max caracteres.\",\n        array: \"El arreglo no debe tener más de :max elementos.\",\n        file: \"El archivo no debe exceder :max bytes.\",\n        files: \"Los archivos no deben exceder :max bytes.\",\n    },\n    image: \"El campo :attribute debe ser una imagen.\",\n    video: \"El campo :attribute debe ser un video.\",\n    audio: \"El campo :attribute debe ser un audio.\",\n    digits: \"El campo :attribute debe tener :digits dígitos.\",\n    file: \"El campo :attribute debe ser un archivo.\",\n    files: \"El campo :attribute requiere al menos un archivo.\",\n    filled: \"El campo :attribute debe tener un valor.\",\n    mimes: \"El campo :attribute debe ser un archivo de tipo: :values.\",\n    mimetypes: \"El campo :attribute debe ser un archivo de tipo: :values.\",\n    gt: {\n        numeric: \"El valor debe ser mayor que :gt.\",\n        string: \"El texto debe tener más de :gt caracteres.\",\n        array: \"El arreglo debe tener más de :gt elementos.\",\n        file: \"El archivo debe tener más de :gt bytes.\",\n        files: \"Los archivos deben tener más de :gt bytes.\",\n    },\n    lt: {\n        numeric: \"El valor debe ser menor que :lt.\",\n        string: \"El texto debe tener menos de :lt caracteres.\",\n        array: \"El arreglo debe tener menos de :lt elementos.\",\n        file: \"El archivo debe tener menos de :lt bytes.\",\n        files: \"Los archivos deben tener menos de :lt bytes.\",\n    },\n    gte: {\n        numeric: \"El valor debe ser mayor o igual a :gte.\",\n        string: \"El texto debe tener al menos :gte caracteres.\",\n        array: \"El arreglo debe tener al menos :gte elementos.\",\n        file: \"El archivo debe tener al menos :gte bytes.\",\n        files: \"Los archivos deben tener al menos :gte bytes.\",\n    },\n    lte: {\n        numeric: \"El valor debe ser menor o igual a :lte.\",\n        string: \"El texto debe tener como máximo :lte caracteres.\",\n        array: \"El arreglo debe tener como máximo :lte elementos.\",\n        file: \"El archivo debe tener como máximo :lte bytes.\",\n        files: \"Los archivos deben tener como máximo :lte bytes.\",\n    },\n    alpha: \"El campo solo puede contener letras.\",\n    alpha_: \"El campo solo puede contener letras y guiones bajos.\",\n    alpha_dash: \"El campo solo puede contener letras, números, guiones y guiones bajos.\",\n    alpha_num: \"El campo solo puede contener letras y números.\",\n    boolean: \"El campo debe ser verdadero o falso.\",\n    confirmed: \"La confirmación del campo no coincide.\",\n    between: {\n        numeric: \"El valor debe estar entre :min y :max.\",\n        string: \"El texto debe tener entre :min y :max caracteres.\",\n        array: \"El arreglo debe tener entre :min y :max elementos.\",\n        file: \"El archivo debe tener entre :min y :max bytes.\",\n        files: \"Los archivos deben tener entre :min y :max bytes.\",\n    },\n    password: {\n        length: \"La contraseña debe tener al menos :length caracteres.\",\n        letters: \"La contraseña debe contener al menos una letra.\",\n        mixed: \"La contraseña debe contener al menos una letra mayúscula y una minúscula.\",\n        numbers: \"La contraseña debe contener al menos un número.\",\n        symbols: \"La contraseña debe contener al menos un símbolo.\",\n        uncompromised: \"La contraseña elegida ha sido comprometida en una fuga de datos. Elija otra contraseña.\",\n    },\n    email: \"El campo debe ser una dirección de correo válida.\",\n    in_array: \"El valor del campo debe ser uno de los siguientes: :values.\",\n    in: \"El valor del campo debe ser uno de los siguientes: :values.\",\n    regex: \"El formato del campo es inválido.\",\n    same: \"El campo debe coincidir con el campo :other.\",\n    ends_with: \"El campo debe terminar con uno de los siguientes: :values.\",\n    starts_with: \"El campo debe comenzar con uno de los siguientes: :values.\",\n    not_in: \"El valor del campo no debe ser uno de los siguientes: :values.\",\n    required_if: \"El campo es obligatorio cuando :other es :value.\",\n    required: \"El campo es obligatorio.\",\n    uppercase: \"El campo debe estar en letras mayúsculas.\",\n    lowercase: \"El campo debe estar en letras minúsculas.\",\n    url: \"El campo debe ser una URL válida.\",\n    uuid: \"El campo debe ser un UUID válido.\",\n    range: \"El valor debe estar entre :min y :max.\",\n    multiple_of: \"El valor debe ser un múltiplo de :number.\",\n    active_url: \"El campo :attribute no es una URL válida.\",\n    numeric: \"El campo :attribute debe ser un número.\",\n    pattern: \"El patrón esperado es :pattern.\",\n    required_unless: \"El campo :attribute es obligatorio, a menos que :other esté en :values.\",\n    required_with: \"El campo :attribute es obligatorio cuando :values está presente.\",\n    required_with_all: \"El campo :attribute es obligatorio cuando :values están presentes.\",\n    required_without: \"El campo :attribute es obligatorio cuando :values no está presente.\",\n    required_without_all: \"El campo :attribute es obligatorio cuando ninguno de :values están presentes.\",\n    after: \"El campo :attribute debe ser una fecha posterior a :date.\",\n    before: \"El campo :attribute debe ser una fecha anterior a :date.\",\n};","export default {\n    accepted: \"Le champ :attribute doit être accepté.\",\n    date: \"Le champ doit être une date valide.\",\n    url: \"Le champ doit être une URL valide.\",\n    ip: \"Le champ doit être une adresse IP valide.\",\n    uuid: \"Le champ doit être un UUID valide.\",\n    integer: \"Le champ doit être un entier.\",\n    alpha_spaces: \"Le champ ne peut contenir que des lettres et des espaces.\",\n    timezone: \"Le champ doit être un fuseau horaire valide.\",\n    credit_card: \"Le champ doit être un numéro de carte de crédit valide.\",\n    phone: \"Le champ doit être un numéro de téléphone valide.\",\n    contains: \"Le champ doit contenir :value.\",\n    not_contains: \"Le champ ne doit pas contenir :value.\",\n    min: {\n        numeric: \"La valeur doit être au moins :min.\",\n        string: \"La longueur doit être d'au moins :min caractères.\",\n        array: \"Le tableau doit avoir au moins :min éléments.\",\n        file: \"La taille du fichier doit être d'au moins :min octets.\",\n        files: \"Les tailles des fichiers doivent être d'au moins :min octets.\",\n    },\n    unique: \"La valeur doit être unique.\",\n    exists: \"La valeur doit exister dans le jeu de données.\",\n    max: {\n        numeric: \"La valeur ne doit pas être supérieure à :max.\",\n        string: \"La longueur ne doit pas dépasser :max caractères.\",\n        array: \"Le tableau ne doit pas avoir plus de :max éléments.\",\n        file: \"La taille du fichier ne doit pas dépasser :max octets.\",\n        files: \"Les tailles des fichiers ne doivent pas dépasser :max octets.\",\n    },\n    image: \"Le champ :attribute doit être une image.\",\n    video: \"Le champ :attribute doit être une vidéo.\",\n    audio: \"Le champ :attribute doit être un fichier audio.\",\n    digits: \"Le champ :attribute doit contenir :digits chiffres.\",\n    file: \"Le champ :attribute doit être un fichier.\",\n    files: \"Le champ :attribute doit contenir au moins un fichier.\",\n    filled: \"Le champ :attribute doit avoir une valeur.\",\n    mimes: \"Le champ :attribute doit être un fichier de type: :values.\",\n    mimetypes: \"Le champ :attribute doit être un fichier de type: :values.\",\n    gt: {\n        numeric: \"La valeur doit être supérieure à :gt.\",\n        string: \"La longueur doit être supérieure à :gt caractères.\",\n        array: \"Le tableau doit avoir plus de :gt éléments.\",\n        file: \"La taille du fichier doit être supérieure à :gt octets.\",\n        files: \"Les tailles des fichiers doivent être supérieures à :gt octets.\",\n    },\n    lt: {\n        numeric: \"La valeur doit être inférieure à :lt.\",\n        string: \"La longueur doit être inférieure à :lt caractères.\",\n        array: \"Le tableau doit avoir moins de :lt éléments.\",\n        file: \"La taille du fichier doit être inférieure à :lt octets.\",\n        files: \"Les tailles des fichiers doivent être inférieures à :lt octets.\",\n    },\n    gte: {\n        numeric: \"La valeur doit être supérieure ou égale à :gte.\",\n        string: \"La longueur doit être supérieure ou égale à :gte caractères.\",\n        array: \"Le tableau doit avoir au moins :gte éléments.\",\n        file: \"La taille du fichier doit être supérieure ou égale à :gte octets.\",\n        files: \"Les tailles des fichiers doivent être supérieures ou égales à :gte octets.\",\n    },\n    lte: {\n        numeric: \"La valeur doit être inférieure ou égale à :lte.\",\n        string: \"La longueur doit être inférieure ou égale à :lte caractères.\",\n        array: \"Le tableau doit avoir au plus :lte éléments.\",\n        file: \"La taille du fichier doit être inférieure ou égale à :lte octets.\",\n        files: \"Les tailles des fichiers doivent être inférieures ou égales à :lte octets.\",\n    },\n    alpha: \"Le champ ne peut contenir que des lettres.\",\n    alpha_: \"Le champ ne peut contenir que des lettres et des tirets bas.\",\n    alpha_dash: \"Le champ ne peut contenir que des lettres, des chiffres, des tirets et des tirets bas.\",\n    alpha_num: \"Le champ ne peut contenir que des lettres et des chiffres.\",\n    boolean: \"Le champ doit être une valeur booléenne.\",\n    confirmed: \"La confirmation du champ ne correspond pas.\",\n    between: {\n        numeric: \"La valeur doit être entre :min et :max.\",\n                string: \"La longueur doit être comprise entre :min et :max caractères.\",\n        array: \"Le tableau doit contenir entre :min et :max éléments.\",\n        file: \"La taille du fichier doit être comprise entre :min et :max octets.\",\n        files: \"Les tailles des fichiers doivent être comprises entre :min et :max octets.\",\n    },\n    password: {\n        length: \"Le mot de passe doit contenir au moins :length caractères.\",\n        letters: \"Le mot de passe doit contenir au moins une lettre.\",\n        mixed: \"Le mot de passe doit contenir au moins une majuscule et une minuscule.\",\n        numbers: \"Le mot de passe doit contenir au moins un chiffre.\",\n        symbols: \"Le mot de passe doit contenir au moins un symbole.\",\n        uncompromised: \"Le mot de passe fourni a été trouvé dans une fuite de données. Veuillez en choisir un autre.\",\n    },\n    email: \"Le champ doit être une adresse e-mail valide.\",\n    in_array: \"La valeur du champ doit être l'une des suivantes : :values.\",\n    in: \"La valeur du champ doit être l'une des suivantes : :values.\",\n    regex: \"Le format du champ est invalide.\",\n    same: \"Le champ doit correspondre au champ :other.\",\n    ends_with: \"Le champ doit se terminer par l'une des valeurs suivantes : :values.\",\n    starts_with: \"Le champ doit commencer par l'une des valeurs suivantes : :values.\",\n    not_in: \"La valeur du champ ne doit pas être l'une des suivantes : :values.\",\n    required_if: \"Le champ est requis si :other est égal à :value.\",\n    required: \"Le champ est requis.\",\n    uppercase: \"Le champ ne peut contenir que des lettres majuscules.\",\n    lowercase: \"Le champ ne peut contenir que des lettres minuscules.\",\n    url: \"Le champ doit être une URL valide.\",\n    uuid: \"Le champ doit être un UUID valide.\",\n    range: \"La valeur doit être comprise entre :min et :max.\",\n    multiple_of: \"La valeur doit être un multiple de :number.\",\n    active_url: \"Le champ :attribute n'est pas une URL valide.\",\n    numeric: \"Le champ :attribute doit être un nombre.\",\n    pattern: \"Le modèle attendu est :pattern.\",\n    required_unless: \"Le champ :attribute est requis à moins que :other ne soit dans :values.\",\n    required_with: \"Le champ :attribute est requis lorsque :values est présent.\",\n    required_with_all: \"Le champ :attribute est requis lorsque :values sont présents.\",\n    required_without: \"Le champ :attribute est requis lorsque :values est absent.\",\n    required_without_all: \"Le champ :attribute est requis lorsque aucun des :values n'est présent.\",\n    after: \"Le champ :attribute doit être une date postérieure à :date.\",\n    before: \"Le champ :attribute doit être une date antérieure à :date.\",\n};","export default {\n    accepted: \"इस फ़ील्ड को स्वीकार करना आवश्यक है।\",\n    date: \"फ़ील्ड एक मान्य दिनांक होना चाहिए।\",\n    url: \"फ़ील्ड एक मान्य यूआरएल होना चाहिए।\",\n    ip: \"फ़ील्ड एक मान्य आईपी पता होना चाहिए।\",\n    uuid: \"फ़ील्ड एक मान्य यूयूआईडी होना चाहिए।\",\n    integer: \"फ़ील्ड एक पूर्णांक होना चाहिए।\",\n    alpha_spaces: \"फ़ील्ड में केवल अक्षर और स्पेस हो सकते हैं।\",\n    timezone: \"फ़ील्ड एक मान्य समयक्षेत्र होना चाहिए।\",\n    credit_card: \"फ़ील्ड एक मान्य क्रेडिट कार्ड नंबर होना चाहिए।\",\n    phone: \"फ़ील्ड एक मान्य फ़ोन नंबर होना चाहिए।\",\n    contains: \"फ़ील्ड में :value शामिल होना चाहिए।\",\n    not_contains: \"फ़ील्ड में :value शामिल नहीं होना चाहिए।\",\n    min: {\n        numeric: \"मान कम से कम :min होना चाहिए।\",\n        string: \"लंबाई कम से कम :min वर्ण होनी चाहिए।\",\n        array: \"एरे में कम से कम :min आइटम होने चाहिए।\",\n        file: \"फाइल का आकार कम से कम :min बाइट्स होना चाहिए।\",\n        files: \"फाइलों का आकार कम से कम :min बाइट्स होना चाहिए।\",\n    },\n    unique: \"मान अद्वितीय होना चाहिए।\",\n    exists: \"मान डेटासेट में मौजूद होना चाहिए।\",\n    max: {\n        numeric: \"मान :max से अधिक नहीं होना चाहिए।\",\n        string: \"लंबाई :max वर्णों से अधिक नहीं होनी चाहिए।\",\n        array: \"एरे में :max आइटम से अधिक नहीं हो सकते।\",\n        file: \"फाइल का आकार :max बाइट्स से अधिक नहीं होना चाहिए।\",\n        files: \"फाइलों का आकार :max बाइट्स से अधिक नहीं होना चाहिए।\",\n    },\n    image: \":attribute एक इमेज होनी चाहिए।\",\n    video: \":attribute एक वीडियो होना चाहिए।\",\n    audio: \":attribute एक ऑडियो होना चाहिए।\",\n    digits: \":attribute :digits अंक होना चाहिए।\",\n    file: \":attribute एक फाइल होनी चाहिए।\",\n    files: \":attribute में कम से कम एक फाइल का चयन आवश्यक है।\",\n    filled: \":attribute में एक मान होना चाहिए।\",\n    mimes: \":attribute फ़ाइल प्रकार :values में से एक होनी चाहिए।\",\n    mimetypes: \":attribute फ़ाइल प्रकार :values में से एक होनी चाहिए।\",\n    gt: {\n        numeric: \"मान :gt से बड़ा होना चाहिए।\",\n        string: \"लंबाई :gt वर्णों से अधिक होनी चाहिए।\",\n        array: \"एरे में :gt आइटम से अधिक होने चाहिए।\",\n        file: \"फाइल का आकार :gt बाइट्स से बड़ा होना चाहिए।\",\n        files: \"फाइलों का आकार :gt बाइट्स से बड़ा होना चाहिए।\",\n    },\n    lt: {\n        numeric: \"मान :lt से कम होना चाहिए।\",\n        string: \"लंबाई :lt वर्णों से कम होनी चाहिए।\",\n        array: \"एरे में :lt आइटम से कम होने चाहिए।\",\n        file: \"फाइल का आकार :lt बाइट्स से कम होना चाहिए।\",\n        files: \"फाइलों का आकार :lt बाइट्स से कम होना चाहिए।\",\n    },\n    gte: {\n        numeric: \"मान :gte से अधिक या बराबर होना चाहिए।\",\n        string: \"लंबाई :gte वर्णों से अधिक या बराबर होनी चाहिए।\",\n        array: \"एरे में कम से कम :gte आइटम होने चाहिए।\",\n        file: \"फाइल का आकार :gte बाइट्स से अधिक या बराबर होना चाहिए।\",\n        files: \"फाइलों का आकार :gte बाइट्स से अधिक या बराबर होना चाहिए।\",\n    },\n    lte: {\n        numeric: \"मान :lte से कम या बराबर होना चाहिए।\",\n        string: \"लंबाई :lte वर्णों से कम या बराबर होनी चाहिए।\",\n        array: \"एरे में अधिकतम :lte आइटम होने चाहिए।\",\n        file: \"फाइल का आकार :lte बाइट्स से कम या बराबर होना चाहिए।\",\n        files: \"फाइलों का आकार :lte बाइट्स से कम या बराबर होना चाहिए।\",\n    },\n    alpha: \"फ़ील्ड में केवल अक्षर हो सकते हैं।\",\n    alpha_: \"फ़ील्ड में केवल अक्षर और अंडरस्कोर हो सकते हैं।\",\n    alpha_dash: \"फ़ील्ड में केवल अक्षर, संख्याएँ, डैश और अंडरस्कोर हो सकते हैं।\",\n    alpha_num: \"फ़ील्ड में केवल अक्षर और संख्याएँ हो सकती हैं।\",\n    boolean: \"फ़ील्ड एक बूलियन मान होना चाहिए।\",\n    confirmed: \"फ़ील्ड की पुष्टि मेल नहीं खाती।\",\n    between: {\n        numeric: \"मान :min और :max के बीच होना चाहिए।\",\n        string: \"लंबाई :min और :max वर्णों के बीच होनी चाहिए।\",\n        array: \"एरे में :min और :max आइटम होने चाहिए।\",\n        file: \"फाइल का आकार :min और :max बाइट्स के बीच होना चाहिए।\",\n        files: \"फाइलों का आकार :min और :max बाइट्स के बीच होना चाहिए।\",\n    },\n    password: {\n        length: \"पासवर्ड कम से कम :length वर्ण लंबा होना चाहिए।\",\n        letters: \"पासवर्ड में कम से कम एक अक्षर होना चाहिए।\",\n        mixed: \"पासवर्ड में कम से कम एक बड़ा और एक छोटा अक्षर होना चाहिए।\",\n        numbers: \"पासवर्ड में कम से कम एक संख्या होनी चाहिए।\",\n        symbols: \"पासवर्ड में कम से कम एक प्रतीक होना चाहिए।\",\n        uncompromised: \"दिया गया पासवर्ड डेटा लीक में पाया गया है। कृपया दूसरा पासवर्ड चुनें।\",\n    },\n    email: \"फ़ील्ड एक मान्य ई-मेल पता होना चाहिए।\",\n    in_array: \"फ़ील्ड का मान निम्न में से एक होना चाहिए: :values।\",\n    in: \"फ़ील्ड का मान निम्न में से एक होना चाहिए: :values।\",\n    regex: \"फ़ील्ड का प्रारूप अमान्य है।\",\n    same: \"फ़ील्ड को :other फ़ील्ड से मेल खाना चाहिए।\",\n    ends_with: \"फ़ील्ड निम्न में से एक के साथ समाप्त होना चाहिए: :values।\",\n    starts_with: \"फ़ील्ड निम्न में से एक से शुरू होना चाहिए: :values।\",\n    not_in: \"फ़ील्ड का मान निम्न में से एक नहीं होना चाहिए: :values।\",\n    required_if: \"यह फ़ील्ड आवश्यक है जब :other :value हो।\",\n    required: \"यह फ़ील्ड आवश्यक है।\",\n    uppercase: \"फ़ील्ड में केवल बड़े अक्षर होने चाहिए।\",\n    lowercase: \"फ़ील्ड में केवल छोटे अक्षर होने चाहिए।\",\n    range: \"मान :min और :max के बीच होना चाहिए।\",\n    multiple_of: \"मान :number का गुणक होना चाहिए।\",\n    active_url: \":attribute एक मान्य यूआरएल नहीं है।\",\n    numeric: \":attribute एक संख्या होनी चाहिए।\",\n    pattern: \"अपेक्षित पैटर्न :pattern है।\",\n    required_unless: \":attribute आवश्यक है जब तक :other में :values न हों।\",\n    required_with: \":attribute आवश्यक है जब :values मौजूद हो।\",\n    required_with_all: \":attribute आवश्यक है जब :values मौजूद हों।\",\n    required_without: \":attribute आवश्यक है जब :values मौजूद न हो।\",\n    required_without_all: \":attribute आवश्यक है जब :values में से कोई भी मौजूद न हो।\",\n    after: \":attribute की तिथि :date के बाद होनी चाहिए।\",\n    before: \":attribute की तिथि :date से पहले होनी चाहिए।\",\n};","export default {\n    accepted: \"A ga-anabata :attribute.\",\n    date: \"E kwesị ka ọ bụrụ ụbọchị dị irè.\",\n    url: \"E kwesị ka ọ bụrụ URL dị irè.\",\n    ip: \"E kwesị ka ọ bụrụ adreesị IP dị irè.\",\n    uuid: \"E kwesị ka ọ bụrụ UUID dị irè.\",\n    integer: \"E kwesị ka ọ bụrụ nọmba zuru oke.\",\n    alpha_spaces: \"E kwesị ka ọ bụrụ mkpụrụokwu na oghere naanị.\",\n    timezone: \"E kwesị ka ọ bụrụ oge mpaghara dị irè.\",\n    credit_card: \"E kwesị ka ọ bụrụ nọmba kaadị kredit dị irè.\",\n    phone: \"E kwesị ka ọ bụrụ nọmba ekwentị dị irè.\",\n    contains: \"A ga-enwe :value na ihe a.\",\n    not_contains: \"Ekwesịghị inwe :value na ihe a.\",\n    min: {\n        numeric: \"Ọnụ ahịa kwesịrị ịdịkarịa ala :min.\",\n        string: \"Ogo kwesịrị ịdịkarịa ala :min mkpụrụokwu.\",\n        array: \"A ga-enwe ihe dịkarịa ala :min n'ime.\",\n        file: \"Nha faịlụ kwesịrị ịdịkarịa ala :min byte.\",\n        files: \"Nha faịlụ kwesịrị ịdịkarịa ala :min byte.\",\n    },\n    unique: \"Ọnụ ahịa kwesịrị ịdị iche.\",\n    exists: \"Ọnụ ahịa kwesịrị ịdị n'ime dataset.\",\n    max: {\n        numeric: \"Ọnụ ahịa enweghị ike ịbụ ihe karịrị :max.\",\n        string: \"Ogo enweghị ike ịdịkarịrị :max mkpụrụokwu.\",\n        array: \"N'ime enweghị ike inwe ihe karịrị :max.\",\n        file: \"Nha faịlụ agaghị agakarịrị :max byte.\",\n        files: \"Nha faịlụ agaghị agakarịrị :max byte.\",\n    },\n    image: \"E kwesị ka :attribute bụrụ onyonyo.\",\n    video: \"E kwesị ka :attribute bụrụ vidio.\",\n    audio: \"E kwesị ka :attribute bụrụ ụda.\",\n    digits: \"E kwesị ka :attribute bụrụ :digits ọnụọgụ.\",\n    file: \"E kwesị ka :attribute bụrụ faịlụ.\",\n    files: \"Ọ dịkarịrị ala faịlụ ga-ahọpụta maka :attribute.\",\n    filled: \"A ga-enwe ụkpụrụ maka :attribute.\",\n    mimes: \"E kwesị ka faịlụ ahụ bụrụ ụdị: :values.\",\n    mimetypes: \"E kwesị ka faịlụ ahụ bụrụ ụdị: :values.\",\n    gt: {\n        numeric: \"Ọnụ ahịa kwesịrị ịdị ihe karịrị :gt.\",\n        string: \"Ogo kwesịrị ịdị ihe karịrị :gt mkpụrụokwu.\",\n        array: \"N'ime kwesịrị inwe ihe dịkarịa ala karịa :gt.\",\n        file: \"Nha faịlụ kwesịrị ịdị ihe karịrị :gt byte.\",\n        files: \"Nha faịlụ kwesịrị ịdị ihe karịrị :gt byte.\",\n    },\n    lt: {\n        numeric: \"Ọnụ ahịa kwesịrị ịdị ala karịa :lt.\",\n        string: \"Ogo kwesịrị ịdị ala karịa :lt mkpụrụokwu.\",\n        array: \"N'ime kwesịrị inwe ihe dị ala karịa :lt.\",\n        file: \"Nha faịlụ kwesịrị ịdị ala karịa :lt byte.\",\n        files: \"Nha faịlụ kwesịrị ịdị ala karịa :lt byte.\",\n    },\n    gte: {\n        numeric: \"Ọnụ ahịa kwesịrị ịdị elu ma ọ bụ tọọlite :gte.\",\n        string: \"Ogo kwesịrị ịdị elu ma ọ bụ tọọlite :gte mkpụrụokwu.\",\n        array: \"N'ime kwesịrị inwe ihe dịkarịa ala :gte.\",\n        file: \"Nha faịlụ kwesịrị ịdị elu ma ọ bụ tọọlite :gte byte.\",\n        files: \"Nha faịlụ kwesịrị ịdị elu ma ọ bụ tọọlite :gte byte.\",\n    },\n    lte: {\n        numeric: \"Ọnụ ahịa kwesịrị ịdị ala ma ọ bụ tọọlite :lte.\",\n        string: \"Ogo kwesịrị ịdị ala ma ọ bụ tọọlite :lte mkpụrụokwu.\",\n        array: \"N'ime kwesịrị ịnwe ihe kachasị mma :lte.\",\n        file: \"Nha faịlụ kwesịrị ịdị ala ma ọ bụ tọọlite :lte byte.\",\n        files: \"Nha faịlụ kwesịrị ịdị ala ma ọ bụ tọọlite :lte byte.\",\n    },\n    alpha: \"E kwesị ka :attribute bụ mkpụrụokwu naanị.\",\n    alpha_: \"E kwesị ka ọ bụrụ mkpụrụedemede na ịkpọ ọdịda.\",\n    alpha_dash: \"E kwesị ka ọ bụrụ mkpụrụokwu, ọnụọgụ, ịkpọ ọdịda na ịkpọ isi.\",\n    alpha_num: \"E kwesị ka ọ bụrụ mkpụrụokwu na ọnụọgụ.\",\n    boolean: \"E kwesị ka ọ bụrụ ụkpụrụ boleean.\",\n    confirmed: \"Nkwenye ahụ adịghị dakọtara.\",\n    between: {\n        numeric: \"Ọnụ ahịa kwesịrị ịdị n'etiti :min na :max.\",\n        string: \"Ogo kwesịrị ịdị n'etiti :min na :max mkpụrụokwu.\",\n        array: \"N'ime kwesịrị inwe ihe n'etiti :min na :max.\",\n        file: \"Nha faịlụ kwesịrị ịdị n'etiti :min na :max byte.\",\n        files: \"Nha faịlụ kwesịrị ịdị n'etiti :min na :max byte.\",\n    },\n    password: {\n        length: \"Ogo okwuntughe kwesiri ịdịkarịa ala :length mkpụrụokwu.\",\n        letters: \"Okwuntughe kwesịrị inwe otu mkpụrụedemede ma ọ dịkarịa ala.\",\n        mixed: \"Okwuntughe kwesịrị inwe mkpụrụedemede elu na ala.\",\n        numbers: \"Okwuntughe kwesịrị inwe otu ọnụọgụ ma ọ dịkarịa ala.\",\n        symbols: \"Okwuntughe kwesịrị inwe otu akara pụrụ iche.\",\n        uncompromised: \"Okwuntughe a apụtala n'efu data. Họrọ ihe ọzọ.\",\n    },\n    email: \"E kwesị ka ọ bụrụ adreesị ozi-e dị irè.\",\n    in_array: \"Ọnụ ahịa kwesịrị ịbụ otu n'ime: :values.\",\n    in: \"Ọnụ ahịa kwesịrị ịbụ otu n'ime: :values.\",\n    regex: \"Usoro :attribute ezighi ezi.\",\n    same: \"A ga-edozi ya na :other.\",\n    ends_with: \"A ga-ejedebe na otu n'ime ndị a: :values.\",\n    starts_with: \"A ga-amalite na otu n'ime ndị a: :values.\",\n    not_in: \"Ekwesighi ịbụ otu n'ime :values.\",\n    required_if: \"Ọ dị mkpa ma ọ bụrụ na :other bụ :value.\",\n    required: \"Ọ dị mkpa.\",\n    uppercase: \"E kwesị ka ọ bụrụ mkpụrụokwu dị elu.\",\n    lowercase: \"E kwesị ka ọ bụrụ mkpụrụokwu dị ala.\",\n    url: \"E kwesị ka ọ bụrụ URL dị irè.\",\n    uuid: \"E kwesị ka ọ bụrụ UUID dị irè.\",\n    range: \"Ọnụ ahịa kwesịrị ịdị n'etiti :min na :max.\",\n    multiple_of: \"E kwesị ka ọ bụrụ ọtụtụ :number.\",\n    active_url: \"E kwesị ka :attribute bụrụ URL dị irè.\",\n    numeric: \"E kwesị ka ọ bụrụ ọnụọgụ.\",\n    pattern: \"E kwesị ka usoro dị :pattern.\",\n    required_unless: \"A chọrọ ya belụsọ ma :other dị na :values.\",\n    required_with: \"Ọ dị mkpa mgbe :values dị.\",\n    required_with_all: \"Ọ dị mkpa mgbe niile :values dị.\",\n    required_without: \"Ọ dị mkpa mgbe :values adịghị.\",\n    required_without_all: \"Ọ dị mkpa mgbe ihe ọ bụla n'ime :values adịghị.\",\n    after: \"E kwesị ka :attribute bụrụ ụbọchị mgbe :date gasịrị.\",\n    before: \"E kwesị ka :attribute bụrụ ụbọchị tupu :date.\",\n};","export default {\n    accepted: \"Il campo :attribute deve essere accettato.\",\n    date: \"Il campo deve essere una data valida.\",\n    url: \"Il campo deve essere un URL valido.\",\n    ip: \"Il campo deve essere un indirizzo IP valido.\",\n    uuid: \"Il campo deve essere un UUID valido.\",\n    integer: \"Il campo deve essere un numero intero.\",\n    alpha_spaces: \"Il campo può contenere solo lettere e spazi.\",\n    timezone: \"Il campo deve essere un fuso orario valido.\",\n    credit_card: \"Il campo deve essere un numero di carta di credito valido.\",\n    phone: \"Il campo deve essere un numero di telefono valido.\",\n    contains: \"Il campo deve contenere :value.\",\n    not_contains: \"Il campo non deve contenere :value.\",\n    min: {\n        numeric: \"Il valore deve essere almeno :min.\",\n        string: \"La lunghezza deve essere di almeno :min caratteri.\",\n        array: \"L'array deve contenere almeno :min elementi.\",\n        file: \"La dimensione del file deve essere di almeno :min byte.\",\n        files: \"Le dimensioni dei file devono essere di almeno :min byte.\",\n    },\n    unique: \"Il valore deve essere unico.\",\n    exists: \"Il valore deve esistere nel set di dati.\",\n    max: {\n        numeric: \"Il valore non deve essere maggiore di :max.\",\n        string: \"La lunghezza non deve superare :max caratteri.\",\n        array: \"L'array non deve avere più di :max elementi.\",\n        file: \"La dimensione del file non deve superare :max byte.\",\n        files: \"Le dimensioni dei file non devono superare :max byte.\",\n    },\n    image: \"Il campo :attribute deve essere un'immagine.\",\n    video: \"Il campo :attribute deve essere un video.\",\n    audio: \"Il campo :attribute deve essere un file audio.\",\n    digits: \"Il campo :attribute deve contenere :digits cifre.\",\n    file: \"Il campo :attribute deve essere un file.\",\n    files: \"Il campo :attribute deve contenere almeno un file.\",\n    filled: \"Il campo :attribute deve avere un valore.\",\n    mimes: \"Il campo :attribute deve essere un file di tipo: :values.\",\n    mimetypes: \"Il campo :attribute deve essere un file di tipo: :values.\",\n    gt: {\n        numeric: \"Il valore deve essere maggiore di :gt.\",\n        string: \"La lunghezza deve essere maggiore di :gt caratteri.\",\n        array: \"L'array deve avere più di :gt elementi.\",\n        file: \"La dimensione del file deve essere maggiore di :gt byte.\",\n        files: \"Le dimensioni dei file devono essere maggiori di :gt byte.\",\n    },\n    lt: {\n        numeric: \"Il valore deve essere minore di :lt.\",\n        string: \"La lunghezza deve essere minore di :lt caratteri.\",\n        array: \"L'array deve avere meno di :lt elementi.\",\n        file: \"La dimensione del file deve essere minore di :lt byte.\",\n        files: \"Le dimensioni dei file devono essere minori di :lt byte.\",\n    },\n    gte: {\n        numeric: \"Il valore deve essere maggiore o uguale a :gte.\",\n        string: \"La lunghezza deve essere maggiore o uguale a :gte caratteri.\",\n        array: \"L'array deve contenere almeno :gte elementi.\",\n        file: \"La dimensione del file deve essere maggiore o uguale a :gte byte.\",\n        files: \"Le dimensioni dei file devono essere maggiori o uguali a :gte byte.\",\n    },\n    lte: {\n        numeric: \"Il valore deve essere minore o uguale a :lte.\",\n        string: \"La lunghezza deve essere minore o uguale a :lte caratteri.\",\n        array: \"L'array non deve avere più di :lte elementi.\",\n        file: \"La dimensione del file deve essere minore o uguale a :lte byte.\",\n        files: \"Le dimensioni dei file devono essere minori o uguali a :lte byte.\",\n    },\n    alpha: \"Il campo può contenere solo lettere.\",\n    alpha_: \"Il campo può contenere solo lettere e trattini bassi.\",\n    alpha_dash: \"Il campo può contenere solo lettere, numeri, trattini e trattini bassi.\",\n    alpha_num: \"Il campo può contenere solo lettere e numeri.\",\n    boolean: \"Il campo deve essere un valore booleano.\",\n    confirmed: \"La conferma del campo non corrisponde.\",\n    between: {\n        numeric: \"Il valore deve essere compreso tra :min e :max.\",\n        string: \"La lunghezza deve essere compresa tra :min e :max caratteri.\",\n        array: \"L'array deve contenere tra :min e :max elementi.\",\n        file: \"La dimensione del file deve essere compresa tra :min e :max byte.\",\n        files: \"Le dimensioni dei file devono essere comprese tra :min e :max byte.\",\n    },\n    password: {\n        length: \"La password deve contenere almeno :length caratteri.\",\n        letters: \"La password deve contenere almeno una lettera.\",\n        mixed: \"La password deve contenere almeno una maiuscola e una minuscola.\",\n        numbers: \"La password deve contenere almeno un numero.\",\n        symbols: \"La password deve contenere almeno un simbolo.\",\n        uncompromised: \"La password fornita è apparsa in una violazione dei dati. Scegli un'altra.\",\n    },\n    email: \"Il campo deve essere un indirizzo email valido.\",\n    in_array: \"Il valore del campo deve essere uno dei seguenti: :values.\",\n    in: \"Il valore del campo deve essere uno dei seguenti: :values.\",\n    regex: \"Il formato del campo è non valido.\",\n    same: \"Il campo deve corrispondere al campo :other.\",\n    ends_with: \"Il campo deve terminare con uno dei seguenti: :values.\",\n    starts_with: \"Il campo deve iniziare con uno dei seguenti: :values.\",\n    not_in: \"Il valore del campo non deve essere uno dei seguenti: :values.\",\n    required_if: \"Il campo è richiesto se :other è uguale a :value.\",\n    required: \"Il campo è richiesto.\",\n    uppercase: \"Il campo può contenere solo lettere maiuscole.\",\n    lowercase: \"Il campo può contenere solo lettere minuscole.\",\n    url: \"Il campo deve essere un URL valido.\",\n    uuid: \"Il campo deve essere un UUID valido.\",\n    range: \"Il valore deve essere compreso tra :min e :max.\",\n    multiple_of: \"Il valore deve essere un multiplo di :number.\",\n    active_url: \"Il campo :attribute non è un URL valido.\",\n    numeric: \"Il campo :attribute deve essere un numero.\",\n    pattern: \"Il modello previsto è :pattern.\",\n    required_unless: \"Il campo :attribute è richiesto a meno che :other non sia in :values.\",\n    required_with: \"Il campo :attribute è richiesto quando :values è presente.\",\n    required_with_all: \"Il campo :attribute è richiesto quando :values sono presenti.\",\n    required_without: \"Il campo :attribute è richiesto quando :values è assente.\",\n    required_without_all: \"Il campo :attribute è richiesto quando nessuno dei :values è presente.\",\n    after: \"Il campo :attribute deve essere una data successiva a :date.\",\n    before: \"Il campo :attribute deve essere una data precedente a :date.\",\n};","export default {\n    accepted: \"O campo :attribute deve ser aceito.\",\n    date: \"O campo deve ser uma data válida.\",\n    url: \"O campo deve ser uma URL válida.\",\n    ip: \"O campo deve ser um endereço IP válido.\",\n    uuid: \"O campo deve ser um UUID válido.\",\n    integer: \"O campo deve ser um número inteiro.\",\n    alpha_spaces: \"O campo só pode conter letras e espaços.\",\n    timezone: \"O campo deve ser um fuso horário válido.\",\n    credit_card: \"O campo deve ser um número de cartão de crédito válido.\",\n    phone: \"O campo deve ser um número de telefone válido.\",\n    contains: \"O campo deve conter :value.\",\n    not_contains: \"O campo não deve conter :value.\",\n    min: {\n        numeric: \"O valor deve ser no mínimo :min.\",\n        string: \"O texto deve ter no mínimo :min caracteres.\",\n        array: \"O array deve ter no mínimo :min itens.\",\n        file: \"O arquivo deve ter no mínimo :min bytes.\",\n        files: \"Os arquivos devem ter no mínimo :min bytes.\",\n    },\n    unique: \"O valor deve ser único.\",\n    exists: \"O valor deve existir no conjunto de dados.\",\n    max: {\n        numeric: \"O valor não pode ser maior que :max.\",\n        string: \"O texto não pode ter mais que :max caracteres.\",\n        array: \"O array não pode ter mais que :max itens.\",\n        file: \"O arquivo não pode ser maior que :max bytes.\",\n        files: \"Os arquivos não podem ser maiores que :max bytes.\",\n    },\n    image: \"O campo :attribute deve ser uma imagem.\",\n    video: \"O campo :attribute deve ser um vídeo.\",\n    audio: \"O campo :attribute deve ser um áudio.\",\n    digits: \"O campo :attribute deve ter :digits dígitos.\",\n    file: \"O campo :attribute deve ser um arquivo.\",\n    files: \"É necessário selecionar pelo menos um arquivo no campo :attribute.\",\n    filled: \"O campo :attribute deve ter um valor.\",\n    mimes: \"O campo :attribute deve ser um arquivo do tipo: :values.\",\n    mimetypes: \"O campo :attribute deve ser um arquivo do tipo: :values.\",\n    gt: {\n        numeric: \"O valor deve ser maior que :gt.\",\n        string: \"O texto deve ter mais de :gt caracteres.\",\n        array: \"O array deve ter mais de :gt itens.\",\n        file: \"O arquivo deve ter mais de :gt bytes.\",\n        files: \"Os arquivos devem ter mais de :gt bytes.\",\n    },\n    lt: {\n        numeric: \"O valor deve ser menor que :lt.\",\n        string: \"O texto deve ter menos de :lt caracteres.\",\n        array: \"O array deve ter menos de :lt itens.\",\n        file: \"O arquivo deve ter menos de :lt bytes.\",\n        files: \"Os arquivos devem ter menos de :lt bytes.\",\n    },\n    gte: {\n        numeric: \"O valor deve ser maior ou igual a :gte.\",\n        string: \"O texto deve ter no mínimo :gte caracteres.\",\n        array: \"O array deve ter no mínimo :gte itens.\",\n        file: \"O arquivo deve ter no mínimo :gte bytes.\",\n        files: \"Os arquivos devem ter no mínimo :gte bytes.\",\n    },\n    lte: {\n        numeric: \"O valor deve ser menor ou igual a :lte.\",\n        string: \"O texto deve ter no máximo :lte caracteres.\",\n        array: \"O array deve ter no máximo :lte itens.\",\n        file: \"O arquivo deve ter no máximo :lte bytes.\",\n        files: \"Os arquivos devem ter no máximo :lte bytes.\",\n    },\n    alpha: \"O campo só pode conter letras.\",\n    alpha_: \"O campo só pode conter letras e sublinhados.\",\n    alpha_dash: \"O campo só pode conter letras, números, traços e sublinhados.\",\n    alpha_num: \"O campo só pode conter letras e números.\",\n    boolean: \"O campo deve ser verdadeiro ou falso.\",\n    confirmed: \"A confirmação do campo não confere.\",\n    between: {\n        numeric: \"O valor deve estar entre :min e :max.\",\n        string: \"O texto deve ter entre :min e :max caracteres.\",\n        array: \"O array deve ter entre :min e :max itens.\",\n        file: \"O arquivo deve ter entre :min e :max bytes.\",\n        files: \"Os arquivos devem ter entre :min e :max bytes.\",\n    },\n    password: {\n        length: \"A senha deve ter no mínimo :length caracteres.\",\n        letters: \"A senha deve conter pelo menos uma letra.\",\n        mixed: \"A senha deve conter pelo menos uma letra maiúscula e uma minúscula.\",\n        numbers: \"A senha deve conter pelo menos um número.\",\n        symbols: \"A senha deve conter pelo menos um símbolo.\",\n        uncompromised: \"A senha escolhida foi encontrada em um vazamento de dados. Escolha uma senha diferente.\",\n    },\n    email: \"O campo deve ser um endereço de e-mail válido.\",\n    in_array: \"O valor do campo deve ser um dos seguintes: :values.\",\n    in: \"O valor do campo deve ser um dos seguintes: :values.\",\n    regex: \"O formato do campo é inválido.\",\n    same: \"O campo deve corresponder ao campo :other.\",\n    ends_with: \"O campo deve terminar com um dos seguintes: :values.\",\n    starts_with: \"O campo deve começar com um dos seguintes: :values.\",\n    not_in: \"O valor do campo não deve ser um dos seguintes: :values.\",\n    required_if: \"O campo é obrigatório quando :other é :value.\",\n    required: \"O campo é obrigatório.\",\n    uppercase: \"O campo deve estar em letras maiúsculas.\",\n    lowercase: \"O campo deve estar em letras minúsculas.\",\n    url: \"O campo deve ser uma URL válida.\",\n    uuid: \"O campo deve ser um UUID válido.\",\n    range: \"O valor deve estar entre :min e :max.\",\n    multiple_of: \"O valor deve ser um múltiplo de :number.\",\n    active_url: \"O campo :attribute não é uma URL válida.\",\n    numeric: \"O campo :attribute deve ser um número.\",\n    pattern: \"O formato esperado é :pattern\",\n    required_unless: \"O campo :attribute é obrigatório, a menos que :other esteja em :values.\",\n    required_with: \"O campo :attribute é obrigatório quando :values está presente.\",\n    required_with_all: \"O campo :attribute é obrigatório quando :values estão presentes.\",\n    required_without: \"O campo :attribute é obrigatório quando :values não está presente.\",\n    required_without_all: \"O campo :attribute é obrigatório quando nenhum de :values estão presentes.\",\n    after: 'O campo :attribute deve ser uma data após :date.',\n    before: 'O campo :attribute deve ser uma data antes de :date.',\n};","export default {\n    accepted: \"Поле :attribute должно быть принято.\",\n    date: \"Поле должно быть действительной датой.\",\n    url: \"Поле должно быть действительным URL-адресом.\",\n    ip: \"Поле должно быть действительным IP-адресом.\",\n    uuid: \"Поле должно быть действительным UUID.\",\n    integer: \"Поле должно быть целым числом.\",\n    alpha_spaces: \"Поле может содержать только буквы и пробелы.\",\n    timezone: \"Поле должно быть действительным часовым поясом.\",\n    credit_card: \"Поле должно быть действительным номером кредитной карты.\",\n    phone: \"Поле должно быть действительным номером телефона.\",\n    contains: \"Поле должно содержать :value.\",\n    not_contains: \"Поле не должно содержать :value.\",\n    min: {\n        numeric: \"Значение должно быть не менее :min.\",\n        string: \"Длина должна быть не менее :min символов.\",\n        array: \"Массив должен содержать не менее :min элементов.\",\n        file: \"Размер файла должен быть не менее :min байтов.\",\n        files: \"Размер файлов должен быть не менее :min байтов.\",\n    },\n    unique: \"Значение должно быть уникальным.\",\n    exists: \"Значение должно существовать в наборе данных.\",\n    max: {\n        numeric: \"Значение не должно превышать :max.\",\n        string: \"Длина не должна превышать :max символов.\",\n        array: \"Массив не должен содержать более :max элементов.\",\n        file: \"Размер файла не должен превышать :max байтов.\",\n        files: \"Размер файлов не должен превышать :max байтов.\",\n    },\n    image: \"Поле :attribute должно быть изображением.\",\n    video: \"Поле :attribute должно быть видео.\",\n    audio: \"Поле :attribute должно быть аудио.\",\n    digits: \"Поле :attribute должно содержать :digits цифр.\",\n    file: \"Поле :attribute должно быть файлом.\",\n    files: \"Поле :attribute требует как минимум одного файла.\",\n    filled: \"Поле :attribute должно содержать значение.\",\n    mimes: \"Поле :attribute должно быть файлом типа: :values.\",\n    mimetypes: \"Поле :attribute должно быть файлом типа: :values.\",\n    gt: {\n        numeric: \"Значение должно быть больше :gt.\",\n        string: \"Длина должна быть больше :gt символов.\",\n        array: \"Массив должен содержать более :gt элементов.\",\n        file: \"Размер файла должен быть больше :gt байтов.\",\n        files: \"Размер файлов должен быть больше :gt байтов.\",\n    },\n    lt: {\n        numeric: \"Значение должно быть меньше :lt.\",\n        string: \"Длина должна быть меньше :lt символов.\",\n        array: \"Массив должен содержать менее :lt элементов.\",\n        file: \"Размер файла должен быть меньше :lt байтов.\",\n        files: \"Размер файлов должен быть меньше :lt байтов.\",\n    },\n    gte: {\n        numeric: \"Значение должно быть больше или равно :gte.\",\n        string: \"Длина должна быть больше или равна :gte символам.\",\n        array: \"Массив должен содержать как минимум :gte элементов.\",\n        file: \"Размер файла должен быть больше или равен :gte байтам.\",\n        files: \"Размер файлов должен быть больше или равен :gte байтам.\",\n    },\n    lte: {\n        numeric: \"Значение должно быть меньше или равно :lte.\",\n        string: \"Длина должна быть меньше или равна :lte символам.\",\n        array: \"Массив должен содержать не более :lte элементов.\",\n        file: \"Размер файла должен быть меньше или равен :lte байтам.\",\n        files: \"Размер файлов должен быть меньше или равен :lte байтам.\",\n    },\n    alpha: \"Поле может содержать только буквы.\",\n    alpha_: \"Поле может содержать только буквы и подчеркивания.\",\n    alpha_dash: \"Поле может содержать только буквы, цифры, дефисы и подчеркивания.\",\n    alpha_num: \"Поле может содержать только буквы и цифры.\",\n    boolean: \"Поле должно быть логическим значением.\",\n    confirmed: \"Подтверждение поля не совпадает.\",\n    between: {\n        numeric: \"Значение должно быть между :min и :max.\",\n        string: \"Длина должна быть между :min и :max символами.\",\n        array: \"Массив должен содержать от :min до :max элементов.\",\n        file: \"Размер файла должен быть между :min и :max байт.\",\n        files: \"Размер файлов должен быть между :min и :max байт.\",\n    },\n    password: {\n        length: \"Пароль должен содержать не менее :length символов.\",\n        letters: \"Пароль должен содержать как минимум одну букву.\",\n        mixed: \"Пароль должен содержать как минимум одну заглавную и одну строчную букву.\",\n        numbers: \"Пароль должен содержать как минимум одну цифру.\",\n        symbols: \"Пароль должен содержать как минимум один символ.\",\n        uncompromised: \"Указанный пароль появился в утечке данных. Пожалуйста, выберите другой :attribute.\",\n    },\n    email: \"Поле должно быть действительным адресом электронной почты.\",\n    in_array: \"Значение поля должно быть одним из следующих: :values.\",\n    in: \"Значение поля должно быть одним из следующих: :values.\",\n    regex: \"Формат поля недействителен.\",\n    same: \"Поле должно соответствовать полю :other.\",\n    ends_with: \"Поле должно заканчиваться на одно из следующих: :values.\",\n    starts_with: \"Поле должно начинаться с одного из следующих: :values.\",\n    not_in: \"Значение поля не должно быть одним из следующих: :values.\",\n    required_if: \"Поле обязательно, если :other равно :value.\",\n    required: \"Поле обязательно.\",\n    uppercase: \"Поле должно содержать только заглавные буквы.\",\n    lowercase: \"Поле должно содержать только строчные буквы.\",\n    url: \"Поле должно быть действительным URL-адресом.\",\n    uuid: \"Поле должно быть действительным UUID.\",\n    range: \"Значение должно быть между :min и :max.\",\n    multiple_of: \"Значение должно быть кратным :number.\",\n    active_url: \"Поле :attribute не является действительным URL.\",\n    numeric: \"Поле :attribute должно быть числом.\",\n    pattern: \"Ожидаемый шаблон: :pattern.\",\n    required_unless: \"Поле :attribute обязательно, если :other не находится в :values.\",\n    required_with: \"Поле :attribute обязательно, когда :values присутствует.\",\n    required_with_all: \"Поле :attribute обязательно, когда :values присутствуют.\",\n    required_without: \"Поле :attribute обязательно, когда :values отсутствует.\",\n    required_without_all: \"Поле :attribute обязательно, когда ни одно из :values не присутствует.\",\n    after: \"Поле :attribute должно быть датой после :date.\",\n    before: \"Поле :attribute должно быть датой до :date.\",\n};","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import * as _F from './core/main';\r\nimport * as _u from './core/utils';\r\nimport * as _c from './core/cookie';\r\n\r\nconst cookie = _c.default;\r\nconst utils = _u.default;\r\nconst FormGuard = _F.FormGuard;\r\n\r\n\r\n// Assign to the global object (window in the browser or exports in Node.js)\r\nif (typeof window !== 'undefined') {\r\n  window.FormGuard = FormGuard;\r\n} else if (typeof exports !== 'undefined') {\r\n  exports.cookie = cookie;\r\n  exports.utils = utils;\r\n  exports.FormGuard = FormGuard;\r\n}\r\n\r\nconsole.log('test')\r\n  \r\n// export { cookie, utils, FormGuard };"],"names":[],"sourceRoot":""}