(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/core/config.js":
/*!****************************!*\
  !*** ./src/core/config.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _locales_en__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../locales/en */ "./src/locales/en.js");
/* harmony import */ var _locales_ig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../locales/ig */ "./src/locales/ig.js");
/* harmony import */ var _locales_ar__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../locales/ar */ "./src/locales/ar.js");
/* harmony import */ var _locales_de__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../locales/de */ "./src/locales/de.js");
/* harmony import */ var _locales_es__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../locales/es */ "./src/locales/es.js");
/* harmony import */ var _locales_fr__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../locales/fr */ "./src/locales/fr.js");
/* harmony import */ var _locales_hi__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../locales/hi */ "./src/locales/hi.js");
/* harmony import */ var _locales_lt__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../locales/lt */ "./src/locales/lt.js");
/* harmony import */ var _locales_pt__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../locales/pt */ "./src/locales/pt.js");
/* harmony import */ var _locales_ru__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../locales/ru */ "./src/locales/ru.js");











/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({ 
    debug: true,

    locales: {
        en: _locales_en__WEBPACK_IMPORTED_MODULE_0__["default"],                 // Primary Local should come first before other locales
        ig: _locales_ig__WEBPACK_IMPORTED_MODULE_1__["default"],
        ar: _locales_ar__WEBPACK_IMPORTED_MODULE_2__["default"],
        de: _locales_de__WEBPACK_IMPORTED_MODULE_3__["default"],
        es: _locales_es__WEBPACK_IMPORTED_MODULE_4__["default"],
        fr: _locales_fr__WEBPACK_IMPORTED_MODULE_5__["default"],
        hi: _locales_hi__WEBPACK_IMPORTED_MODULE_6__["default"],
        lt: _locales_lt__WEBPACK_IMPORTED_MODULE_7__["default"],
        pt: _locales_pt__WEBPACK_IMPORTED_MODULE_8__["default"],
        ru: _locales_ru__WEBPACK_IMPORTED_MODULE_9__["default"]

    },     

    file_patterns: {
        image: [
            /^image\/(png|gif|jpe?g)/,
        ],
        video: [
            /^video\/(.+?)/,
        ],
        pdf: [
            /application\/json/
        ],
        document: [
            /application\/json/
        ],
    },

    attributes: {
        // email: "Email Address",
        // first_name: "First Name",
        // last_name: "Last Name",
        // phone: "Phone Number"
    },


    customRules: {
        // exist: {
        //     fn: async ({value}) => {
        //         try {
        //             const user = await fetch('/api/user_end_point', {
        //                 body: JSON.stringify({username: value})
        //             });
        //             return user;
        //         } catch(e) {}
        //     },
        //     message: 'User account already exists'
        // },

        // // add others
    }
});

/***/ }),

/***/ "./src/core/cookie/index.js":
/*!**********************************!*\
  !*** ./src/core/cookie/index.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    write(name, value, expires, path, domain, secure) {
        let config = {
            expires: expires || Date.now() + (60 * 60 * 24 * 365),
            path,
            domain,
            secure,
        };

        if (typeof expires === 'object' && expires !== null && !Array.isArray(expires)) {
            config = {
                ...config, ...expires
            }
        }
        
        const cookie = [name + "=" + encodeURIComponent(value)];

        typeof config.expires === "number" &&
            cookie.push("expires=" + new Date(config.expires).toGMTString());

        typeof config.path === "string" && cookie.push("path=" + config.path);

        typeof config.domain === "string" && cookie.push("domain=" + config.domain);

        config.secure === true && cookie.push("secure");
        
        document.cookie = cookie.join("; ");

        return value;
    },


    read(name) {
        if (typeof name !== "string") return null;
        const match = document.cookie.match(
            new RegExp("(^|;\\s*)(" + name + ")=([^;]*)")
        );
        return match ? decodeURIComponent(match[3]) : null;
    },

    remove(name) {
        const value = this.read(name);

        if (value) {
            this.write(name, "", Date.now() - 86400000);
        }
        return value;
    },
});


/***/ }),

/***/ "./src/core/exceptions/index.js":
/*!**************************************!*\
  !*** ./src/core/exceptions/index.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KnownError: () => (/* binding */ KnownError),
/* harmony export */   ValidationError: () => (/* binding */ ValidationError)
/* harmony export */ });
class ValidationError extends Error {
    constructor(message) {
        super(message);
        this.message = `[@VGuard/Validator]: ${message}`;
        this.name = "ValidationError";
    }
}

class KnownError extends EvalError {
    constructor(message) {
        super(message);
        this.message = message;
        this.name = "KnownError";
    }
}

/***/ }),

/***/ "./src/core/main/index.js":
/*!********************************!*\
  !*** ./src/core/main/index.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FormGuard: () => (/* binding */ FormGuard)
/* harmony export */ });
/* harmony import */ var _exceptions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../exceptions */ "./src/core/exceptions/index.js");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../config */ "./src/core/config.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils */ "./src/core/utils/index.js");




const _keys = Object.keys(_config__WEBPACK_IMPORTED_MODULE_1__["default"].locales);
const system_locale = _keys.length > 0 ? _keys[0] : 'en';

const registers = {
    types: [
        "blob",
        "date",
        "datetime",
        "array",
        "object",
        "numeric",
        "integer",
        "string",
        "file",
        "files",
        "boolean",
        "url",
        "ip",
        "email",
        "uuid"
    ],
    stabilizers: ["trim", "capitalize", "format_date"],
    fillables: [
        "if_empty",
        "fill",
        "fillable",
        "nullable",
        "required",
        "required_if",
        "required_unless",
        "required_with",
        "required_with_all",
        "required_without",
        "required_without_all",
    ],
};


class FormGuard {
    _hasFile = false;
    static locale_keys = _keys;
    static locale = system_locale;
    static _translations = {};
    static _fallback_messages;
    static _debug = false;
    static user_defined_messages = {};

    static registers = registers;

    constructor(data, rules = null, messages = {}, attributes = {}) {
        FormGuard.user_defined_messages;
        console.log('testing');
        this.setAttributes(attributes);
        this._errors = {};
        this._hasFile = false;
        FormGuard._translations = _config__WEBPACK_IMPORTED_MODULE_1__["default"].locales;
        FormGuard._debug = _config__WEBPACK_IMPORTED_MODULE_1__["default"].debug;
        
        this.loadFallbackMessages();
        this._file_patterns = _utils__WEBPACK_IMPORTED_MODULE_2__["default"].isPlainObject(_config__WEBPACK_IMPORTED_MODULE_1__["default"].file_patterns) ? _config__WEBPACK_IMPORTED_MODULE_1__["default"].file_patterns : {};
        FormGuard.user_defined_messages = {};

        this._skips = [];
        this._rules = {};

        this._data = { ...data };

        FormGuard.add(_config__WEBPACK_IMPORTED_MODULE_1__["default"].customRules);
        FormGuard.setMessages(messages);

        this.parseRules(rules);
    }

    init() {
        FormGuard.registers = {
            types: [
                "blob",
                "date",
                "datetime",
                "array",
                "object",
                "numeric",
                "integer",
                "string",
                "file",
                "files",
                "boolean",
            ],
            stabilizers: ["trim", "capitalize", "format_date"],
            fillables: [
                "if_empty",
                "fill",
                "fillable",
                "nullable",
                "required",
                "required_if",
                "required_unless",
                "required_with",
                "required_with_all",
                "required_without",
                "required_without_all",
            ],
        };
    

    }

    static log(type, ...args) {
        if (this._debug && console[type]) {
            console[type](...args);
        }
    }

    static setSystemMessages(messages, name) {
        this._translations = _utils__WEBPACK_IMPORTED_MODULE_2__["default"].castObject(this._translations);

        _utils__WEBPACK_IMPORTED_MODULE_2__["default"].forEach(this._translations, (messages, locale) => {
            delete this._translations[locale][name];
        })

        _utils__WEBPACK_IMPORTED_MODULE_2__["default"].forEach(messages, (message, key) => {
            const [message_key, locale] = this.getKeys(key);
            this._translations[locale] = {
                ..._utils__WEBPACK_IMPORTED_MODULE_2__["default"].castObject(this._translations[locale]),
                [message_key]:message
            }
        });
        this._fallback_messages = this._translations[FormGuard.locale]
    }

    static setMessages(messages) {

        this.user_defined_messages = _utils__WEBPACK_IMPORTED_MODULE_2__["default"].castObject(this.user_defined_messages);

        if (!_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isPlainObject(messages)) {
            throw new _exceptions__WEBPACK_IMPORTED_MODULE_0__.ValidationError(
                `Default Messages must be an object, but ${
                    messages === null ? "NULL" : typeof messages
                } was provided`
            );
        }


        _utils__WEBPACK_IMPORTED_MODULE_2__["default"].forEach(messages, (default_message, attr) => {
            const [message_key, locale] = this.getKeys(attr);

            const fallback = message_key + "$" + system_locale;

            if (locale !== system_locale) {
                if (
                    _utils__WEBPACK_IMPORTED_MODULE_2__["default"].isUndefined(messages[fallback]) &&
                    _utils__WEBPACK_IMPORTED_MODULE_2__["default"].isUndefined(messages[message_key])
                ) {
                    const example = {
                        ...messages,
                        [message_key]: "This is an error Message",
                    };
                    this.log('warn', 
                        `Default message for "${message_key}" is missing. Defining message for ${message_key} will serve as fallback in case the user language is not available. So ensure it's written in english.\n\nExample:\n${JSON.stringify(
                            example
                        )}`
                    );
                }
            }
            if (
                !_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isUndefined(default_message) &&
                !_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isString(default_message)
            ) {
                throw new _exceptions__WEBPACK_IMPORTED_MODULE_0__.ValidationError(
                    `Default Message type for ${attr} is ${
                        default_message === null
                            ? "NULL"
                            : typeof default_message
                    }. But String was expected`
                );
            }

            this.user_defined_messages[locale] = {
                ...(_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isPlainObject(this.user_defined_messages[locale])
                    ? this.user_defined_messages[locale]
                    : {}),
                [message_key]: default_message,
            };
        });
    }

    //name, password, letters
    //obj, attribute, rule, type
    //namePasswordLetters
    //namePasswordSymbols
    //namePassword

    getUserMessages({attribute, rule, type}, holder, defaultValue) {
        const holderArgs = [attribute, rule, holder].filter(arg => _utils__WEBPACK_IMPORTED_MODULE_2__["default"].isString(arg));
        const ruleArgs = [attribute, rule];

        const getValue = (key) => {
            const user_defined_messages = FormGuard.user_defined_messages[FormGuard.locale] || FormGuard.user_defined_messages.en;
            return user_defined_messages?.[key];
        };

        defaultValue = defaultValue||"validation."+rule;

        const matches = [
            this.snakeCase(...holderArgs),
            this.snakeCase(...ruleArgs),
            holderArgs.join('.'),
            ruleArgs.join('.')
        ]
        .map(result => getValue(result))
        .find(data => _utils__WEBPACK_IMPORTED_MODULE_2__["default"].isString(data));
        

        if (matches) {
            return matches;
        }
        else {
            const fallback = _utils__WEBPACK_IMPORTED_MODULE_2__["default"].objectGet(FormGuard._fallback_messages, rule);
            if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isString(fallback)) {
                return fallback;
            }
            else if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isPlainObject(fallback)) {
                return fallback[holder || type] || defaultValue;
            }

            return defaultValue;
        }
        
    }


    static setLocale(locale) { 
        FormGuard.locale = locale;
    }

   

    data(obj) {
        if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isPlainObject(obj)) {
            this._data = obj;
        }
        return this;
    }

    all() {
        this._errors = {};
        this._skips = [];

        return new Promise(async (resolve, reject) => {
            for (const [attribute, data] of Object.entries(this._rules)) {
                for (const item of data) {
                    const { args, callback } = item;
                    await callback(...args);
                }
            }
            const errorKeys = Object.keys(this._errors);

            if (errorKeys.length > 0) {
                return reject(this._errors);
            }

            const entries = Object.entries(this._data).filter(
                ([key]) => !errorKeys.includes(key)
            );
            const validated = Object.fromEntries(entries);
            const formData = this.convertDataToFormData(validated);

            resolve({ validated, formData });
        });
    }
    clearAll() {
        this._errors = {};
    }

    only(attributes) {
        if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isString(attributes)) {
            attributes = [attributes];
        }

        return new Promise(async (resolve, reject) => {
            let errors = {};
            let attrs = [];

            if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isArray(attributes)) {
                attrs = attributes;
                const rules = Object.entries(this._rules).filter(
                    ([key]) => attrs.includes(key)
                );

                for (const [attribute, data] of rules) {
                    // reset errors
                    delete this._errors[attribute];

                    for (const item of data) {
                        const { args, callback } = item;
                        await callback(...args);
                    }
                }

                errors = Object.fromEntries(
                    Object.entries(this._errors).filter(([key]) =>
                        attrs.includes(key)
                    )
                );
            } else if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isPlainObject(attributes)) {
                attrs = Object.keys(attributes);
                const rules = Object.entries(this._rules).filter(
                    ([key]) => attrs.includes(key)
                );

                for (const [attribute, data] of rules) {
                    delete this._errors[attribute];
                    if (attribute in attributes) {
                        this._data[attribute] = attributes[attribute];
                    }

                    for (const item of data) {
                        await item.callback(...item.args);
                    }
                }

                errors = Object.fromEntries(
                    Object.entries(this._errors).filter(([key]) =>
                        attrs.includes(key)
                    )
                );
            }

            if (Object.keys(errors).length > 0) {
                return reject(this._errors);
            }

            const entries = Object.entries(this._data).filter(([key]) =>
                attrs.includes(key)
            );
            const validated = Object.fromEntries(entries);
            const formData = this.convertDataToFormData(validated);

            resolve({ validated, formData });
        });
    }


    validate(attributes) {
        attributes = attributes || this.getData();
        
        if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isString(attributes)) {
            attributes = {[attributes]:this._data[attributes]}
        }
            else if (!_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isPlainObject(attributes)) {
                throw new _exceptions__WEBPACK_IMPORTED_MODULE_0__.ValidationError(
                    `Data should be an object`
                );
            }

            return new Promise(async (resolve, reject) => {
            try {
                let errors = {};
                let attrs = [];

                if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isArray(attributes)) {
                    attrs = attributes;
                    const rules = Object.entries(this._rules).filter(
                        ([key]) => attrs.includes(key)
                    );
                    for (const [attribute, data] of rules) {
                        // reset errors
                        delete this._errors[attribute];

                        
                        for (const item of data) {
                            const { args, callback } = item;
                            await callback(...args);
                        }
                    }

                    errors = Object.fromEntries(
                        Object.entries(this._errors).filter(([key]) =>
                            attrs.includes(key)
                        )
                    );
                } else if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isPlainObject(attributes)) {
                    attrs = Object.keys(attributes);
                    const rules = Object.entries(this._rules).filter(
                        ([key]) => attrs.includes(key)
                    );

                    for (const [attribute, data] of rules) {
                        delete this._errors[attribute];
                        if (attribute in attributes) {
                            this._data[attribute] = attributes[attribute];
                        }


                        for (const item of data) {
                            await item.callback(...item.args);
                        }
                    }

                    errors = Object.fromEntries(
                        Object.entries(this._errors).filter(([key]) =>
                            attrs.includes(key)
                        )
                    );
                }

                if (Object.keys(errors).length > 0) {
                    return reject(this._errors);
                }

                const entries = Object.entries(this._data).filter(([key]) =>
                    attrs.includes(key)
                );
                const validated = Object.fromEntries(entries);
                const formData = this.convertDataToFormData(validated);

                resolve({ validated, formData });
                } catch(e) {
                    FormGuard.log('error', e);

                    let errors = this._errors;
                    if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isEmpty(errors)) {
                        errors = {error:'Failed to validate'};
                    }
                    
                    reject(errors);
                }
            });
    }

    static async make(data, rules = null, messages = {}, attributes = {}) {
        const validator = new FormGuard(data, rules, messages, attributes);

        return validator.validate();
    }

    successfully__passed__validation(obj) {
        if (this.skippedValidation(obj)) return;
        this.clearErrorMessage(obj);
        FormGuard.log('info', 'Successfully validated '+obj.attribute)
    }

    /**
     * TYPE RULES (types)
     *
     * @method blob
     * @method date
     * @method datetime
     * @method array
     * @method object
     * @method numeric
     * @method integer
     * @method string
     * @method file
     * @method files
     * @method boolean
     * @method email
     * @method uuid 
     * @method ip 
     * @method url
     *
     */

    async blob(obj) {
        const data = this.getData(obj);

        this.clearIF(_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isBlob(data), obj)
    }

    async date(obj) {
        const data = this.getData(obj);
        if (this.skippedValidation(obj)) return;
        const date = new Date(data);
        const validated = !isNaN(date.getFullYear());

        if (validated) {
            this.setData(obj, _utils__WEBPACK_IMPORTED_MODULE_2__["default"].format_date(date, 'yyyy-mm-dd'));
        }

        this.clearIF(validated, obj);

    }

    async datetime(obj) {
        const data = this.getData(obj);
        if (this.skippedValidation(obj)) return;
        const date = new Date(data);
        const validated = !isNaN(date.getSeconds());

        if (validated) {
            this.setData(obj, _utils__WEBPACK_IMPORTED_MODULE_2__["default"].format_date(date, 'yyyy-mm-dd H:i:s'));
        }

        this.clearIF(validated, obj);

    }

    async time(obj) {
        const data = this.getData(obj);
        if (this.skippedValidation(obj)) return;
        const date = new Date(data);
        const validated = !isNaN(date.getHours());

        if (validated) {
            this.setData(obj, _utils__WEBPACK_IMPORTED_MODULE_2__["default"].format_date(date, 'H:i:s'));
        }

        this.clearIF(validated, obj);

    }


    async timestamp(obj) {
        let validated = false;
        try {
            const data = this.getData(obj);
            const time = Date.parse(data);
            validated = !isNaN(time);

            if (validated) {
                return this.setData(obj, time);
            }

        } catch(e) {};

        this.clearIF(
            validated,
            obj
        );
    }

    async array(obj) {
        if (this.skippedValidation(obj)) return;

        this.clearIF(_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isArray(this.getData(obj)), obj);
        
    }

    async numeric(obj) {
        if (this.skippedValidation(obj)) return;

        const data = this.getData(obj);
        const num = _utils__WEBPACK_IMPORTED_MODULE_2__["default"].isNumeric(data);

        this.clearIF(
            num,
            obj
        );
        if (num) {
            this.setData(obj, num);
        }

    }

    async integer(obj) {
        if (this.skippedValidation(obj)) return;

        const data = this.getData(obj);
        const intData = _utils__WEBPACK_IMPORTED_MODULE_2__["default"].isInteger(data);

        this.clearIF(
            intData,
            obj
        );
        if (intData) {
            this.setData(obj, intData);
        }

    }

    async string(obj) {
        if (this.skippedValidation(obj)) return;
        let data = this.getData(obj);

        if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isNumber(data)) {
            data = `${data}`;
        }

        this.clearIF(
            _utils__WEBPACK_IMPORTED_MODULE_2__["default"].isString(data),
            obj
        );
        this.setData(obj, data);
    }

    matchFile(file, types) {
        const matchPattern = (pattern) => {
            if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isArray(file)) {
                return file.every((item) => pattern.test(item.type));
            } else if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isFileList(file)) {
                return Array.from(file).every((item) =>
                    pattern.test(item.type)
                );
            } else if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isFile(file)) {
                return pattern.test(file.type);
            }
            return false;
        };

        return types.some((type) => {
            const patterns = this._file_patterns[type];

            if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isArray(patterns)) {
                return patterns.some((pattern) => {
                    return matchPattern(pattern);
                });
            } else if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isRegExp(patterns)) {
                return matchPattern(patterns);
            }
            return false;
        });
    }

    async file(obj, ...types) {
        if (this.skippedValidation(obj)) return;

        const data = this.getData(obj);
        const hasAttr = types[0] !== true;

        if (
            _utils__WEBPACK_IMPORTED_MODULE_2__["default"].isArray(data) &&
            data.length > 0 &&
            _utils__WEBPACK_IMPORTED_MODULE_2__["default"].isFile(data[data.length - 1])
        ) {
            const file = data[data.length - 1];

            if (hasAttr && !this.matchFile(data, types)) {
                return this.loadErrorMessage(
                    obj,
                    `File must be either ${_utils__WEBPACK_IMPORTED_MODULE_2__["default"].join(types, ", ", " or ")}`
                );
            }

            this.setData(obj, file);
        } else if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isFile(data) || _utils__WEBPACK_IMPORTED_MODULE_2__["default"].isFileList(data)) {
            if (hasAttr && !this.matchFile(data, types)) {
                return this.loadErrorMessage(
                    obj,
                    `File must be either ${_utils__WEBPACK_IMPORTED_MODULE_2__["default"].join(types, ", ", " or ")}`
                );
            }

            if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isFileList(data) && data.length > 0) {
                this.setData(obj, data[data.length - 1]);
            }
            return this.clearErrorMessage(obj);
        }

        this.loadErrorMessage(obj);
    }

    isFile(data) {
        if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isFileList(data) || _utils__WEBPACK_IMPORTED_MODULE_2__["default"].isFile(data)) return true;
        else if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isArray(data)) {
            return data.every((file) => _utils__WEBPACK_IMPORTED_MODULE_2__["default"].isFile(file));
        }
        return false;
    }

    async files(obj, ...types) {
        if (this.skippedValidation(obj)) return;
        let data = this.getData(obj);
        const hasAttr = types[0] !== true;

        if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isFileList(data)) {
            data = Array.from(data);
        } else if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isFile(data)) {
            data = [data];
        }
        this.setData(obj, data);

        if (this.isFile(data)) {
            if (hasAttr && !this.matchFile(data, types)) {
                return this.loadErrorMessage(
                    obj,
                    `File must be either ${_utils__WEBPACK_IMPORTED_MODULE_2__["default"].join(types, ", ", " or ")}`
                );
            }
            return this.clearErrorMessage(obj);
        }

        this.loadErrorMessage(obj);
    }

    async boolean(obj) {
        let value = this.getData(obj);
        if (!_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isBoolean(value)) {
            this.loadErrorMessage(obj);
        }
    }

    
    async email(obj) {
        if (this.skippedValidation(obj)) return;

        const data = this.getData(obj);
       
        this.clearIF(
            _utils__WEBPACK_IMPORTED_MODULE_2__["default"].isEmail(data),
            obj
        );
    }


    async uuid(obj) {
        const data = this.getData(obj);
        if (this.skippedValidation(obj)) return;

        const validated = _utils__WEBPACK_IMPORTED_MODULE_2__["default"].isString(data) && _utils__WEBPACK_IMPORTED_MODULE_2__["default"].isUuid(data);

        this.clearIF(
            validated,
            obj
        );
       
    }

    async url(obj) {
        const data = this.getData(obj);
        if (this.skippedValidation(obj)) return;
        let validated = _utils__WEBPACK_IMPORTED_MODULE_2__["default"].isUrl(data);
        
        this.clearIF(
            validated,
            obj
        );

    }

    async ip(obj) {
        const data = this.getData(obj);
        if (this.skippedValidation(obj)) return;
        
        const validated = _utils__WEBPACK_IMPORTED_MODULE_2__["default"].isIpAddress(data);

        this.clearIF(
            validated,
            obj
        );
    }

    /**
     *
     * STABILIZERS
     * @method trim
     * @method capitalize
     * @method format_date
     * */
    async trim(obj) {
        const value = this.getData(obj);

        if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isString(value)) {
            this.setData(obj, _utils__WEBPACK_IMPORTED_MODULE_2__["default"].trim(value));
        }
        else {
            this.setData(obj, _utils__WEBPACK_IMPORTED_MODULE_2__["default"].recursiveTrim(value));
        }
    }

    async capitalize(obj, type) {
        this.trim(obj);
        const value = this.getData(obj);

        if (value) {
            if (type === "all") this.setData(obj, value.toUpperCase());
            else if (type === "none") this.setData(obj, value.toLowerCase());
            else
                this.setData(
                    obj,
                    value.replace(/\b([a-z])/g, ($1) => $1.toUpperCase())
                );
        }
    }

    async format_date(obj, format) {
        if (!["date", "datetime", "time"].includes(obj.type)) {
            throw new _exceptions__WEBPACK_IMPORTED_MODULE_0__.ValidationError(
                "format_date after declaring date, datetime or time type"
            );
        }

        const formatted = _utils__WEBPACK_IMPORTED_MODULE_2__["default"].format_date(this.getData(obj), format, obj.type);
        if (formatted) {
            this.setData(obj, formatted);
        }
        
    }

    /**
     * FILLABLE RULES
     * @method fill
     * @method if_empty
     * @method fillable
     * @method nullable
     * @method required
     * @method required_if
     * @method required_unless
     * @method required_with
     * @method required_with_all
     * @method required_without
     * @method required_without_all
     */
    async fill(obj, initial) {
        const value = this.getData(obj);

        if (this.empty(value)) {
            this.setData(obj, initial);
        }
    }

    async if_empty(obj, initial) {
        if (!_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isString(initial)) {
            throw new _exceptions__WEBPACK_IMPORTED_MODULE_0__.ValidationError("if_empty argument is not accepted");
        }

        const value = this.getData(obj);

        if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isEmpty(value)) {
            this.setData(obj, initial);
        }
    }

    async filled(obj) {
        if (this.skippedValidation(obj)) return;

        const data = this.getData(obj);

        const matcher = [
            data === undefined,
            data === null,
            data === "",
            _utils__WEBPACK_IMPORTED_MODULE_2__["default"].isArray(data) && data.length === 0,
            _utils__WEBPACK_IMPORTED_MODULE_2__["default"].isPlainObject(data) && data && Object.keys(data).length === 0,
        ];

        if (matcher.some((item) => item === true)) {
            this.loadErrorMessage(obj);
        }
    }

    async nullable(obj) {
        if (this.skippedValidation(obj)) return;

        if (!this.getData(obj)) {
            this.setData(obj, null);
            this.skipNextValidation(obj);
        }
    }

    async required(obj) {
        const data = this.getData(obj);
        if (
            (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isFile(data) && obj.type === "file") ||
            (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isFileList(data) && obj.type === "files")
        ) {
            return this.clearErrorMessage(obj);
        }

        const matcher = [
            data === undefined,
            data === null,
            data === "",
            _utils__WEBPACK_IMPORTED_MODULE_2__["default"].isArray(data) && data.length === 0,
            _utils__WEBPACK_IMPORTED_MODULE_2__["default"].isPlainObject(data) && Object.keys(data).length === 0,
        ];

        if (matcher.some((item) => item === true)) {
            this.loadErrorMessage(obj);
        }
    }

    async required_if(obj, other, value) {
        if (!this.getData(obj) && this._data[other] !== value) {
            this.loadErrorMessage({ ...obj, other, value });
        } else {
            this.clearErrorMessage(obj);
        }
    }

    async required_unless(obj, other, ...values) {
        const value = this.getData(obj);
        const otherValue = this._data[other];

        if (value && values.includes(otherValue)) {
            return this.clearErrorMessage(obj);
        }

        this.loadErrorMessage({ ...obj, other, values: values.join(",") });
    }

    async required_with(obj, ...values) {
        const required_files = [obj.attribute, ...values];
        const value = this.getData(obj);
        const valueData = required_files.map((item) => this._data[item]);

        if (value && valueData.some((item) => !this.empty(item))) {
            return this.clearErrorMessage(obj);
        }
        this.loadErrorMessage({ ...obj, values: values.join(",") });
    }

    async required_with_all(obj, ...values) {
        const required_files = [obj.attribute, ...values];
        const data = required_files.map((item) => this._data[item]);

        if (data.some((item) => this.empty(item))) {
            this.loadErrorMessage({ ...obj, values: values.join(",") });
        }
    }

    async required_without(obj, ...values) {
        const required_files = [obj.attribute, ...values];
        const data = required_files.map((item) => this._data[item]);

        if (data.every((item) => this.empty(item))) {
            this.loadErrorMessage({ ...obj, values: values.join(",") });
        }
    }

    async required_without_all(obj, ...values) {
        const value = this.getData(obj);
        const valudData = values.map((item) => this._data[item]);

        if (!value && valudData.some((item) => this.empty(item))) {
            this.loadErrorMessage({ ...obj, values: values.join(",") });
        }
    }

    /**
     * LAST ORDER RULES (validators)
     */

    /**
     *
     * Check if a field has been accepted
     *
     * @see filled
     *
     * term: 'accepted|...'
     *
     * or
     * term: {accepted: true, ...}
     *
     * or
     * term: ['accepted',...]
     */

    accepted(obj) {
        if (!this.getData(obj)) {
            this.loadErrorMessage(obj);
        }
    }

    /**
     *
     * Checks if the provided data has strong password features
     *
     * @usage
     * name: 'string|password|...'
     *
     * or
     * name: {string:true, password:true, ...}
     *
     * or
     * name: ['string', 'password', ...]
     */

    async password(obj) {
        const data = this.getData(obj) ?? "";
        const patterns = {
            letters: [/[a-zA-Z]/],
            mixed: [/[a-z]/, /[A-Z]/],
            numbers: [/[0-9]/],
            symbols: [/[!@#$^&*()_+<>?\/\\,.+|{}%-`~]/]
        };

        for(const [key, pattern] of Object.entries(patterns)) {
            if (pattern.some(p => !p.test(data))) {
                return this.loadErrorMessage(
                    obj,
                    this.getUserMessages(obj, key)
                )
            }
        }
        return this.clearErrorMessage(obj)

        if (!/[a-zA-Z]/.test(data)) {
            this.loadErrorMessage(
                obj,
                this.getUserMessages(obj, 'letters')
            );
        } else if (!/[a-z]/.test(data) || !/[A-Z]/.test(data)) {
            this.loadErrorMessage(
                obj,
                this.getUserMessages(obj, 'mixed')
            );
        } else if (!/[0-9]/.test(data)) {
            this.loadErrorMessage(
                obj,
                this.getUserMessages(obj, 'numbers')
            );
        } else if (!/[!@#$^&*()_+<>?\/\\,.+|{}%-`~]/.test(data)) {
            this.loadErrorMessage(
                obj,
                this.getUserMessages(obj, 'symbols')
            );
        } else if (data.length < 8) {
            this.loadErrorMessage(
                { ...obj, length: 8 },
                this.getUserMessages(obj, 'length')
            );
        }
    }

    /**
     *
     * Checks is a provided data has only alphabets
     *
     * @usage
     * name: 'string|alpha|...'
     *
     * or
     * name: {string:true, alpha:true, ...}
     *
     * or
     * name: ['string', 'alpha', ...]
     */

    alpha(obj) {
        if (this.skippedValidation(obj)) return;
        this.trim(obj);
        const data = this.getData(obj).toString();

        const pattern = /^[a-zA-Z]+$/;

        
        this.clearIF(_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isString(data) && pattern.test(data), obj)
    }

    clearIF(validated, obj, errorMessage) {
        if (validated) {
            return this.clearErrorMessage(obj);
        }
        this.loadErrorMessage(obj, errorMessage);
    }

    /**
     *
     * Checks is a provided data has only alphabets and underscores
     *
     * @usage
     * name: 'string|alpha_underscore|...'
     *
     * or
     * name: {string:true, alpha_underscore:true, ...}
     *
     * or
     * name: ['string', 'alpha_underscore', ...]
     */

    alpha_underscore(obj) {
        if (this.skippedValidation(obj)) return;

        this.trim(obj);
        const data = this.getData(obj);
        
        this.clearIF(_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isString(data) && /^[a-zA-Z_]+$/.test(data), obj)
    }

    /**
     *
     * Checks is a provided data has only alphabets and dashes
     *
     * @usage
     * name: 'string|alpha_dash|...'
     *
     * or
     * name: {string:true, alpha_dash:true, ...}
     *
     * or
     * name: ['string', 'alpha_dash', ...]
     */

    alpha_dash(obj) {
        if (this.skippedValidation(obj)) return;
        this.trim(obj);
        const data = this.getData(obj);

        this.clearIF(_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isString(data) && /^[a-zA-Z0-9_-]+$/.test(data), obj)
    }

    /**
     *
     * Checks is a provided data has only alphabets and numbers
     *
     * @usage
     * name: 'string|alpha_num|...'
     *
     * or
     * name: {string:true, alpha_num:true, ...}
     *
     * or
     * name: ['string', 'alpha_num', ...]
     */

    alpha_num(obj) {
        if (this.skippedValidation(obj)) return;
        
        this.trim(obj);

        const data = this.getData(obj);

        this.clearIF(_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isString(data) && /^[a-zA-Z0-9]+$/.test(data), obj)
    }

    /**
     *
     * Checks is a provided data has only alphabets and spaces
     *
     * @usage
     * name: 'string|alpha_spaces|...'
     *
     * or
     * name: {string:true, alpha_spaces:true, ...}
     *
     * or
     * name: ['string', 'alpha_spaces', ...]
     */

    alpha_spaces(obj) {
        if (this.skippedValidation(obj)) return;
       
        this.trim(obj);
        const data = this.getData(obj);

        this.clearIF(_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isString(data) && /^[a-zA-Z\s]+$/.test(data), obj)
    }

    getSize(obj) {
        const data = this.getData(obj);

        if (obj.type === 'numeric') {
            return [data]; 
        }
        else if (obj.type === 'files') {
            return data.map(file => file.size);
        }
        else if (obj.type === 'file') {
            return [
                data.size
            ];
        }
        else if (obj.type === 'string' || obj.type === 'array') {
            return [
                data.length
            ];
        }
        return 0;
    }

    /**
     *
     * Ensures a value is between a minimum and maximum range.
     * Handles numeric, string, array, and file types
     *
     * @usage
     * age: 'between:18,45|...'
     *
     * or
     *
     * age: {between: [18, 45], ...}
     *
     * or
     * age: ['between:18,45', ...]
     */

    async between(obj, min, max) {
        if (this.skippedValidation(obj)) return;

        min = this.parseInt(min);
        max = this.parseInt(max);
        const data = this.getData(obj);

        min = Math.min(max, min);
        max = Math.max(max, min);

        const patterns = {
            numeric: (data) => data < min || data > max,
            string: (data) => data.length < min || data > max,
            array: (data) => data.length < min || data > max,
            files: (data) => data.some(file => file.size < min || file.size > max),
            file: (data) => data.size < min || data.size > max
        };

        const fnc = patterns[obj.type];
        let validated = false;

        if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isFunction(fnc)) {
            validated = !fnc(data);
        }
        this.clearIF(
            validated, 
            {...obj, min, max},
            this.getUserMessages(obj)
        );

    }

    /**
     *
     * Validates if the value matches another field (commonly used for password confirmation)
     *
     * @usage
     * terms: 'confirmed|...'
     *
     * or
     * terms: {confirmed: true, ...}
     *
     * or
     * terms: ['confirmed', ...]
     */

    async confirmed(obj) {
        if (this.skippedValidation(obj)) return;
        let other = arguments.length > 1 ? arguments[1] : obj.attribute + '_confirmation';

        const validated = _utils__WEBPACK_IMPORTED_MODULE_2__["default"].isString(other) && this.getData(obj) === this._data[other];

        

        if (!validated) {
            this._skips.push(other);
            this._errors[other] = this.getUserMessages(obj);
        }
    }

    /**
     *
     * Checks if the value contains a specific substring
     *
     * @usage
     * name: 'contains:bright|...'
     *
     * or
     * name: {contains: 'bright', ...}
     *
     * or
     * name: ['contains:bright', ...]
     */

    

    async contains(obj, value) {
        if (this.skippedValidation(obj)) return;
        const data = this.getData(obj);

        this.clearIF(
            _utils__WEBPACK_IMPORTED_MODULE_2__["default"].isString(data) && data.includes(value),
            obj
        );
    }

    /**
     *
     * Validates a credit card number using regex patterns for various card types (Visa, MasterCard, etc.)
     *
     * @param {*} obj
     * @returns
     */

    async credit_card(obj) {
        const data = this.getData(obj);
        if (this.skippedValidation(obj)) return;

        const cardNumberRegex =
            /^4[0-9]{12}(?:[0-9]{3})?$|^5[1-5][0-9]{14}$|^3[47][0-9]{13}$|^3(?:0[0-5]|[68][0-9])[0-9]{11}$|^6(?:011|5[0-9]{2})[0-9]{12}$|^35(?:2[89]|[3-8][0-9])[0-9]{12}$|^(?:2131|1800|35[2-8][0-9])[0-9]{11}$/;

        this.clearIF(
            cardNumberRegex.test(data),
            obj
        );
    }

    /**
     *
     * Validates if a date is after a certain time (e.g., after:18years)
     *
     * @usage
     * birthdate: 'date|after:18years'
     *
     * or
     * birthdate: {date:true, after: '18years', ...}
     *
     * or
     * birthdate: ['date', 'before:18years', ....]
     */

    after(obj, after) {
        if (this.skippedValidation(obj)) return;
        const date = after;

        const current = Date.now();

        const mtch = date.match(
            /^(\d+)\s*(year|month|day|hour|minute|second|millisecond)(s)?$/
        );
        if (!mtch) {
            throw new _exceptions__WEBPACK_IMPORTED_MODULE_0__.ValidationError(
                `Invalid Validation Rule Syntax, usage example: ${obj.attribute}: 'date|after:18years`
            );
        }

        let value = Date.parse(this.getData(obj));
        let validated = false;
        if (!isNaN(value)) {
            // value = new Date(value);

            let [all, digits, text] = mtch;
            const timers = {
                year: 1000 * 60 * 60 * 24 * 365, // 1000 * 60*60*24*365
                month: 1000 * 60 * 60 * 24 * 7 * 4, // 1000 * 60 * 60 * 60 * 24 * 7 * 4
                week: 1000 * 60 * 60 * 24 * 7,
                day: 1000 * 60 * 60 * 24,
                hour: 1000 * 60 * 60,
                minute: 1000 * 60,
                second: 1000,
                millisecond: 1,
            };
            digits = parseInt(digits);

            if (text in timers) {
                const newTime = Math.floor((current - value) / timers[text]);
                validated = newTime >= digits
            }
        }
        this.clearIF(
            validated,
            { ...obj, after }
        );
    }

    /**
     *
     * Validates if a date is before a certain time (e.g., before:45years)
     *
     * @usage
     * birthdate: 'date|before:45years'
     *
     * or
     * birthdate: {date:true, before: '45years', ...}
     *
     * or
     * birthdate ['date', 'before:45years', ...]
     */

    async before(obj, before) {
        if (this.skippedValidation(obj)) return;
        const date = before;

        const current = Date.now();

        const mtch = date.match(
            /^(\d+)\s*(year|month|day|hour|minute|second|millisecond)(s)?$/
        );

        if (!mtch) {
            throw new _exceptions__WEBPACK_IMPORTED_MODULE_0__.ValidationError(
                `Invalid Validation Rule Syntax, usage example: ${obj.attribute}: 'date|before:45years`
            );
        }

        const value = Date.parse(this.getData(obj));
        let validated = false;

        if (!isNaN(value)) {
            let [all, digits, text] = mtch;
            const timers = {
                year: 1000 * 60 * 60 * 24 * 365,
                month: 1000 * 60 * 60 * 24 * 7 * 4,
                week: 1000 * 60 * 60 * 24 * 7,
                day: 1000 * 60 * 60 * 24,
                hour: 1000 * 60 * 60,
                minute: 1000 * 60,
                second: 1000,
                millisecond: 1,
            };
            digits = parseInt(digits);

            if (text in timers) {
                const newTime = Math.floor((value - current) / timers[text]);
                validated = newTime >= digits;
            }
        }

        this.clearIF(
            validated,
            { ...obj, before }
        );
    }


    /**
     *
     * Ensures the string ends with any of the specified values
     *
     */

    async ends_with(obj, ...values) {
        if (this.skippedValidation(obj)) return;
        const data = this.getData(obj);
        const pattern = values.join("|") + "$";
        const regex = new RegExp(pattern);


        const validated = _utils__WEBPACK_IMPORTED_MODULE_2__["default"].isString(data) && regex.test(data);

        this.clearIF(
            validated,
            { ...obj, values: values.join(", ") }
        );
    }

    /**
     *
     * Checks if the value is within a specified set of values
     *
     * @see in_array
     */

    async in(obj, ...values) {
        if (this.skippedValidation(obj)) return;
        const data = this.getData(obj);

        const validated = _utils__WEBPACK_IMPORTED_MODULE_2__["default"].isPlainObject(data) && values.some(item => item in data);

        this.clearIF(
            validated,
            { ...obj, values: values.join(", ") }
        );
    }


    async in_array(obj, ...values) {
        if (this.skippedValidation(obj)) return;
        const data = this.getData(obj);

        const validated = _utils__WEBPACK_IMPORTED_MODULE_2__["default"].isString(data) && values.includes(data);

        this.clearIF(
            validated,
            { ...obj, values: values.join(", ") }
        );
    }

    

    /** */

    async json(obj) {
        if (this.skippedValidation(obj)) return;
        const data = this.getData(obj);

        let validated = false;

        try {
            JSON.parse(data);
            validated = true;
        } catch (e) {
        }

        this.clearIF(
            validated,
            obj
        );
    }

    async lowercase(obj) {
        const data = this.getData(obj);
        if (this.skippedValidation(obj)) return;

        const validated = _utils__WEBPACK_IMPORTED_MODULE_2__["default"].isString(data) && /^[a-z]+$/.test(data);

        this.clearIF(
            validated,
            obj
        );
    }





    async max(obj, max) {
        max = parseInt(max);
        const data = this.getData(obj);

        if (this.skippedValidation(obj)) return;

        const patterns = {
            numeric: (data) => data >= max,
            string: (data) => data.length >= max,
            array: (data) => data.length >= max,
            files: (data) => data.some(file => file.size >= max),
            file: (data) => data.size >= max
        };

        const fnc = patterns[obj.type];
        let validated = false;

        if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isFunction(fnc)) {
            validated = !fnc(data);
        }

        this.clearIF(
            validated, 
            {...obj, min, max},
            this.getUserMessages(obj)
        );

    }




    async mimes(obj, ...mimes) {
        const data = this.getData(obj);
        if (this.skippedValidation(obj)) return;

        let error = false;

        switch (obj.type) {
            case "file":
                error = !mimes.includes(data.type);
                break;
            case "files":
                error = Array.from(data).some(
                    (file) => !mimes.includes(file.type)
                );
                break;
        }

        this.clearIF(
            !error,
            { ...obj, mimes: mimes.join(", ") }
        );

    }

    async min(obj, min) {
        if (this.skippedValidation(obj)) return;

        min = this.parseInt(min);
        const data = this.getData(obj);

        const patterns = {
            numeric: (data) => data < max,
            string: (data) => data.length < max,
            array: (data) => data.length < max,
            files: (data) => data.some(file => file.size < max),
            file: (data) => data.size < max
        };

        const fnc = patterns[obj.type];
        let validated = false;

        if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isFunction(fnc)) {
            validated = !fnc(data);
        }

        this.clearIF(
            validated, 
            {...obj, min, max},
            this.getUserMessages(obj)
        );

    }

    async multiple_of(obj, number) {
        number = parseFloat(number);
        const data = this.getData(obj);
        if (this.skippedValidation(obj)) return;

        const validated = _utils__WEBPACK_IMPORTED_MODULE_2__["default"].isNumber(data) && data % number === 0;

        this.clearIF(
            validated,
            obj
        );
    }

    async not_contains(obj, value) {
        const data = this.getData(obj);
        if (this.skippedValidation(obj)) return;

        const validated = _utils__WEBPACK_IMPORTED_MODULE_2__["default"].isString(data) && !data.includes(value);

        this.clearIF(
            validated,
            obj
        );
    }

    async not_in(obj, ...values) {
        if (this.skippedValidation(obj)) return;
        const data = this.getData(obj);

        const validate = _utils__WEBPACK_IMPORTED_MODULE_2__["default"].isPlainObject(data) && values.every(value => !(value in data))

        this.clearIF(
            validated,
            { ...obj, values: values.join(", ") }
        );

    }




    async phone(obj) {
        if (this.skippedValidation(obj)) return;
        const data = this.getData(obj);

        const phoneRegex = /^\+?[1-9]\d{1,14}$/;

        this.clearIF(
            phoneRegex.test(data),
            obj
        );
    }



    async range(obj, min, max) {
        min = this.parseInt(min);
        max = this.parseInt(max);
        const data = this.getData(obj);

        if (this.skippedValidation(obj)) return;

        const validated = _utils__WEBPACK_IMPORTED_MODULE_2__["default"].isNumber(data) && data >= min && data <= max;

        this.clearIF(
            validated,
            {...obj, min, max}
        );

    }


    async regex(obj, pattern) {
        if (this.skippedValidation(obj)) return;
        const data = this.getData(obj);
        let validated = false;

        if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isRegExp(pattern) || _utils__WEBPACK_IMPORTED_MODULE_2__["default"].isString(data)) {
            try {
                const regex = _utils__WEBPACK_IMPORTED_MODULE_2__["default"].isRegExp(pattern) ? pattern : new RegExp(pattern);

                validated = regex.test(data);
            } catch(e) {}
        }

        this.clearIF(
            validated,
            {...obj, pattern}
        );

    }

    async same(obj, other) {
        if (this.skippedValidation(obj)) return;

        this.clearIF(
            this.getData(obj) !== this._data[other],
            {...obj, other}
        );
    }




    async starts_with(obj, ...values) {
        if (this.skippedValidation(obj)) return;
        const data = this.getData(obj);
        const pattern = "^" + values.join("|");
        let validated = false;

        try {
            const regex = new RegExp(pattern);
            validated = regex.test(data);
        } catch(e) {}

        this.clearIF(
            validated,
            { ...obj, values: values.join(", ") }
        );

    }




    async timezone(obj) {
        if (this.skippedValidation(obj)) return;
        const data = this.getData(obj);

        const validTimezones = Intl.supportedValuesOf("timeZone");
        const validated = validTimezones.includes(data);

        this.clearIF(
            validated,
            obj
        );
    }

    async uppercase(obj) {
        if (this.skippedValidation(obj)) return;
        const data = this.getData(obj);

        const validated = _utils__WEBPACK_IMPORTED_MODULE_2__["default"].isString(data) && /^[A-Z]+$/.test(data);

        this.clearIF(
            validated,
            obj
        );
    }

    


    async gt(obj, gt) {
        if (this.skippedValidation(obj)) return;
        gt = this.parseInt(gt, `gt argument expects a number but ${typeof gt} was provided`);
        const data = this.getData(obj);

        let error = false;
        switch (obj.type) {
            case "numeric":
                error = data <= gt;
                break;
            case "file":
                error = _utils__WEBPACK_IMPORTED_MODULE_2__["default"].isFile(data) ? 1 <= gt : data.length <= gt;
                break;
            case "string":
            case "array":
                error = data.length <= gt;
                break;
        }

        
        this.clearIF(
            !error,
            {...obj, gt},
            this.getUserMessages(obj)
        );

    }

    async gte(obj, gte) {
        gte = parseInt(gte);
        const data = this.getData(obj);

        if (this.skippedValidation(obj)) return;

        let error = false;
        switch (obj.type) {
            case "numeric":
                error = data < gte;
                break;
            case "file":
                error = _utils__WEBPACK_IMPORTED_MODULE_2__["default"].isFile(data) ? 1 < gte : data.length < gte;
                break;
            case "string":
            case "array":
                error = data.length < gte;
                break;
        }

        this.clearIF(
            !error,
            {...obj, gte},
            this.getUserMessages(obj)
        );
    }

    async lt(obj, lt) {
        lt = parseInt(lt);
        const data = this.getData(obj);

        if (this.skippedValidation(obj)) return;

        let error = false;
        switch (obj.type) {
            case "numeric":
                error = data >= lt;
                break;
            case "file":
                error = _utils__WEBPACK_IMPORTED_MODULE_2__["default"].isFile(data) ? 1 >= lt : data.length >= lt;
                break;
            case "string":
            case "array":
                error = data.length >= lt;
                break;
        }

        this.clearIF(
            !error,
            {...obj, lt},
            this.getUserMessages(obj)
        );
    }

    async lte(obj, lte) {
        lte = parseInt(lte);
        const data = this.getData(obj);

        if (this.skippedValidation(obj)) return;

        let error = false;
        switch (obj.type) {
            case "numeric":
                error = data > lte;
                break;
            case "file":
                error = _utils__WEBPACK_IMPORTED_MODULE_2__["default"].isFile(data) ? 1 > lte : data.length > lte;
                break;
            case "string":
            case "array":
                error = data.length > lte;
                break;
        }

        this.clearIF(
            !error,
            {...obj, lte},
            this.getUserMessages(obj)
        );
    }

    async active_url(obj) {
        const data = this.getData(obj);

        if (this.skippedValidation(obj)) return;

        let validated = _utils__WEBPACK_IMPORTED_MODULE_2__["default"].isString(data) && /^https?:\/\//.test(data);

        if (validated) {
            validated = false;
            try {
                await fetch(this.getData(obj));
                validated = true;
            } catch (e) {}
        }

        this.clearIF(
            validated, 
            obj
        );
    }

    parseInt(num, message) {
        if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isNumber(num)) {
            return str;
        }

        const parsed = parseInt(num);

        if (isNaN(parsed)) {
            throw new _exceptions__WEBPACK_IMPORTED_MODULE_0__.ValidationError(
                message || `Number type was expected but ${typeof num} was provided`
            )
        }

        return parsed;
    }

    async digits(obj, digits) {
        digits = this.parseInt(digits);
        
        let data = `${this.getData(obj)}`;

        const validated = data.length === digits;
    
        this.clearIF(
            validated,
            obj
        );
    }

    
    async image(obj) {
        if (this.skippedValidation(obj)) return;

        const data = this.getData(obj);

        const isImage = (type) => this._file_patterns.image.some(pattern => pattern.test(type));

        if (["file", "files"].includes(obj.type)) {
            const fileIsImage = _utils__WEBPACK_IMPORTED_MODULE_2__["default"].isFile(data) && isImage(data.type);
            const filesAreImage = _utils__WEBPACK_IMPORTED_MODULE_2__["default"].isArray(data) && data.every((item) => isImage(item.type));

            validated = fileIsImage || filesAreImage;
        }

        this.clearIF(
            validated,
            obj
        );
    }

    audio(obj) {
        if (this.skippedValidation(obj)) return;

        const data = this.getData(obj);

        const isAudio = (type) => this._file_patterns.audio.some(pattern => pattern.test(type));

        if (["file", "files"].includes(obj.type)) {
            const fileIsAudio = _utils__WEBPACK_IMPORTED_MODULE_2__["default"].isFile(data) && isAudio(data.type);
            const filesAreAudio = _utils__WEBPACK_IMPORTED_MODULE_2__["default"].isArray(data) && data.every((item) => isAudio(item.type));

            validated = fileIsAudio || filesAreAudio;
        }

        this.clearIF(
            validated,
            obj
        );
    }

    async video(obj) {
        if (this.skippedValidation(obj)) return;

        const data = this.getData(obj);

        const isVideo = (type) => this._file_patterns.video.some(pattern => pattern.test(type));

        if (["file", "files"].includes(obj.type)) {
            const fileIsVideo = _utils__WEBPACK_IMPORTED_MODULE_2__["default"].isFile(data) && isVideo(data.type);
            const filesAreVideo = _utils__WEBPACK_IMPORTED_MODULE_2__["default"].isArray(data) && data.every((item) => isVideo(item.type));

            validated = fileIsVideo || filesAreVideo;
        }

        this.clearIF(
            validated,
            obj
        );
    }




    async pattern(obj, pattern) {
        if (this.skippedValidation(obj)) return;

        const indicators = {
            z: /^[a-z]$/,
            Z: /^[A-Z]$/,
            a: /^[a-z]$/,
            A: /^[A-Z]$/,
            0: /^[0-9]$/,
            9: /^[0-9]$/,
            "*": /^[a-zA-Z0-9]$/,
        };

        let data = this.getData(obj);

        let validated = false;

        if (data) {
            const splitData = _utils__WEBPACK_IMPORTED_MODULE_2__["default"].trim(data.toString()).split("");
            const splitPattern = pattern.split("");

            if (splitPattern.length === splitData.length) {
                validated = splitPattern.every((pattern, i) => {
                    return (
                        (!indicators[pattern] && pattern === splitData[i]) ||
                        (indicators[pattern] &&
                            indicators[pattern].test(splitData[i]))
                    );
                });

                
            }
        }

        this.clearIF(
            validated,
            {...obj, pattern}
        )

    }

    

    hasFile() {
        return this._hasFile;
    }

    /**
     *
     * Converts regular data into FormData,
     * which is often required for file uploads
     * or sending data in POST requests
     *
     * @param {*} data
     * @returns
     */

    convertDataToFormData(data) {
        const formData = new FormData();

        _utils__WEBPACK_IMPORTED_MODULE_2__["default"].forEach(data, (value, key) => {
            if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isFileList(value)) {
                this._hasFile = true;

                _utils__WEBPACK_IMPORTED_MODULE_2__["default"].forEach(Array.from(value), (file) => {
                    formData.append(`${key}[]`, file);
                });
            } else if (
                _utils__WEBPACK_IMPORTED_MODULE_2__["default"].isArray(value) &&
                value.every((file) => _utils__WEBPACK_IMPORTED_MODULE_2__["default"].isFile(file))
            ) {
                this._hasFile = true;
                value.forEach((file) => {
                    formData.append(`${key}[]`, file);
                });
            } else {
                if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isFile(value)) {
                    this._hasFile = true;
                }
                formData.append(key, value);
            }
        });

        return formData;
    }

    /**
     *
     * Loops through the rules and applies the necessary validation for each attribute
     */

    parseRules(rules) {
        if (!_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isPlainObject(rules)) {
            throw new TypeError("Argement 2 (rules) must be an object");
        }
        _utils__WEBPACK_IMPORTED_MODULE_2__["default"].forEach(rules, (rule, attribute) => {
            this.start({
                rule,
                attribute,
            });
        });
        
    }

    /**
     * Infers the type of the data (e.g., array, object, numeric, file, etc.)
     *
     * @param {*} data
     * @returns {String}
     */

    detectType(data) {
        if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isArray(data)) return data.every(item => _utils__WEBPACK_IMPORTED_MODULE_2__["default"].isFile(item)) ? "files":"array";
        else if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isBlob(data)) return "blob";
        else if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isPlainObject(data)) return "object";
        else if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isNumber(data)) return "numeric";
        else if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isBoolean(data)) return "boolean";
        else if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isFile(data)) return "file";
        else if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isFileList(data)) return "files";
        else if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isString(data)) return "string";
        else {
            const date = new Date(data);
            if (!isNaN(date.getFullYear())) return 'date';
            try {
                let d = JSON.parse(data);
                if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isArray(d) || _utils__WEBPACK_IMPORTED_MODULE_2__["default"].isObject(d)) return 'json';
                return typeof d;
            } catch(e){}
        }
        return "any";
    }

    /**
     * Orders the properties of an array or object based on specified patterns.
     *
     * @param {Array|Object} input - The array or object to be categorized and ordered.
     * @param {Object} patterns - The patterns to categorize the properties.
     * @param {Object} defaults - The default values to ensure presence if necessary.
     * @returns {Array|Object} - A new array or object with properties ordered according to the patterns.
     */
    orderRules(attribute, input) {

        const order = _utils__WEBPACK_IMPORTED_MODULE_2__["default"].memorize(() => {
            const Pattern = (arr) => new RegExp(`^(${arr.join("|")})$`);
            const patterns = {
                types: Pattern(FormGuard.registers.types),
                stabilizers: Pattern(FormGuard.registers.stabilizers),
                fillables: Pattern(FormGuard.registers.fillables),
            };
    
    
            if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isString(input)) {
                const rules = {};
                const split = input.split("|");
                split.forEach((item) => {
                    let [rule, args] = item.split(":");
                    args = !args ? true : args.split(",");
                    rules[rule] = args.length === 0 ? true : args;
                });
    
                return this.orderRules(attribute, rules);
            }
            else if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isArray(input)) {
                if (input.some(item => _utils__WEBPACK_IMPORTED_MODULE_2__["default"].isString(item) && item.indexOf(':') > 0)) {
                    input = this.arrayToObject(input);
                }                        
            }


    
            const categorized = this.categorizeRules(input, patterns);
    
            const orderedRules = _utils__WEBPACK_IMPORTED_MODULE_2__["default"].isArray(input)
                ? this.createOrderedArray(categorized)
                : this.createOrderedObject(categorized, input);
    
    
            return orderedRules;
        }, attribute);
        return order();
        
    }

    arrayToObject(input) {
        const obj = {};

        input.forEach(item => {
            if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isFunction(item)) {
            
                let name = item.name || 'anonymous';
                obj[name] = item;
            }
            else if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isString(item)) {
                const splt = item.split(":");
                let name = splt[0];
                let args = true;

                if (splt.length > 1) {
                    args = splt[1].split(',').map(_utils__WEBPACK_IMPORTED_MODULE_2__["default"].normalize);
                }
                obj[name] = args;              
            }
        });
        return obj;
    }

    categorizeRules(input, patterns) {
        const categorized = {
            types: [],
            stabilizers: [],
            fillables: [],
            others: [],
        };

        (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isArray(input) ? input : Object.keys(input)).forEach((item) => {
            let matched = false;
            for (const [key, pattern] of Object.entries(patterns)) {
                if (item && pattern.test(item)) {
                    categorized[key].push(item);
                    matched = true;
                    break;
                }
            }
            if (!matched) categorized.others.push(item);
        });

        return categorized;
    }

    createOrderedArray(categorized) {
        let order = [];

        ["fillables", "types", "stabilizers"].forEach((key) => {
            if (categorized[key] && categorized[key].length > 0) {
                order.push(
                    key === "stabilizers"
                        ? categorized.stabilizers[0]
                        : categorized[key][0]
                );
            }
        });

        return [
            ...order,
            ...categorized.others,
            "successfully__passed__validation",
        ];
    }

    createOrderedObject(categorized, input) {
        const orders = {};

        ["fillables", "types", "stabilizers"].forEach((order) => {
            const item = categorized[order].map((key) => [
                key,
                input[key] || true,
            ]);

            if (item.length > 0) {
                Object.assign(
                    orders,
                    Object.fromEntries(
                        order === "stabilizers" ? item : [item[0]]
                    )
                );
            }
        });

        return {
            ...orders,
            ...Object.fromEntries(
                categorized.others.map((key) => [key, input[key]])
            ),
            successfully__passed__validation: true,
        };
    }

    appendRule(attribute, rule, callback, methodArgs) {
        const [method, arg] = methodArgs;
        const args = methodArgs;
        if (method === 'fill' && arg.length > 0) {
            return this.setData({attribute}, arg[0]);
        }
        if (!(attribute in this._rules)) {
            this._rules[attribute] = [];
        }
        if (rule.length === 0) {
            rule = "custom";
        }


        this._rules[attribute].push({
            rule,
            callback,
            methodArgs,
            args,
            arg
        });
    }

    /**
     * Starts the validation process for a given rule and attribute.
     *
     * @param {Object} config - Configuration object containing rule and attribute.
     * @param {string|Object} config.rule - Validation rule or rules to process.
     * @param {string} config.attribute - The attribute to validate.
     */

    start({ rule, attribute }) {
        const fail = (message) => {
            throw new _exceptions__WEBPACK_IMPORTED_MODULE_0__.KnownError(message);
        };

        rule = this.orderRules(attribute, rule);

        let type = this.inferType({ rule, attribute });

        const processItem = async (method, args) => {
            const fnc = _utils__WEBPACK_IMPORTED_MODULE_2__["default"].isFunction(method)
                ? method
                : _utils__WEBPACK_IMPORTED_MODULE_2__["default"].isFunction(args)
                ? args
                : false;

            if (["integer"].includes(type)) {
                type = "numeric";
            }

            return await this.enact({
                method,
                fnc,
                args,
                fail,
                attribute,
                type,
            });
        };

        if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isArray(rule)) {
            for (const method of rule) {
                let rule = method;
                if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isFunction(method)) {
                    rule = method.name;
                }
                this.appendRule(attribute, rule, processItem, [method]);
            }
        } else if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isPlainObject(rule)) {
            for (const [method, args] of Object.entries(rule)) {
                if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isFunction(args)) {
                    // FormGuard.addCustomRules({ [method]: args });
                }


                this.appendRule(attribute, method, processItem, [method, args]);
            }
        } else {
            throw new _exceptions__WEBPACK_IMPORTED_MODULE_0__.ValidationError("Failed to process validation rules");
        }
    }

    inferType(obj) {
        const types = FormGuard.registers.types;

        const matchedType = (
            _utils__WEBPACK_IMPORTED_MODULE_2__["default"].isArray(obj.rule) ? obj.rule : Object.keys(obj.rule)
        ).find((item) => types.includes(item));

        if (matchedType) {
            return matchedType;
        }
        const data = this.getData(obj);
        const isNumeric = _utils__WEBPACK_IMPORTED_MODULE_2__["default"].isNumeric(data);

        if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isArray(data))
            return data.every((file) => _utils__WEBPACK_IMPORTED_MODULE_2__["default"].isFile(file)) ? "files" : "array";
        else if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isPlainObject(data)) return "object";
        else if (isNumeric) {
            this.setData(obj, isNumeric);
            return "numeric";
        } else if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isFile(data)) return "file";
        else if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isFileList(data)) return "files";
        else if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isString(data)) return "string";
        return "any";
    }

    async enact({ method, attribute, args, fnc, type, required, fail }) {
        let rule = method;

        if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isString(method) && method.indexOf(":") >= 0) {
            [rule, args] = method.split(":");
            args = args.split(",");
        } else if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isFunction(method)) {

            rule = method.name || 'anonymous';
        }


        let message = `validation.${
            rule || "custom" + (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isFunction(method) ? "Callback" : "Rule")
        }`;

        const errorMessage = (msg) => {
            if (!_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isString(rule)) {
                return message;
            }
            return this.getUserMessages({attribute, type, rule}, null, msg || message);
        };

        let parameters = [];
        
        if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isArray(args)) {
            parameters = args.map(_utils__WEBPACK_IMPORTED_MODULE_2__["default"].normalize);
        }

        const apply_callback = async (fnc, message) => {
            try {
                let response = await fnc({
                    query: this._data,
                    value: this._data[attribute],
                    parameters,
                    message,
                    type,
                    attribute,
                    fail,
                });


                if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isPlainObject(response) && _utils__WEBPACK_IMPORTED_MODULE_2__["default"].isString(response[FormGuard.locale])) {
                    throw new _exceptions__WEBPACK_IMPORTED_MODULE_0__.KnownError(response[FormGuard.locale]);
                }

                else if (response === false || _utils__WEBPACK_IMPORTED_MODULE_2__["default"].isString(response)) {
                    throw new _exceptions__WEBPACK_IMPORTED_MODULE_0__.KnownError(response || errorMessage());
                }

                return response;
            } catch (err) {
                this._errors[attribute] = errorMessage();

                if (err instanceof _exceptions__WEBPACK_IMPORTED_MODULE_0__.KnownError) {
                    if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isString(err.message)) {
                        this._errors[attribute] = errorMessage(err.message);
                    }
                    if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isPlainObject(err.message) && _utils__WEBPACK_IMPORTED_MODULE_2__["default"].isString(err.message[FormGuard.locale])) {
                        this._errors[attribute] = errorMessage(err.message[FormGuard.locale]);
                    }
                }
                
                else if (err instanceof _exceptions__WEBPACK_IMPORTED_MODULE_0__.ValidationError) {
                    throw new _exceptions__WEBPACK_IMPORTED_MODULE_0__.ValidationError(err.message);
                } 
            }
        };

        try {
            if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isFunction(fnc)) {
                if (this.skippedValidation({ attribute, required })) return;

                await apply_callback(fnc, message);
            } else if (rule && rule in this) {
                args = [
                    {
                        rule,
                        method: rule,
                        attribute,
                        type,
                        required,
                        fail,
                    },
                ].concat(args);
                const fun = this[rule];

                await fun.apply(this, args);

                // this[rule].apply(this, args);
            } else if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isString(rule) && rule in FormGuard) {
                let matched = false;

                if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isFunction(FormGuard[rule])) {
                    message = this.getUserMessages({attribute, rule, type});
                    
                    await apply_callback(FormGuard[rule], message);
                    matched = true;
                }
                if (!matched) {
                    FormGuard.log("warn", `Validation Rule "${rule}" is not valid`);
                }
            }
            else {
                FormGuard.log("warn", `Validation Rule "${rule}" is not defined`);

            }
        } catch (e) {
            if (FormGuard._debug) {
                console.error(e);
                throw e;
            }
            else {
                throw new _exceptions__WEBPACK_IMPORTED_MODULE_0__.ValidationError(
                    'An error occurred'
                );
            }
        }
    }

    

    skippedValidation(obj) {
        return (
            this._skips.includes(obj.attribute) ||
            // (!this.getData(obj) && !obj.required) ||
            obj.attribute in this._errors
        );
    }

    loadErrorMessage(obj, message) {

        
        if (!_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isString(obj.rule)) {
            obj.rule = method;
        }

        if (!_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isString(message)) {
            message = this.getUserMessages(obj);
        }
        

        this.skipNextValidation(obj);

        const attrs = {
            ...obj,
            attribute: this.getAttribute(obj.attribute),
        };
        message = message.replace(
            /:([a-zA-Z_]+)/g,
            (_, key) => attrs[key] || key
        );
        this._errors[obj.attribute] = message;
    }


    getData(obj) {
        if (!_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isObject(obj)) {
            return this._data;
        }
        return this._data[obj.attribute];
    }

    setData(obj, value) {
        this._data[obj.attribute] = value;
    }
    removeData(obj) {
        delete this._data[obj.attribute];
    }

    skipNextValidation(obj) {
        this._skips.push(obj.attribute);
    }

    clearErrorMessage(obj) {
        if (this._errors[obj.attribute]) {
            delete this._errors[obj.attribute];
        }
    }

    hasError(obj) {
        return !!this._errors[obj.attribute];
    }

    /**
     * @param obj {Object}
     *
     * @usage
     * FormGuard.setAttributes({
     *    name: 'Full Name',
     *    email: 'Email Address'
     * });
     *
     * @returns void
     */

     static getKeys(thing){
        const pattern = /([^$]+)/g;
        const matched = thing.match(pattern);

        if (!matched || matched.length !== 2) {
            return [thing, system_locale];
        }
        return matched;
    }

    getAttribute(name) {
        if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isPlainObject(this._attributes)) {
            const locale = this._attributes[FormGuard.locale];

            if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isPlainObject(locale)) {
                return locale[name] || name;
            }
        }
        return name;
    }



    setAttributes(obj) {
        if (!_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isObject(this._attributes)) {
            this._attributes = {};
        }

        if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isObject(obj)) {
            obj = {
                ...(_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isPlainObject(_config__WEBPACK_IMPORTED_MODULE_1__["default"].attributes) ? _config__WEBPACK_IMPORTED_MODULE_1__["default"].attributes : {}),
                ...obj 
            };
            _utils__WEBPACK_IMPORTED_MODULE_2__["default"].forEach(obj, (value, key) => {
                const [message_key, locale] = FormGuard.getKeys(key);
                this._attributes[locale] = {
                    ...(_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isPlainObject(this._attributes[locale]) ? this._attributes[locale] : {}),
                    [message_key]: value
                };
            })
            
        }

        return this;
    }

    snakeCase(...args) {
        args = args.filter(arg => _utils__WEBPACK_IMPORTED_MODULE_2__["default"].isString(arg))
        
        return args
            .map((arg, i) =>
                i === 0
                    ? arg.toLowerCase()
                    : arg.charAt(0).toUpperCase() + arg.slice(1).toLowerCase()
            )
            .join("");
    }

    async empty(data) {
        const matcher = [
            data === undefined,
            data === null,
            _utils__WEBPACK_IMPORTED_MODULE_2__["default"].isString(data) && _utils__WEBPACK_IMPORTED_MODULE_2__["default"].trim(data) === "",
            _utils__WEBPACK_IMPORTED_MODULE_2__["default"].isArray(data) && data.length === 0,
            _utils__WEBPACK_IMPORTED_MODULE_2__["default"].isObject(data) && data && Object.keys(data).length === 0,
        ];

        return matcher.some((item) => item);
    }


    loadFallbackMessages(fallback_messages) {
        FormGuard._fallback_messages = FormGuard._translations[FormGuard.locale] || _utils__WEBPACK_IMPORTED_MODULE_2__["default"].castObject(fallback_messages, {});
    }
    
    static setPriority(name, priority) {
        const priors = {
            p1: 'fillables',
            p2: 'types',
            p3: 'stabilizers',
        }
        const priorities = ["fillables", "types", "stabilizers"];
        priority = _utils__WEBPACK_IMPORTED_MODULE_2__["default"].castNumber(priority, 4);

        this.resetPriority(name);
        const prior = `p${priority}`;


        if (priors[prior]) {
            const order = priors[prior];
            this.registers[order].push(name);

        }
    }

    static resetPriority(name) {
        
        for(const [registry, orders] of Object.entries(this.registers)) {
            const order = orders.indexOf(name);
            if (order >= 0) {
                this.registers[registry].splice(order, 1);
            }
        }
    }

    static remove(name) {
        this.resetPriority(name);

        if (name in this) {
            delete this[name];
        }
    }


    static add(custom_rules, options) {
        if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isString(custom_rules)) {
            if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isPlainObject(options)) {
                this.add({
                    [custom_rules]: options, 
                });
            }
            else if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isFunction(options)) {
                this.add({
                    [custom_rules]: {
                        fn: options 
                    }
                });
                // this[custom_rules] = options;
            }
        }   

        else if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isArray(custom_rules)) {
            _utils__WEBPACK_IMPORTED_MODULE_2__["default"].forEach(custom_rules, rules => {
                if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isPlainObject(rules) && _utils__WEBPACK_IMPORTED_MODULE_2__["default"].isString(rules.name)) {
                    this.add({[rules.name]: rules})
                }
                else if (!_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isPlainObject(rules)) {
                    this.log('warn', 'Rules should be an object');
                }
                else if (!_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isString(rules.name)) {
                    this.log('warn', 'Rule name is missing');
                }
            });
        }

        else if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isPlainObject(custom_rules)) {

            _utils__WEBPACK_IMPORTED_MODULE_2__["default"].forEach(custom_rules, (options, name) => {
                if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isFunction(options)) {
                    this[name] = options;
                    return;
                }
                
                const fn = eval(`(function ${name}(data){return options.fn(data);})`)
                // const fn = options.fn;
                
                
                let messages = _utils__WEBPACK_IMPORTED_MODULE_2__["default"].isString(options.message) ? {[name]:options.message} : {};

                if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isPlainObject(options.messages)) {
                    messages = {
                        ...(Object.fromEntries(
                            Object.entries(options.messages)
                                .map(([locale, message]) => [`${name}$${locale}`, message])
                        ))
                    }
                }
                
                
                if (_utils__WEBPACK_IMPORTED_MODULE_2__["default"].isFunction(fn)) {
                    this.setSystemMessages(messages, name);
                    this.setPriority(name, options.priority);
                    delete this[name];
                    this[name] = fn;
                }
                else {
                    this.log('warn', `${name} fn must be a function`);
                }
            })
            

        }

    }



    
}

/***/ }),

/***/ "./src/core/utils/index.js":
/*!*********************************!*\
  !*** ./src/core/utils/index.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });



// utils is a library of generic helper functions non-specific to axios

const {toString} = Object.prototype;
const {getPrototypeOf} = Object;

const kindOf = (cache => thing => {
    const str = toString.call(thing);
    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(Object.create(null));

const kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type
}



const typeOfTest = type => (thing, falseValue = false) => typeof thing === type ? true : falseValue;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 *
 * @returns {boolean} True if value is an Array, otherwise false
 */
const {isArray} = Array;

/**
 * Determine if a value is undefined
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if the value is undefined, otherwise false
 */
const isUndefined = typeOfTest('undefined');

/**
 * Determine if a value is a Buffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
const isArrayBuffer = kindOfTest('ArrayBuffer');


/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  let result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a String, otherwise false
 */
const isString = typeOfTest('string');

/**
 * Determine if a value is a Function
 *
 * @param {*} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
const isFunction = typeOfTest('function');

/**
 * Determine if a value is a Number
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Number, otherwise false
 */
const isNumber = typeOfTest('number');

/**
 * Determine if a value is an Object
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an Object, otherwise false
 */
const isObject = (thing, falseValue = false) => thing !== null && typeof thing === 'object' ? true : falseValue;

/**
 * Determine if a value is a Boolean
 *
 * @param {*} thing The value to test
 * @returns {boolean} True if value is a Boolean, otherwise false
 */
const isBoolean = thing => thing === true || thing === false;

/**
 * Determine if a value is a plain Object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a plain Object, otherwise false
 */
const isPlainObject = (val, returnValue = false) => {
  if (kindOf(val) !== 'object') {
    return returnValue;
  }

  const prototype = getPrototypeOf(val);
  const m = (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
  return m ? m : returnValue;
}

const castType = (type) => {
  const parsers = {
    object: isPlainObject,
    string: isString,
    boolean: isBoolean,
    number: isNumber,
    array: isArray,
    function: isFunction,
  };
  const defaults = {
    object: {},
    string: '',
    boolean: false,
    number: 0,
    function: () => {},
    array: []
  }
  let _parser = parsers.string;
  let _cast = defaults.string;

  if (parsers[type]) {
    _parser = parsers[type]
    _cast = defaults[type];
  }
   
  return (thing, cast) => {
    if (_parser(thing)) {
      return thing;
    }
    return cast||_cast;
  }
};
const castNumber = castType('number');
const castObject = castType('object');
const castString = castType('string');
const castArray = castType('array');
const castBoolean = castType('boolean');
const castFunction = castType('function');

/**
 * Determine if a value is a Date
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Date, otherwise false
 */
const isDate = kindOfTest('Date');

/**
 * Determine if a value is a File
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */
const isFile = kindOfTest('File');

/**
 * Determine if a value is a Blob
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Blob, otherwise false
 */
const isBlob = kindOfTest('Blob');

/**
 * Determine if a value is a FileList
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */
const isFileList = kindOfTest('FileList');

/**
 * Determine if a value is a Stream
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Stream, otherwise false
 */
const isStream = (val) => isObject(val) && isFunction(val.pipe);

/**
 * Determine if a value is a FormData
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an FormData, otherwise false
 */
const isFormData = (thing) => {
  let kind;
  return thing && (
    (typeof FormData === 'function' && thing instanceof FormData) || (
      isFunction(thing.append) && (
        (kind = kindOf(thing)) === 'formdata' ||
        // detect form-data instance
        (kind === 'object' && isFunction(thing.toString) && thing.toString() === '[object FormData]')
      )
    )
  )
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
const isURLSearchParams = kindOfTest('URLSearchParams');

const [isReadableStream, isRequest, isResponse, isHeaders] = ['ReadableStream', 'Request', 'Response', 'Headers'].map(kindOfTest);

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 *
 * @returns {String} The String freed of excess whitespace
 */
const trim = (str) => str.trim ?
  str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');

const recursiveTrim = (str) => {
  if (isString(str)) return trim(str);

  if (isArray(str)) {
    let newArray = [];
    for(var i = 0; i < str.length; i++) {
      newArray.push(isString(str[i]) ? trim(str[i]) : recursiveTrim(str[i]));
    }
    return newArray;
  }
  else if (isPlainObject(str)) {
    return Object.fromEntries(
      Object.entries(str).map(([key, value]) => [
        key,
        recursiveTrim(value)
      ])
    );
  }
  return str;
}

/**
 * Extend List
 */
const enList = (list, extension) => {
  for (var _len2 = list.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = list[_key2];
  }
  if (isUndefined(extension)) {
    return args;
  }
  else if (!isArray(extension)) {
      extension = [extension];
  }

  const aLength = args.length;
  const eLength = extension.length;
  if (aLength >= eLength || eLength === 0) return args;

  return extension.map((ext, i) => i + 1 > aLength ? ext : args[i])

};

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 *
 * @param {Boolean} [allOwnKeys = false]
 * @returns {any}
 */
function forEach(obj, fn, {allOwnKeys = false} = {}) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  let i;
  let l;

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;

    for (i = 0; i < len; i++) {
      key = keys[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}

function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}

const _global = (() => {
  /*eslint no-undef:0*/
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : (typeof window !== 'undefined' ? window : __webpack_require__.g)
})();

const isContextDefined = (context) => !isUndefined(context) && context !== _global;

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 *
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  const {caseless} = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  }

  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 *
 * @param {Boolean} [allOwnKeys]
 * @returns {Object} The resulting value of object a
 */
const extend = (a, b, thisArg, {allOwnKeys}= {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction(val)) {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  }, {allOwnKeys});
  return a;
}


/**
 * Inherit the prototype methods from one constructor into another
 * @param {function} constructor
 * @param {function} superConstructor
 * @param {object} [props]
 * @param {object} [descriptors]
 *
 * @returns {void}
 */
const inherits = (constructor, superConstructor, props, descriptors) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, 'super', {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
}



/**
 * Returns new array from array like object or null if failed
 *
 * @param {*} [thing]
 *
 * @returns {?Array}
 */
const toArray = (thing) => {
  if (!thing) return null;
  if (isArray(thing)) return thing;
  let i = thing.length;
  if (!isNumber(i)) return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
}

/**
 * Checking if the Uint8Array exists and if it does, it returns a function that checks if the
 * thing passed in is an instance of Uint8Array
 *
 * @param {TypedArray}
 *
 * @returns {Array}
 */
// eslint-disable-next-line func-names
const isTypedArray = (TypedArray => {
  // eslint-disable-next-line func-names
  return thing => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== 'undefined' && getPrototypeOf(Uint8Array));

/**
 * For each entry in the object, call the function with the key and value.
 *
 * @param {Object<any, any>} obj - The object to iterate over.
 * @param {Function} fn - The function to call for each entry.
 *
 * @returns {void}
 */
const forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator];

  const iterator = generator.call(obj);

  let result;

  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
}



/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */
const isHTMLForm = kindOfTest('HTMLFormElement');

const toCamelCase = str => {
  return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g,
    function replacer(m, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};

/* Creating a function that will check if an object has a property. */
const hasOwnProperty = (({hasOwnProperty}) => (obj, prop) => hasOwnProperty.call(obj, prop))(Object.prototype);

/**
 * Determine if a value is a RegExp object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a RegExp object, otherwise false
 */
const isRegExp = kindOfTest('RegExp');

const reduceDescriptors = (obj, reducer) => {
  const descriptors = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};

  forEach(descriptors, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });

  Object.defineProperties(obj, reducedDescriptors);
}

/**
 * Makes all methods read-only
 * @param {Object} obj
 */

const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    // skip restricted props in strict mode
    if (isFunction(obj) && ['arguments', 'caller', 'callee'].indexOf(name) !== -1) {
      return false;
    }

    const value = obj[name];

    if (!isFunction(value)) return;

    descriptor.enumerable = false;

    if ('writable' in descriptor) {
      descriptor.writable = false;
      return;
    }

    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error('Can not rewrite read-only method \'' + name + '\'');
      };
    }
  });
}


const isAsyncFn = kindOfTest('AsyncFunction');

const isThenable = (thing) =>
  thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);




const parallel = async (...tasks) => {
  await Promise.all(tasks.map((task) => task()));
}

const series = async (...tasks) => {
    for (const task of tasks) {
        await task();
    }
}

const race = async (tasks) => {
  return await Promise.race(tasks);
}

const delay =  (ms) => {
  return new Promise((resolve) => setTimeout(resolve, ms));
}



const join = (array, glue, finalGlue = '') => {
    if (finalGlue === '') {
      return array.join(glue);
    }

    if (array.length === 0) {
        return '';
    }

    if (array.length === 1) {
        return array[0];
    }

    const finalItem = array.pop();

    return array.join(glue) + finalGlue + finalItem;
}

const format_date = (strdate, format, type = "datetime") => {
  
  const placeholders = {
      date: "yyyy-mm-dd",
      datetime: "yyyy-mm-dd H:i:s",
      time: "H:i:s a",
  };
  const matchers = /(yyyy|mm|dd|h|i|s|a)/gi;
  
  const placeholder = placeholders[type] || placeholders.datetime;
  if (!isString(format)) {
      format = placeholder;
  }

  const date = isDate(strdate) ? strdate : new Date(strdate);

  const padZero = (n) => (n < 10 ? `0${n}` : n);

  const yyyy = date.getFullYear();
  if (isNaN(yyyy)) {
    return null;
  }
  const mm = padZero(date.getMonth() + 1);
  const i = padZero(date.getMinutes() || 0);
  const dd = padZero(date.getDate());
  const hours = date.getHours();
  let a = "am";
  let A = "AM";
  let h = hours;

  if (h > 12) {
      h -= 12;
      a = "pm";
      A = "PM";
  }
  h = padZero(h);
  const H = padZero(hours);
  const s = padZero(date.getSeconds() || 0);
  const pattern = /([a-zA-Z]+)/g;
  const [MM, S, YYYY, DD, I] = [mm, s, yyyy, dd, i];

  const dateObj = { yyyy, YYYY, mm, MM, s, S, h, H, a, A, dd, DD, i, I };
  
  return format.replace(matchers, $1 => dateObj[$1] || $1);

}


const retry = async (fn, options = {}) => {
  if (isPlainObject(options)) {
      options = {};
  }
  options = {
      limit: 3,
      retryIF: () => true,
      timeout: 1000,
      maxTimeout: 8000,
      delay: false,
      ...options
  };
  options.timeout = options.timeout || 0;
  let lastError;
  for (let i = 0; i < options.limit; i++) {
      const nextDelay = Math.min(options.timeout * Math.pow(2, i), options.maxTimeout);
      try {
          return await fn({counter: i + 1, next:nextDelay});
      } catch (error) {
          lastError = error;
          if (!options.retryIF(error)) {
              throw error;
          }
          if (i < options.limit - 1) {
              const delay = options.delay ? 1 : 0;
              
              await new Promise((resolve) => setTimeout(resolve, nextDelay * delay));
          }
      }
  }
  throw lastError;
};

const combineArrayToObject =  (keys, values = [], defaultValue) => {
  if (!isArray(keys) || !isArray(values)) return [];

  return keys.reduce((acc, key, i) => {
      acc[key] = !isUndefined(values[i]) ? values[i] : defaultValue;
      return acc;
  }, {});
}



const isNumeric = (thing) => {
  if (!isNumber(thing)) {
    if (!isString(thing) || !/^[-]?\d*(\.\d+)?$/.test(thing)) {
      return false;
    }
    thing = parseFloat(thing);
  }
  return isNaN(thing) ? false : thing;
}

const isInteger = (thing) => {
  thing = isNumeric(thing);
  if (thing && thing % 1 === 0) {
    return thing;
  }
  return false;
};

const isDecimal = (thing) => (isNumeric(thing) && !isInteger(thing)) || (isString(thing) && /^[-]?\d*(\.\d+)?$/.test(thing));



const objectGet = (obj) => {
  let data = obj;
  for (var i = 1; i < arguments.length; i++) {
    if (isPlainObject(data)) {
      data = data[arguments[i]];
    } else {
      return;
    }
  }
  return data;
};





const isLength = (value) => isNumber(value) && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;

const len = value => {
  if (isArray(value) || isString(value)) return value.length;

  if (isPlainObject(value)) {
    return Object.keys(value).length;
  }

  return 0;
};

const isArrayLike = (value) => value != null && isLength(value.length) && !isFunction(value);
const isObjectMethod = (name)=> typeof Object === 'function' ? typeof Object[name] === 'function' : false;


const zip =  (keys, values, defaultValue) => {
  try {
  if (typeof values === 'undefined') {
      return Object.fromEntries(keys);
  }
if (!Array.isArray(keys) || !Array.isArray(values)) return [];


return keys.reduce((acc, key, i) => {
    if (isString(key)) {
      acc[key] = values[i] !== undefined ? values[i] : defaultValue;
    }
  
    else if (isArray(key) && key.length > 0) {
      acc[key[0]] = key.length > 1 ? key[1] : undefined;
    }
    return acc;
}, {});
  } catch(e){return [];}
}




const interval = (fnc, options) => {
  let intervalId;
  let time = Date.now();

  if (typeof options === 'number') {
      options = { delay: options };
  }
  else if (typeof options !== 'object' || options === null) {
      options = {};
  }
  options = { delay: 5000, ...options}
  
  
  return (...args) => {
      const context = undefined;
      intervalId && clearInterval(intervalId);
   
      intervalId = setInterval(() => {
      args = [Date.now() - time].concat(args);

          fnc.apply(context, args);
      }, options.delay);

      return intervalId;

  };

}

const poll = (fnc, delay = 60000) => {
  interval(fnc, delay)();
}

const memorize = (fn, cacheKey) => {
  const cache = {};
  return (...args) => {
      const key = cacheKey || JSON.stringify(args);
      if (cache[key]) {
          return cache[key];
      }
      const result = fn(...args);
      cache[key] = result;
      return result;
  };
};
//freezeMethods
const throttle = (fn, delay) => {
  let lastCall = 0;
  return (...args) => {
      const now = new Date().getTime();
      if (now - lastCall < delay) {
          return;
      }
      lastCall = now;
      return fn(...args);
  };
};



const normalize = memorize(data => {
  if (isPlainObject(data)) {
    return Object.fromEntries(
      Object.entries(data)
        .map(([key, value]) => [key, normalize(value)])
    )
  }
  else if (isArray(data)) {
    return data.map(item => normalize(item))
  }
  else if (isString(data)) {
    try {
      const parsed = JSON.parse(trim(data));

      return normalize(parsed);

    } catch(e) {}
  }
  return data;
});

// const isEmpty = (data) => {
//   const matcher = [
//       isUndefined(data),
//       data === null,
//       isString(data) && trim(data) === "",
//       isArray(data) && data.length === 0,
//       isPlainObject(data) && data && Object.keys(data).length === 0,
//   ];

//   return matcher.some((item) => item);
// };


const isSet = value => {
  if (isArray(value)) return !!value.length;

  if (value === undefined || value === null) {
    return false;
  }
  if (isString(value)) {
    return !!trim(value).length;
  }

  if (value === false) {
    return true;
  }

  if (value instanceof Date) {
    return !isNaN(value.getTime());
  }

  if (typeof value === 'object') {
    for (let _ in value) return true;

    return false;
  }

  return !!String(value).length;
};

const isEmpty = value => !isSet(value);



const generateUUID = (format = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx') => format.replace(/[xy]/g, (c) => {
      const r = Math.random() * 16 | 0;
      const v = c === 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
});

const randomInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;


const deepClone = (obj) => {
  if (obj === null || typeof obj !== 'object') {
      return obj;
  }
  if (Array.isArray(obj)) {
      return obj.map(item => deepClone(item));
  }
  const clone = {};
  for (const key in obj) {
      if (obj.hasOwnProperty(key)) {
          clone[key] = deepClone(obj[key]);
      }
  }
  return clone;
};


const isEmail = (str) => (
  isString(str) && 
  /^(?:[A-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[A-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9]{2,}(?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])$/i.test(str)
);

const isUuid = (str) => (
  isString(str) &&
  /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/.test(str)
);

const isUrl = (str) => (
  isString(str) &&
  /^(?:(?:(?:https?|ftp):)?\/\/)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u00a1-\uffff][a-z0-9\u00a1-\uffff_-]{0,62})?[a-z0-9\u00a1-\uffff]\.)+(?:[a-z\u00a1-\uffff]{2,}\.?))(?::\d{2,5})?(?:[/?#]\S*)?$/i.test(str)
);

const isIpAddress = (str) => (
  isString(str) &&
  /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(str)
);

const isObj = (obj, ifNotReturn = {}) => {
  if (!isPlainObject(obj)) {
    return ifNotReturn;
  }
  return obj;
}

const wrap = (value) => {
  if (isArray(value)) {
    return value;
  }
  if (isUndefined(value)) {
    return [];
  }
  else if (isString(value)) {
    return [value];
  }
  try {
    return Array.from(value);
  } catch(e) {}
};

class Observer {
    constructor() {
    this.callbacks = [];
    }

    /**
    Register a callback to be eecuted when the observed value changes.
    @params {Function} callback
    */
    watch(predictive, callback) {
      this.callbacks.push([callback, predictive]);
    }

    /**
     * Notify all registered callbacks of a value change.
     * @param {*} newValue
     * @param {*} oldValue
    */
    notify(newValue, oldValue) {
      console.log({newValue, oldValue})
      this.callbacks.forEach((callback) => callback[0](newValue, oldValue));
    }


  /**
   * Create a proxied object to observe changes
   * @param {*} initialValue
   * @returns {Proxy}
   */

  createProxy(initialValue) {
      return new Proxy({value:initialValue}, {
        set: (target, property, newValue) => {
          const oldValue = target.value;
          target.value = newValue;
          
          this.notify(newValue, oldValue);
          return true;
        },
      });
  }
}
const observer = new Observer();

const reactive = (initials) => {
    return observer.createProxy(initials);
}

const watch = (predictive, callback) => {
  observer.watch(predictive, callback);
}

// *********************

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  isObj,
  deepClone,
  memorize,
  throttle,
  isObjectMethod,
  generateUUID,
  randomInt,
  interval,
  poll,
  observer,
  reactive,
  watch,
  zip,
  isLength,
  isArrayLike,
  objectGet,
  join,
  isNumeric,
  isInteger,
  combineArrayToObject,
  race,
  parallel,
  series,
  retry,
  delay,
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  inherits,
  kindOf,
  kindOfTest,
  toArray,
  forEachEntry,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty, // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toCamelCase,
  findKey,
  global: _global,
  isContextDefined,
  isAsyncFn,
  isThenable,
  isEmpty,
  isSet,
  isDecimal,
  isEmail,
  isUuid,
  isUrl,
  isIpAddress,
  
  castNumber,
  castString,
  castObject,
  castArray,
  castBoolean,
  castFunction,
  enList,
  

  normalize,
  wrap,
  format_date
});

/***/ }),

/***/ "./src/locales/ar.js":
/*!***************************!*\
  !*** ./src/locales/ar.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    accepted: "  :attribute.",
    date: "     .",
    url: "     .",
    ip: "     IP .",
    uuid: "    UUID .",
    integer: "     .",
    alpha_spaces: "       .",
    timezone: "      .",
    credit_card: "       .",
    phone: "      .",
    contains: "     :value.",
    not_contains: "     :value.",
    min: {
        numeric: "    :min.",
        string: "     :min .",
        array: "    :min   .",
        file: "      :min .",
        files: "      :min .",
    },
    unique: "   .",
    exists: "     .",
    max: {
        numeric: "    :max.",
        string: "     :max .",
        array: "      :max .",
        file: "     :max .",
        files: "     :max .",
    },
    image: "   :attribute .",
    video: "   :attribute .",
    audio: "   :attribute .",
    digits: "   :attribute  :digits .",
    file: "   :attribute .",
    files: "       :attribute.",
    filled: "   :attribute  .",
    mimes: "     : :values.",
    mimetypes: "     : :values.",
    gt: {
        numeric: "     :gt.",
        string: "     :gt .",
        array: "      :gt .",
        file: "      :gt .",
        files: "      :gt .",
    },
    lt: {
        numeric: "     :lt.",
        string: "     :lt .",
        array: "      :lt .",
        file: "      :lt .",
        files: "      :lt .",
    },
    gte: {
        numeric: "       :gte.",
        string: "    :gte   .",
        array: "    :gte   .",
        file: "     :gte   .",
        files: "     :gte   .",
    },
    lte: {
        numeric: "       :lte.",
        string: "    :lte   .",
        array: "      :lte .",
        file: "     :lte .",
        files: "     :lte .",
    },
    alpha: "      .",
    alpha_: "        .",
    alpha_dash: "          .",
    alpha_num: "       .",
    boolean: "     .",
    confirmed: "   .",
    between: {
        numeric: "    :min  :max.",
        string: "     :min  :max .",
        array: "    :min  :max .",
        file: "      :min  :max .",
        files: "      :min  :max .",
    },
    password: {
        length: "       :length .",
        letters: "         .",
        mixed: "          .",
        numbers: "         .",
        symbols: "         .",
        uncompromised: "      .     .",
    },
    email: "      .",
    in_array: "      : :values.",
    in: "      : :values.",
    regex: "   .",
    same: "     :other.",
    ends_with: "     : :values.",
    starts_with: "     : :values.",
    not_in: "      : :values.",
    required_if: "    :other  :value.",
    required: "  .",
    uppercase: "       .",
    lowercase: "       .",
    range: "    :min  :max.",
    multiple_of: "     :number.",
    active_url: " :attribute   .",
    numeric: "   :attribute .",
    pattern: "    :pattern.",
    required_unless: "      :other  :values.",
    required_with: "     :values.",
    required_with_all: "     :values.",
    required_without: "      :values.",
    required_without_all: "        :values.",
    after: "   :attribute   :date.",
    before: "   :attribute   :date.",
});

/***/ }),

/***/ "./src/locales/de.js":
/*!***************************!*\
  !*** ./src/locales/de.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    accepted: "Das Feld :attribute muss akzeptiert werden.",
    date: "Das Feld muss ein gltiges Datum sein.",
    url: "Das Feld muss eine gltige URL sein.",
    ip: "Das Feld muss eine gltige IP-Adresse sein.",
    uuid: "Das Feld muss eine gltige UUID sein.",
    integer: "Das Feld muss eine ganze Zahl sein.",
    alpha_spaces: "Das Feld darf nur Buchstaben und Leerzeichen enthalten.",
    timezone: "Das Feld muss eine gltige Zeitzone sein.",
    credit_card: "Das Feld muss eine gltige Kreditkartennummer sein.",
    phone: "Das Feld muss eine gltige Telefonnummer sein.",
    contains: "Das Feld muss :value enthalten.",
    not_contains: "Das Feld darf :value nicht enthalten.",
    min: {
        numeric: "Der Wert muss mindestens :min sein.",
        string: "Der Text muss mindestens :min Zeichen lang sein.",
        array: "Das Array muss mindestens :min Elemente enthalten.",
        file: "Die Datei muss mindestens :min Bytes gro sein.",
        files: "Die Dateien mssen mindestens :min Bytes gro sein.",
    },
    unique: "Der Wert muss eindeutig sein.",
    exists: "Der Wert muss im Datensatz vorhanden sein.",
    max: {
        numeric: "Der Wert darf nicht grer als :max sein.",
        string: "Der Text darf nicht lnger als :max Zeichen sein.",
        array: "Das Array darf nicht mehr als :max Elemente enthalten.",
        file: "Die Datei darf nicht grer als :max Bytes sein.",
        files: "Die Dateien drfen nicht grer als :max Bytes sein.",
    },
    image: "Das Feld :attribute muss ein Bild sein.",
    video: "Das Feld :attribute muss ein Video sein.",
    audio: "Das Feld :attribute muss eine Audiodatei sein.",
    digits: "Das Feld :attribute muss :digits Ziffern haben.",
    file: "Das Feld :attribute muss eine Datei sein.",
    files: "Das Feld :attribute erfordert mindestens eine Datei.",
    filled: "Das Feld :attribute muss einen Wert enthalten.",
    mimes: "Das Feld :attribute muss eine Datei des Typs sein: :values.",
    mimetypes: "Das Feld :attribute muss eine Datei des Typs sein: :values.",
    gt: {
        numeric: "Der Wert muss grer als :gt sein.",
        string: "Der Text muss lnger als :gt Zeichen sein.",
        array: "Das Array muss mehr als :gt Elemente enthalten.",
        file: "Die Datei muss grer als :gt Bytes sein.",
        files: "Die Dateien mssen grer als :gt Bytes sein.",
    },
    lt: {
        numeric: "Der Wert muss kleiner als :lt sein.",
        string: "Der Text muss krzer als :lt Zeichen sein.",
        array: "Das Array muss weniger als :lt Elemente enthalten.",
        file: "Die Datei muss kleiner als :lt Bytes sein.",
        files: "Die Dateien mssen kleiner als :lt Bytes sein.",
    },
    gte: {
        numeric: "Der Wert muss mindestens :gte sein.",
        string: "Der Text muss mindestens :gte Zeichen lang sein.",
        array: "Das Array muss mindestens :gte Elemente enthalten.",
        file: "Die Datei muss mindestens :gte Bytes gro sein.",
        files: "Die Dateien mssen mindestens :gte Bytes gro sein.",
    },
    lte: {
        numeric: "Der Wert darf hchstens :lte sein.",
        string: "Der Text darf hchstens :lte Zeichen lang sein.",
        array: "Das Array darf hchstens :lte Elemente enthalten.",
        file: "Die Datei darf hchstens :lte Bytes gro sein.",
        files: "Die Dateien drfen hchstens :lte Bytes gro sein.",
    },
    alpha: "Das Feld darf nur Buchstaben enthalten.",
    alpha_: "Das Feld darf nur Buchstaben und Unterstriche enthalten.",
    alpha_dash: "Das Feld darf nur Buchstaben, Zahlen, Bindestriche und Unterstriche enthalten.",
    alpha_num: "Das Feld darf nur Buchstaben und Zahlen enthalten.",
    boolean: "Das Feld muss ein boolescher Wert sein.",
    confirmed: "Die Besttigung des Feldes stimmt nicht berein.",
    between: {
        numeric: "Der Wert muss zwischen :min und :max liegen.",
        string: "Der Text muss zwischen :min und :max Zeichen lang sein.",
        array: "Das Array muss zwischen :min und :max Elemente enthalten.",
        file: "Die Datei muss zwischen :min und :max Bytes gro sein.",
        files: "Die Dateien mssen zwischen :min und :max Bytes gro sein.",
    },
    password: {
        length: "Das Passwort muss mindestens :length Zeichen lang sein.",
        letters: "Das Passwort muss mindestens einen Buchstaben enthalten.",
        mixed: "Das Passwort muss mindestens einen Gro- und einen Kleinbuchstaben enthalten.",
        numbers: "Das Passwort muss mindestens eine Zahl enthalten.",
        symbols: "Das Passwort muss mindestens ein Symbol enthalten.",
        uncompromised: "Das angegebene Passwort wurde in einer Datenpanne gefunden. Bitte whlen Sie ein anderes Passwort.",
    },
    email: "Das Feld muss eine gltige E-Mail-Adresse sein.",
    in_array: "Der Wert des Feldes muss einer der folgenden sein: :values.",
    in: "Der Wert des Feldes muss einer der folgenden sein: :values.",
    regex: "Das Format des Feldes ist ungltig.",
    same: "Das Feld muss mit dem Feld :other bereinstimmen.",
    ends_with: "Das Feld muss mit einem der folgenden enden: :values.",
    starts_with: "Das Feld muss mit einem der folgenden beginnen: :values.",
    not_in: "Der Wert des Feldes darf keiner der folgenden sein: :values.",
    required_if: "Das Feld ist erforderlich, wenn :other :value ist.",
    required: "Das Feld ist erforderlich.",
    uppercase: "Das Feld darf nur Grobuchstaben enthalten.",
    lowercase: "Das Feld darf nur Kleinbuchstaben enthalten.",
    url: "Das Feld muss eine gltige URL sein.",
    uuid: "Das Feld muss eine gltige UUID sein.",
    range: "Der Wert muss zwischen :min und :max liegen.",
    multiple_of: "Der Wert muss ein Vielfaches von :number sein.",
    active_url: "Das Feld :attribute ist keine gltige URL.",
    numeric: "Das Feld :attribute muss eine Zahl sein.",
    pattern: "Das erwartete Muster ist :pattern.",
    required_unless: "Das Feld :attribute ist erforderlich, es sei denn, :other befindet sich in :values.",
    required_with: "Das Feld :attribute ist erforderlich, wenn :values vorhanden ist.",
    required_with_all: "Das Feld :attribute ist erforderlich, wenn :values vorhanden sind.",
    required_without: "Das Feld :attribute ist erforderlich, wenn :values nicht vorhanden ist.",
    required_without_all: "Das Feld :attribute ist erforderlich, wenn keines der :values vorhanden ist.",
    after: "Das Feld :attribute muss ein Datum nach :date sein.",
    before: "Das Feld :attribute muss ein Datum vor :date sein.",
});

/***/ }),

/***/ "./src/locales/en.js":
/*!***************************!*\
  !*** ./src/locales/en.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    accepted: "The :attribute must be accepted.",
    date: "The :attribute field must be a valid date.",
    url: "The :attribute field must be a valid URL.",
    ip: "The :attribute field must be a valid IP address.",
    uuid: "The :attribute field must be a valid UUID.",
    integer: "The :attribute field must be an integer.",
    alpha_spaces: "The :attribute field may only contain letters and spaces.",
    timezone: "The :attribute field must be a valid timezone.",
    credit_card: "The :attribute field must be a valid credit card number.",
    phone: "The :attribute field must be a valid phone number.",
    contains: "The :attribute field must contain :value.",
    not_contains: "The :attribute field must not contain :value.",
    min: {
        numeric: "The :attribute field value must be at least :min.",
        string: "The :attribute field length must be at least :min characters.",
        array: "The :attribute field must have at least :min items.",
        file: "The :attribute field file size must be at least :min bytes.",
        files: "The :attribute files sizes must be at least :min bytes.",
    },
    unique: "The :attribute field value must be unique.",
    exists: "The :attribute field value must exist in the dataset.",
    max: {
        numeric: "The :attribute field value must not be greater than :max.",
        string: "The :attribute field length must not be greater than :max characters.",
        array: "The :attribute field must not have more than :max items.",
        file: "The :attribute field file size must not exceed :max bytes.",
        files: "The :attribute files sizes must not exceed :max bytes.",
    },
    image: "The :attribute must be an image.",
    video: "The :attribute must be an video.",
    audio: "The :attribute must be an audio.",
    digits: "The :attribute must be :digits digits.",
    file: "The :attribute must be a file.",
    files: "The :attribute expects at least a file to be selected",
    filled: "The :attribute field must have a value.",
    mimes: "The :attribute must be a file of type: :values.",
    mimetypes: "The :attribute must be a file of type: :values.",
    gt: {
        numeric: "The :attribute field value must be greater than :gt.",
        string: "The :attribute length must be greater than :gt characters.",
        array: "The :attribute must have more than :gt items.",
        file: "The :attribute file size must be greater than :gt bytes.",
        files: "The :attribute files sizes must be greater than :gt bytes.",
    },
    lt: {
        numeric: "The :attribute field value must be less than :lt.",
        string: "The :attribute field length must be less than :lt characters.",
        array: "The :attribute array must have fewer than :lt items.",
        file: "The :attribute file size must be less than :lt bytes.",
        files: "The :attribute files sizes must be less than :lt bytes.",
    },
    gte: {
        numeric: "The :attribute field value must be greater than or equal to :gte.",
        string: "The :attribute field length must be greater than or equal to :gte characters.",
        array: "The :attribute array must have at least :gte items.",
        file: "The :attribute file size must be greater than or equal to :gte bytes.",
        files: "The :attribute files sizes must be greater than or equal to :gte bytes.",
    },
    lte: {
        numeric: "The :attribute field value must be less than or equal to :lte.",
        string: "The :attributee field charater length must be less than or equal to :lte characters.",
        array: "The :attribute field must have at most :lte items.",
        file: "The :attribute field file size must be less than or equal to :lte bytes.",
        files: "The :attribute files sizes must be less than or equal to :lte bytes.",
    },
    alpha: "The :attribute field may only contain alphabets",
    alpha_underscore: "The :attribute field may only contain letters and underscores.",
    alpha_dash:
        "The :attribute field may only contain letters, numbers, dashes, and underscores.",
    alpha_num: "The :attribute field may only contain letters and numbers.",
    boolean: "The :attribute field must be a boolean value.",
    confirmed: "The :attribute field confirmation does not match.",
    between: {
        numeric: "The :attribute field value must be between :min and :max.",
        string: "The length for the :attribute field must be between :min and :max characters.",
        array: "The :attribute field must have between :min and :max items.",
        file: "The file size must be between :min and :max bytes.",
        files: "The files sizes must be between :min and :max bytes.",
    },
    password: {
        length: "The Password must be at least :length characters.",
        letters: "The Password must contain at least one letter.",
        mixed: "The Password must contain at least one uppercase and one lowercase letter.",
        numbers: "The Password must contain at least one number.",
        symbols: "The Password must contain at least one symbol.",
        uncompromised:
            "The given Password has appeared in a data leak. Please choose a different :attribute.",
    },
    email: "The :attribute field must be a valid email address.",
    in_array: "The :attribute field value must be one of the following: :values.",
    in: "The :attribute field value must be one of the following: :values.",
    regex: "The :attribute field format is invalid.",
    same: "The :attribute field must match the :other field.",
    ends_with: "The :attribute field must end with one of the following: :values.",
    starts_with:
        "The :attribute field must start with one of the following: :values.",
    not_in: "The :attribute field value must not be one of the following: :values.",
    required_if: "The :attribute field is required when :other is :value.",
    required: "The :attribute field is required.",
    uppercase: "The :attribute field must be uppercase letters only.",
    lowercase: "The :attribute field must be lowercase letters only.",
    url: "The :attribute field must be a valid URL.",
    uuid: "The :attribute field must be a valid UUID.",
    range: "The :attribute field value must be between :min and :max.",
    multiple_of: "The :attribute field value must be a multiple of :number.",
    active_url: "The :attribute field contain an invalid URL.",
    numeric: "The :attribute field must have a number.",
    pattern: "The :attribute field expected pattern is :pattern",
    required_unless:
        "The :attribute field is required unless :other is in :values.",
    required_with:
        "The :attribute field is required when :values is present.",
    required_with_all:
        "The :attribute field is required when :values are present.",
    required_without:
        "The :attribute field is required when :values is not present.",
    required_without_all:
        "The :attribute field is required when none of :values are present.",
    after: 'The :attribute field must be a date after :date.',
    before: 'The :attribute field must be a date before :date.',
});

/***/ }),

/***/ "./src/locales/es.js":
/*!***************************!*\
  !*** ./src/locales/es.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    accepted: "El campo :attribute debe ser aceptado.",
    date: "El campo debe ser una fecha vlida.",
    url: "El campo debe ser una URL vlida.",
    ip: "El campo debe ser una direccin IP vlida.",
    uuid: "El campo debe ser un UUID vlido.",
    integer: "El campo debe ser un nmero entero.",
    alpha_spaces: "El campo solo puede contener letras y espacios.",
    timezone: "El campo debe ser una zona horaria vlida.",
    credit_card: "El campo debe ser un nmero de tarjeta de crdito vlido.",
    phone: "El campo debe ser un nmero de telfono vlido.",
    contains: "El campo debe contener :value.",
    not_contains: "El campo no debe contener :value.",
    min: {
        numeric: "El valor debe ser al menos :min.",
        string: "El texto debe tener al menos :min caracteres.",
        array: "El arreglo debe tener al menos :min elementos.",
        file: "El archivo debe tener al menos :min bytes.",
        files: "Los archivos deben tener al menos :min bytes.",
    },
    unique: "El valor debe ser nico.",
    exists: "El valor debe existir en el conjunto de datos.",
    max: {
        numeric: "El valor no debe ser mayor que :max.",
        string: "El texto no debe tener ms de :max caracteres.",
        array: "El arreglo no debe tener ms de :max elementos.",
        file: "El archivo no debe exceder :max bytes.",
        files: "Los archivos no deben exceder :max bytes.",
    },
    image: "El campo :attribute debe ser una imagen.",
    video: "El campo :attribute debe ser un video.",
    audio: "El campo :attribute debe ser un audio.",
    digits: "El campo :attribute debe tener :digits dgitos.",
    file: "El campo :attribute debe ser un archivo.",
    files: "El campo :attribute requiere al menos un archivo.",
    filled: "El campo :attribute debe tener un valor.",
    mimes: "El campo :attribute debe ser un archivo de tipo: :values.",
    mimetypes: "El campo :attribute debe ser un archivo de tipo: :values.",
    gt: {
        numeric: "El valor debe ser mayor que :gt.",
        string: "El texto debe tener ms de :gt caracteres.",
        array: "El arreglo debe tener ms de :gt elementos.",
        file: "El archivo debe tener ms de :gt bytes.",
        files: "Los archivos deben tener ms de :gt bytes.",
    },
    lt: {
        numeric: "El valor debe ser menor que :lt.",
        string: "El texto debe tener menos de :lt caracteres.",
        array: "El arreglo debe tener menos de :lt elementos.",
        file: "El archivo debe tener menos de :lt bytes.",
        files: "Los archivos deben tener menos de :lt bytes.",
    },
    gte: {
        numeric: "El valor debe ser mayor o igual a :gte.",
        string: "El texto debe tener al menos :gte caracteres.",
        array: "El arreglo debe tener al menos :gte elementos.",
        file: "El archivo debe tener al menos :gte bytes.",
        files: "Los archivos deben tener al menos :gte bytes.",
    },
    lte: {
        numeric: "El valor debe ser menor o igual a :lte.",
        string: "El texto debe tener como mximo :lte caracteres.",
        array: "El arreglo debe tener como mximo :lte elementos.",
        file: "El archivo debe tener como mximo :lte bytes.",
        files: "Los archivos deben tener como mximo :lte bytes.",
    },
    alpha: "El campo solo puede contener letras.",
    alpha_: "El campo solo puede contener letras y guiones bajos.",
    alpha_dash: "El campo solo puede contener letras, nmeros, guiones y guiones bajos.",
    alpha_num: "El campo solo puede contener letras y nmeros.",
    boolean: "El campo debe ser verdadero o falso.",
    confirmed: "La confirmacin del campo no coincide.",
    between: {
        numeric: "El valor debe estar entre :min y :max.",
        string: "El texto debe tener entre :min y :max caracteres.",
        array: "El arreglo debe tener entre :min y :max elementos.",
        file: "El archivo debe tener entre :min y :max bytes.",
        files: "Los archivos deben tener entre :min y :max bytes.",
    },
    password: {
        length: "La contrasea debe tener al menos :length caracteres.",
        letters: "La contrasea debe contener al menos una letra.",
        mixed: "La contrasea debe contener al menos una letra mayscula y una minscula.",
        numbers: "La contrasea debe contener al menos un nmero.",
        symbols: "La contrasea debe contener al menos un smbolo.",
        uncompromised: "La contrasea elegida ha sido comprometida en una fuga de datos. Elija otra contrasea.",
    },
    email: "El campo debe ser una direccin de correo vlida.",
    in_array: "El valor del campo debe ser uno de los siguientes: :values.",
    in: "El valor del campo debe ser uno de los siguientes: :values.",
    regex: "El formato del campo es invlido.",
    same: "El campo debe coincidir con el campo :other.",
    ends_with: "El campo debe terminar con uno de los siguientes: :values.",
    starts_with: "El campo debe comenzar con uno de los siguientes: :values.",
    not_in: "El valor del campo no debe ser uno de los siguientes: :values.",
    required_if: "El campo es obligatorio cuando :other es :value.",
    required: "El campo es obligatorio.",
    uppercase: "El campo debe estar en letras maysculas.",
    lowercase: "El campo debe estar en letras minsculas.",
    url: "El campo debe ser una URL vlida.",
    uuid: "El campo debe ser un UUID vlido.",
    range: "El valor debe estar entre :min y :max.",
    multiple_of: "El valor debe ser un mltiplo de :number.",
    active_url: "El campo :attribute no es una URL vlida.",
    numeric: "El campo :attribute debe ser un nmero.",
    pattern: "El patrn esperado es :pattern.",
    required_unless: "El campo :attribute es obligatorio, a menos que :other est en :values.",
    required_with: "El campo :attribute es obligatorio cuando :values est presente.",
    required_with_all: "El campo :attribute es obligatorio cuando :values estn presentes.",
    required_without: "El campo :attribute es obligatorio cuando :values no est presente.",
    required_without_all: "El campo :attribute es obligatorio cuando ninguno de :values estn presentes.",
    after: "El campo :attribute debe ser una fecha posterior a :date.",
    before: "El campo :attribute debe ser una fecha anterior a :date.",
});

/***/ }),

/***/ "./src/locales/fr.js":
/*!***************************!*\
  !*** ./src/locales/fr.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    accepted: "Le champ :attribute doit tre accept.",
    date: "Le champ doit tre une date valide.",
    url: "Le champ doit tre une URL valide.",
    ip: "Le champ doit tre une adresse IP valide.",
    uuid: "Le champ doit tre un UUID valide.",
    integer: "Le champ doit tre un entier.",
    alpha_spaces: "Le champ ne peut contenir que des lettres et des espaces.",
    timezone: "Le champ doit tre un fuseau horaire valide.",
    credit_card: "Le champ doit tre un numro de carte de crdit valide.",
    phone: "Le champ doit tre un numro de tlphone valide.",
    contains: "Le champ doit contenir :value.",
    not_contains: "Le champ ne doit pas contenir :value.",
    min: {
        numeric: "La valeur doit tre au moins :min.",
        string: "La longueur doit tre d'au moins :min caractres.",
        array: "Le tableau doit avoir au moins :min lments.",
        file: "La taille du fichier doit tre d'au moins :min octets.",
        files: "Les tailles des fichiers doivent tre d'au moins :min octets.",
    },
    unique: "La valeur doit tre unique.",
    exists: "La valeur doit exister dans le jeu de donnes.",
    max: {
        numeric: "La valeur ne doit pas tre suprieure  :max.",
        string: "La longueur ne doit pas dpasser :max caractres.",
        array: "Le tableau ne doit pas avoir plus de :max lments.",
        file: "La taille du fichier ne doit pas dpasser :max octets.",
        files: "Les tailles des fichiers ne doivent pas dpasser :max octets.",
    },
    image: "Le champ :attribute doit tre une image.",
    video: "Le champ :attribute doit tre une vido.",
    audio: "Le champ :attribute doit tre un fichier audio.",
    digits: "Le champ :attribute doit contenir :digits chiffres.",
    file: "Le champ :attribute doit tre un fichier.",
    files: "Le champ :attribute doit contenir au moins un fichier.",
    filled: "Le champ :attribute doit avoir une valeur.",
    mimes: "Le champ :attribute doit tre un fichier de type: :values.",
    mimetypes: "Le champ :attribute doit tre un fichier de type: :values.",
    gt: {
        numeric: "La valeur doit tre suprieure  :gt.",
        string: "La longueur doit tre suprieure  :gt caractres.",
        array: "Le tableau doit avoir plus de :gt lments.",
        file: "La taille du fichier doit tre suprieure  :gt octets.",
        files: "Les tailles des fichiers doivent tre suprieures  :gt octets.",
    },
    lt: {
        numeric: "La valeur doit tre infrieure  :lt.",
        string: "La longueur doit tre infrieure  :lt caractres.",
        array: "Le tableau doit avoir moins de :lt lments.",
        file: "La taille du fichier doit tre infrieure  :lt octets.",
        files: "Les tailles des fichiers doivent tre infrieures  :lt octets.",
    },
    gte: {
        numeric: "La valeur doit tre suprieure ou gale  :gte.",
        string: "La longueur doit tre suprieure ou gale  :gte caractres.",
        array: "Le tableau doit avoir au moins :gte lments.",
        file: "La taille du fichier doit tre suprieure ou gale  :gte octets.",
        files: "Les tailles des fichiers doivent tre suprieures ou gales  :gte octets.",
    },
    lte: {
        numeric: "La valeur doit tre infrieure ou gale  :lte.",
        string: "La longueur doit tre infrieure ou gale  :lte caractres.",
        array: "Le tableau doit avoir au plus :lte lments.",
        file: "La taille du fichier doit tre infrieure ou gale  :lte octets.",
        files: "Les tailles des fichiers doivent tre infrieures ou gales  :lte octets.",
    },
    alpha: "Le champ ne peut contenir que des lettres.",
    alpha_: "Le champ ne peut contenir que des lettres et des tirets bas.",
    alpha_dash: "Le champ ne peut contenir que des lettres, des chiffres, des tirets et des tirets bas.",
    alpha_num: "Le champ ne peut contenir que des lettres et des chiffres.",
    boolean: "Le champ doit tre une valeur boolenne.",
    confirmed: "La confirmation du champ ne correspond pas.",
    between: {
        numeric: "La valeur doit tre entre :min et :max.",
                string: "La longueur doit tre comprise entre :min et :max caractres.",
        array: "Le tableau doit contenir entre :min et :max lments.",
        file: "La taille du fichier doit tre comprise entre :min et :max octets.",
        files: "Les tailles des fichiers doivent tre comprises entre :min et :max octets.",
    },
    password: {
        length: "Le mot de passe doit contenir au moins :length caractres.",
        letters: "Le mot de passe doit contenir au moins une lettre.",
        mixed: "Le mot de passe doit contenir au moins une majuscule et une minuscule.",
        numbers: "Le mot de passe doit contenir au moins un chiffre.",
        symbols: "Le mot de passe doit contenir au moins un symbole.",
        uncompromised: "Le mot de passe fourni a t trouv dans une fuite de donnes. Veuillez en choisir un autre.",
    },
    email: "Le champ doit tre une adresse e-mail valide.",
    in_array: "La valeur du champ doit tre l'une des suivantes : :values.",
    in: "La valeur du champ doit tre l'une des suivantes : :values.",
    regex: "Le format du champ est invalide.",
    same: "Le champ doit correspondre au champ :other.",
    ends_with: "Le champ doit se terminer par l'une des valeurs suivantes : :values.",
    starts_with: "Le champ doit commencer par l'une des valeurs suivantes : :values.",
    not_in: "La valeur du champ ne doit pas tre l'une des suivantes : :values.",
    required_if: "Le champ est requis si :other est gal  :value.",
    required: "Le champ est requis.",
    uppercase: "Le champ ne peut contenir que des lettres majuscules.",
    lowercase: "Le champ ne peut contenir que des lettres minuscules.",
    url: "Le champ doit tre une URL valide.",
    uuid: "Le champ doit tre un UUID valide.",
    range: "La valeur doit tre comprise entre :min et :max.",
    multiple_of: "La valeur doit tre un multiple de :number.",
    active_url: "Le champ :attribute n'est pas une URL valide.",
    numeric: "Le champ :attribute doit tre un nombre.",
    pattern: "Le modle attendu est :pattern.",
    required_unless: "Le champ :attribute est requis  moins que :other ne soit dans :values.",
    required_with: "Le champ :attribute est requis lorsque :values est prsent.",
    required_with_all: "Le champ :attribute est requis lorsque :values sont prsents.",
    required_without: "Le champ :attribute est requis lorsque :values est absent.",
    required_without_all: "Le champ :attribute est requis lorsque aucun des :values n'est prsent.",
    after: "Le champ :attribute doit tre une date postrieure  :date.",
    before: "Le champ :attribute doit tre une date antrieure  :date.",
});

/***/ }),

/***/ "./src/locales/hi.js":
/*!***************************!*\
  !*** ./src/locales/hi.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    accepted: "      ",
    date: "     ",
    url: "     ",
    ip: "      ",
    uuid: "     ",
    integer: "    ",
    alpha_spaces: "        ",
    timezone: "     ",
    credit_card: "       ",
    phone: "      ",
    contains: "  :value   ",
    not_contains: "  :value    ",
    min: {
        numeric: "    :min  ",
        string: "    :min   ",
        array: "     :min   ",
        file: "      :min   ",
        files: "      :min   ",
    },
    unique: "   ",
    exists: "     ",
    max: {
        numeric: " :max     ",
        string: " :max      ",
        array: "  :max      ",
        file: "   :max      ",
        files: "   :max      ",
    },
    image: ":attribute    ",
    video: ":attribute    ",
    audio: ":attribute    ",
    digits: ":attribute :digits   ",
    file: ":attribute    ",
    files: ":attribute          ",
    filled: ":attribute     ",
    mimes: ":attribute   :values     ",
    mimetypes: ":attribute   :values     ",
    gt: {
        numeric: " :gt    ",
        string: " :gt     ",
        array: "  :gt     ",
        file: "   :gt     ",
        files: "   :gt     ",
    },
    lt: {
        numeric: " :lt    ",
        string: " :lt     ",
        array: "  :lt     ",
        file: "   :lt     ",
        files: "   :lt     ",
    },
    gte: {
        numeric: " :gte      ",
        string: " :gte       ",
        array: "     :gte   ",
        file: "   :gte       ",
        files: "   :gte       ",
    },
    lte: {
        numeric: " :lte      ",
        string: " :lte       ",
        array: "   :lte   ",
        file: "   :lte       ",
        files: "   :lte       ",
    },
    alpha: "      ",
    alpha_: "        ",
    alpha_dash: "   , ,      ",
    alpha_num: "        ",
    boolean: "     ",
    confirmed: "     ",
    between: {
        numeric: " :min  :max    ",
        string: " :min  :max     ",
        array: "  :min  :max   ",
        file: "   :min  :max     ",
        files: "   :min  :max     ",
    },
    password: {
        length: "    :length    ",
        letters: "        ",
        mixed: "            ",
        numbers: "        ",
        symbols: "        ",
        uncompromised: "            ",
    },
    email: "   -   ",
    in_array: "        : :values",
    in: "        : :values",
    regex: "    ",
    same: "  :other     ",
    ends_with: "         : :values",
    starts_with: "        : :values",
    not_in: "         : :values",
    required_if: "     :other :value ",
    required: "   ",
    uppercase: "      ",
    lowercase: "      ",
    range: " :min  :max    ",
    multiple_of: " :number    ",
    active_url: ":attribute     ",
    numeric: ":attribute    ",
    pattern: "  :pattern ",
    required_unless: ":attribute     :other  :values  ",
    required_with: ":attribute    :values  ",
    required_with_all: ":attribute    :values  ",
    required_without: ":attribute    :values   ",
    required_without_all: ":attribute    :values       ",
    after: ":attribute   :date    ",
    before: ":attribute   :date    ",
});

/***/ }),

/***/ "./src/locales/ig.js":
/*!***************************!*\
  !*** ./src/locales/ig.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    accepted: "A ga-anabata :attribute.",
    date: "E kwes ka  br bch d ir.",
    url: "E kwes ka  br URL d ir.",
    ip: "E kwes ka  br adrees IP d ir.",
    uuid: "E kwes ka  br UUID d ir.",
    integer: "E kwes ka  br nmba zuru oke.",
    alpha_spaces: "E kwes ka  br mkprokwu na oghere naan.",
    timezone: "E kwes ka  br oge mpaghara d ir.",
    credit_card: "E kwes ka  br nmba kaad kredit d ir.",
    phone: "E kwes ka  br nmba ekwent d ir.",
    contains: "A ga-enwe :value na ihe a.",
    not_contains: "Ekwesgh inwe :value na ihe a.",
    min: {
        numeric: "n aha kwesr dkara ala :min.",
        string: "Ogo kwesr dkara ala :min mkprokwu.",
        array: "A ga-enwe ihe dkara ala :min n'ime.",
        file: "Nha fal kwesr dkara ala :min byte.",
        files: "Nha fal kwesr dkara ala :min byte.",
    },
    unique: "n aha kwesr d iche.",
    exists: "n aha kwesr d n'ime dataset.",
    max: {
        numeric: "n aha enwegh ike b ihe karr :max.",
        string: "Ogo enwegh ike dkarr :max mkprokwu.",
        array: "N'ime enwegh ike inwe ihe karr :max.",
        file: "Nha fal agagh agakarr :max byte.",
        files: "Nha fal agagh agakarr :max byte.",
    },
    image: "E kwes ka :attribute br onyonyo.",
    video: "E kwes ka :attribute br vidio.",
    audio: "E kwes ka :attribute br da.",
    digits: "E kwes ka :attribute br :digits ng.",
    file: "E kwes ka :attribute br fal.",
    files: " dkarr ala fal ga-ahpta maka :attribute.",
    filled: "A ga-enwe kpr maka :attribute.",
    mimes: "E kwes ka fal ah br d: :values.",
    mimetypes: "E kwes ka fal ah br d: :values.",
    gt: {
        numeric: "n aha kwesr d ihe karr :gt.",
        string: "Ogo kwesr d ihe karr :gt mkprokwu.",
        array: "N'ime kwesr inwe ihe dkara ala kara :gt.",
        file: "Nha fal kwesr d ihe karr :gt byte.",
        files: "Nha fal kwesr d ihe karr :gt byte.",
    },
    lt: {
        numeric: "n aha kwesr d ala kara :lt.",
        string: "Ogo kwesr d ala kara :lt mkprokwu.",
        array: "N'ime kwesr inwe ihe d ala kara :lt.",
        file: "Nha fal kwesr d ala kara :lt byte.",
        files: "Nha fal kwesr d ala kara :lt byte.",
    },
    gte: {
        numeric: "n aha kwesr d elu ma  b tlite :gte.",
        string: "Ogo kwesr d elu ma  b tlite :gte mkprokwu.",
        array: "N'ime kwesr inwe ihe dkara ala :gte.",
        file: "Nha fal kwesr d elu ma  b tlite :gte byte.",
        files: "Nha fal kwesr d elu ma  b tlite :gte byte.",
    },
    lte: {
        numeric: "n aha kwesr d ala ma  b tlite :lte.",
        string: "Ogo kwesr d ala ma  b tlite :lte mkprokwu.",
        array: "N'ime kwesr nwe ihe kachas mma :lte.",
        file: "Nha fal kwesr d ala ma  b tlite :lte byte.",
        files: "Nha fal kwesr d ala ma  b tlite :lte byte.",
    },
    alpha: "E kwes ka :attribute b mkprokwu naan.",
    alpha_: "E kwes ka  br mkpredemede na kp dda.",
    alpha_dash: "E kwes ka  br mkprokwu, ng, kp dda na kp isi.",
    alpha_num: "E kwes ka  br mkprokwu na ng.",
    boolean: "E kwes ka  br kpr boleean.",
    confirmed: "Nkwenye ah adgh daktara.",
    between: {
        numeric: "n aha kwesr d n'etiti :min na :max.",
        string: "Ogo kwesr d n'etiti :min na :max mkprokwu.",
        array: "N'ime kwesr inwe ihe n'etiti :min na :max.",
        file: "Nha fal kwesr d n'etiti :min na :max byte.",
        files: "Nha fal kwesr d n'etiti :min na :max byte.",
    },
    password: {
        length: "Ogo okwuntughe kwesiri dkara ala :length mkprokwu.",
        letters: "Okwuntughe kwesr inwe otu mkpredemede ma  dkara ala.",
        mixed: "Okwuntughe kwesr inwe mkpredemede elu na ala.",
        numbers: "Okwuntughe kwesr inwe otu ng ma  dkara ala.",
        symbols: "Okwuntughe kwesr inwe otu akara pr iche.",
        uncompromised: "Okwuntughe a aptala n'efu data. Hr ihe z.",
    },
    email: "E kwes ka  br adrees ozi-e d ir.",
    in_array: "n aha kwesr b otu n'ime: :values.",
    in: "n aha kwesr b otu n'ime: :values.",
    regex: "Usoro :attribute ezighi ezi.",
    same: "A ga-edozi ya na :other.",
    ends_with: "A ga-ejedebe na otu n'ime nd a: :values.",
    starts_with: "A ga-amalite na otu n'ime nd a: :values.",
    not_in: "Ekwesighi b otu n'ime :values.",
    required_if: " d mkpa ma  br na :other b :value.",
    required: " d mkpa.",
    uppercase: "E kwes ka  br mkprokwu d elu.",
    lowercase: "E kwes ka  br mkprokwu d ala.",
    url: "E kwes ka  br URL d ir.",
    uuid: "E kwes ka  br UUID d ir.",
    range: "n aha kwesr d n'etiti :min na :max.",
    multiple_of: "E kwes ka  br tt :number.",
    active_url: "E kwes ka :attribute br URL d ir.",
    numeric: "E kwes ka  br ng.",
    pattern: "E kwes ka usoro d :pattern.",
    required_unless: "A chr ya bels ma :other d na :values.",
    required_with: " d mkpa mgbe :values d.",
    required_with_all: " d mkpa mgbe niile :values d.",
    required_without: " d mkpa mgbe :values adgh.",
    required_without_all: " d mkpa mgbe ihe  bla n'ime :values adgh.",
    after: "E kwes ka :attribute br bch mgbe :date gasr.",
    before: "E kwes ka :attribute br bch tupu :date.",
});

/***/ }),

/***/ "./src/locales/lt.js":
/*!***************************!*\
  !*** ./src/locales/lt.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    accepted: "Il campo :attribute deve essere accettato.",
    date: "Il campo deve essere una data valida.",
    url: "Il campo deve essere un URL valido.",
    ip: "Il campo deve essere un indirizzo IP valido.",
    uuid: "Il campo deve essere un UUID valido.",
    integer: "Il campo deve essere un numero intero.",
    alpha_spaces: "Il campo pu contenere solo lettere e spazi.",
    timezone: "Il campo deve essere un fuso orario valido.",
    credit_card: "Il campo deve essere un numero di carta di credito valido.",
    phone: "Il campo deve essere un numero di telefono valido.",
    contains: "Il campo deve contenere :value.",
    not_contains: "Il campo non deve contenere :value.",
    min: {
        numeric: "Il valore deve essere almeno :min.",
        string: "La lunghezza deve essere di almeno :min caratteri.",
        array: "L'array deve contenere almeno :min elementi.",
        file: "La dimensione del file deve essere di almeno :min byte.",
        files: "Le dimensioni dei file devono essere di almeno :min byte.",
    },
    unique: "Il valore deve essere unico.",
    exists: "Il valore deve esistere nel set di dati.",
    max: {
        numeric: "Il valore non deve essere maggiore di :max.",
        string: "La lunghezza non deve superare :max caratteri.",
        array: "L'array non deve avere pi di :max elementi.",
        file: "La dimensione del file non deve superare :max byte.",
        files: "Le dimensioni dei file non devono superare :max byte.",
    },
    image: "Il campo :attribute deve essere un'immagine.",
    video: "Il campo :attribute deve essere un video.",
    audio: "Il campo :attribute deve essere un file audio.",
    digits: "Il campo :attribute deve contenere :digits cifre.",
    file: "Il campo :attribute deve essere un file.",
    files: "Il campo :attribute deve contenere almeno un file.",
    filled: "Il campo :attribute deve avere un valore.",
    mimes: "Il campo :attribute deve essere un file di tipo: :values.",
    mimetypes: "Il campo :attribute deve essere un file di tipo: :values.",
    gt: {
        numeric: "Il valore deve essere maggiore di :gt.",
        string: "La lunghezza deve essere maggiore di :gt caratteri.",
        array: "L'array deve avere pi di :gt elementi.",
        file: "La dimensione del file deve essere maggiore di :gt byte.",
        files: "Le dimensioni dei file devono essere maggiori di :gt byte.",
    },
    lt: {
        numeric: "Il valore deve essere minore di :lt.",
        string: "La lunghezza deve essere minore di :lt caratteri.",
        array: "L'array deve avere meno di :lt elementi.",
        file: "La dimensione del file deve essere minore di :lt byte.",
        files: "Le dimensioni dei file devono essere minori di :lt byte.",
    },
    gte: {
        numeric: "Il valore deve essere maggiore o uguale a :gte.",
        string: "La lunghezza deve essere maggiore o uguale a :gte caratteri.",
        array: "L'array deve contenere almeno :gte elementi.",
        file: "La dimensione del file deve essere maggiore o uguale a :gte byte.",
        files: "Le dimensioni dei file devono essere maggiori o uguali a :gte byte.",
    },
    lte: {
        numeric: "Il valore deve essere minore o uguale a :lte.",
        string: "La lunghezza deve essere minore o uguale a :lte caratteri.",
        array: "L'array non deve avere pi di :lte elementi.",
        file: "La dimensione del file deve essere minore o uguale a :lte byte.",
        files: "Le dimensioni dei file devono essere minori o uguali a :lte byte.",
    },
    alpha: "Il campo pu contenere solo lettere.",
    alpha_: "Il campo pu contenere solo lettere e trattini bassi.",
    alpha_dash: "Il campo pu contenere solo lettere, numeri, trattini e trattini bassi.",
    alpha_num: "Il campo pu contenere solo lettere e numeri.",
    boolean: "Il campo deve essere un valore booleano.",
    confirmed: "La conferma del campo non corrisponde.",
    between: {
        numeric: "Il valore deve essere compreso tra :min e :max.",
        string: "La lunghezza deve essere compresa tra :min e :max caratteri.",
        array: "L'array deve contenere tra :min e :max elementi.",
        file: "La dimensione del file deve essere compresa tra :min e :max byte.",
        files: "Le dimensioni dei file devono essere comprese tra :min e :max byte.",
    },
    password: {
        length: "La password deve contenere almeno :length caratteri.",
        letters: "La password deve contenere almeno una lettera.",
        mixed: "La password deve contenere almeno una maiuscola e una minuscola.",
        numbers: "La password deve contenere almeno un numero.",
        symbols: "La password deve contenere almeno un simbolo.",
        uncompromised: "La password fornita  apparsa in una violazione dei dati. Scegli un'altra.",
    },
    email: "Il campo deve essere un indirizzo email valido.",
    in_array: "Il valore del campo deve essere uno dei seguenti: :values.",
    in: "Il valore del campo deve essere uno dei seguenti: :values.",
    regex: "Il formato del campo  non valido.",
    same: "Il campo deve corrispondere al campo :other.",
    ends_with: "Il campo deve terminare con uno dei seguenti: :values.",
    starts_with: "Il campo deve iniziare con uno dei seguenti: :values.",
    not_in: "Il valore del campo non deve essere uno dei seguenti: :values.",
    required_if: "Il campo  richiesto se :other  uguale a :value.",
    required: "Il campo  richiesto.",
    uppercase: "Il campo pu contenere solo lettere maiuscole.",
    lowercase: "Il campo pu contenere solo lettere minuscole.",
    url: "Il campo deve essere un URL valido.",
    uuid: "Il campo deve essere un UUID valido.",
    range: "Il valore deve essere compreso tra :min e :max.",
    multiple_of: "Il valore deve essere un multiplo di :number.",
    active_url: "Il campo :attribute non  un URL valido.",
    numeric: "Il campo :attribute deve essere un numero.",
    pattern: "Il modello previsto  :pattern.",
    required_unless: "Il campo :attribute  richiesto a meno che :other non sia in :values.",
    required_with: "Il campo :attribute  richiesto quando :values  presente.",
    required_with_all: "Il campo :attribute  richiesto quando :values sono presenti.",
    required_without: "Il campo :attribute  richiesto quando :values  assente.",
    required_without_all: "Il campo :attribute  richiesto quando nessuno dei :values  presente.",
    after: "Il campo :attribute deve essere una data successiva a :date.",
    before: "Il campo :attribute deve essere una data precedente a :date.",
});

/***/ }),

/***/ "./src/locales/pt.js":
/*!***************************!*\
  !*** ./src/locales/pt.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    accepted: "O campo :attribute deve ser aceito.",
    date: "O campo deve ser uma data vlida.",
    url: "O campo deve ser uma URL vlida.",
    ip: "O campo deve ser um endereo IP vlido.",
    uuid: "O campo deve ser um UUID vlido.",
    integer: "O campo deve ser um nmero inteiro.",
    alpha_spaces: "O campo s pode conter letras e espaos.",
    timezone: "O campo deve ser um fuso horrio vlido.",
    credit_card: "O campo deve ser um nmero de carto de crdito vlido.",
    phone: "O campo deve ser um nmero de telefone vlido.",
    contains: "O campo deve conter :value.",
    not_contains: "O campo no deve conter :value.",
    min: {
        numeric: "O valor deve ser no mnimo :min.",
        string: "O texto deve ter no mnimo :min caracteres.",
        array: "O array deve ter no mnimo :min itens.",
        file: "O arquivo deve ter no mnimo :min bytes.",
        files: "Os arquivos devem ter no mnimo :min bytes.",
    },
    unique: "O valor deve ser nico.",
    exists: "O valor deve existir no conjunto de dados.",
    max: {
        numeric: "O valor no pode ser maior que :max.",
        string: "O texto no pode ter mais que :max caracteres.",
        array: "O array no pode ter mais que :max itens.",
        file: "O arquivo no pode ser maior que :max bytes.",
        files: "Os arquivos no podem ser maiores que :max bytes.",
    },
    image: "O campo :attribute deve ser uma imagem.",
    video: "O campo :attribute deve ser um vdeo.",
    audio: "O campo :attribute deve ser um udio.",
    digits: "O campo :attribute deve ter :digits dgitos.",
    file: "O campo :attribute deve ser um arquivo.",
    files: " necessrio selecionar pelo menos um arquivo no campo :attribute.",
    filled: "O campo :attribute deve ter um valor.",
    mimes: "O campo :attribute deve ser um arquivo do tipo: :values.",
    mimetypes: "O campo :attribute deve ser um arquivo do tipo: :values.",
    gt: {
        numeric: "O valor deve ser maior que :gt.",
        string: "O texto deve ter mais de :gt caracteres.",
        array: "O array deve ter mais de :gt itens.",
        file: "O arquivo deve ter mais de :gt bytes.",
        files: "Os arquivos devem ter mais de :gt bytes.",
    },
    lt: {
        numeric: "O valor deve ser menor que :lt.",
        string: "O texto deve ter menos de :lt caracteres.",
        array: "O array deve ter menos de :lt itens.",
        file: "O arquivo deve ter menos de :lt bytes.",
        files: "Os arquivos devem ter menos de :lt bytes.",
    },
    gte: {
        numeric: "O valor deve ser maior ou igual a :gte.",
        string: "O texto deve ter no mnimo :gte caracteres.",
        array: "O array deve ter no mnimo :gte itens.",
        file: "O arquivo deve ter no mnimo :gte bytes.",
        files: "Os arquivos devem ter no mnimo :gte bytes.",
    },
    lte: {
        numeric: "O valor deve ser menor ou igual a :lte.",
        string: "O texto deve ter no mximo :lte caracteres.",
        array: "O array deve ter no mximo :lte itens.",
        file: "O arquivo deve ter no mximo :lte bytes.",
        files: "Os arquivos devem ter no mximo :lte bytes.",
    },
    alpha: "O campo s pode conter letras.",
    alpha_: "O campo s pode conter letras e sublinhados.",
    alpha_dash: "O campo s pode conter letras, nmeros, traos e sublinhados.",
    alpha_num: "O campo s pode conter letras e nmeros.",
    boolean: "O campo deve ser verdadeiro ou falso.",
    confirmed: "A confirmao do campo no confere.",
    between: {
        numeric: "O valor deve estar entre :min e :max.",
        string: "O texto deve ter entre :min e :max caracteres.",
        array: "O array deve ter entre :min e :max itens.",
        file: "O arquivo deve ter entre :min e :max bytes.",
        files: "Os arquivos devem ter entre :min e :max bytes.",
    },
    password: {
        length: "A senha deve ter no mnimo :length caracteres.",
        letters: "A senha deve conter pelo menos uma letra.",
        mixed: "A senha deve conter pelo menos uma letra maiscula e uma minscula.",
        numbers: "A senha deve conter pelo menos um nmero.",
        symbols: "A senha deve conter pelo menos um smbolo.",
        uncompromised: "A senha escolhida foi encontrada em um vazamento de dados. Escolha uma senha diferente.",
    },
    email: "O campo deve ser um endereo de e-mail vlido.",
    in_array: "O valor do campo deve ser um dos seguintes: :values.",
    in: "O valor do campo deve ser um dos seguintes: :values.",
    regex: "O formato do campo  invlido.",
    same: "O campo deve corresponder ao campo :other.",
    ends_with: "O campo deve terminar com um dos seguintes: :values.",
    starts_with: "O campo deve comear com um dos seguintes: :values.",
    not_in: "O valor do campo no deve ser um dos seguintes: :values.",
    required_if: "O campo  obrigatrio quando :other  :value.",
    required: "O campo  obrigatrio.",
    uppercase: "O campo deve estar em letras maisculas.",
    lowercase: "O campo deve estar em letras minsculas.",
    url: "O campo deve ser uma URL vlida.",
    uuid: "O campo deve ser um UUID vlido.",
    range: "O valor deve estar entre :min e :max.",
    multiple_of: "O valor deve ser um mltiplo de :number.",
    active_url: "O campo :attribute no  uma URL vlida.",
    numeric: "O campo :attribute deve ser um nmero.",
    pattern: "O formato esperado  :pattern",
    required_unless: "O campo :attribute  obrigatrio, a menos que :other esteja em :values.",
    required_with: "O campo :attribute  obrigatrio quando :values est presente.",
    required_with_all: "O campo :attribute  obrigatrio quando :values esto presentes.",
    required_without: "O campo :attribute  obrigatrio quando :values no est presente.",
    required_without_all: "O campo :attribute  obrigatrio quando nenhum de :values esto presentes.",
    after: 'O campo :attribute deve ser uma data aps :date.',
    before: 'O campo :attribute deve ser uma data antes de :date.',
});

/***/ }),

/***/ "./src/locales/ru.js":
/*!***************************!*\
  !*** ./src/locales/ru.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    accepted: " :attribute   .",
    date: "    .",
    url: "    URL-.",
    ip: "    IP-.",
    uuid: "    UUID.",
    integer: "    .",
    alpha_spaces: "      .",
    timezone: "     .",
    credit_card: "      .",
    phone: "     .",
    contains: "   :value.",
    not_contains: "    :value.",
    min: {
        numeric: "     :min.",
        string: "     :min .",
        array: "     :min .",
        file: "      :min .",
        files: "      :min .",
    },
    unique: "   .",
    exists: "     .",
    max: {
        numeric: "    :max.",
        string: "    :max .",
        array: "     :max .",
        file: "     :max .",
        files: "     :max .",
    },
    image: " :attribute   .",
    video: " :attribute   .",
    audio: " :attribute   .",
    digits: " :attribute   :digits .",
    file: " :attribute   .",
    files: " :attribute     .",
    filled: " :attribute   .",
    mimes: " :attribute    : :values.",
    mimetypes: " :attribute    : :values.",
    gt: {
        numeric: "    :gt.",
        string: "    :gt .",
        array: "    :gt .",
        file: "     :gt .",
        files: "     :gt .",
    },
    lt: {
        numeric: "    :lt.",
        string: "    :lt .",
        array: "    :lt .",
        file: "     :lt .",
        files: "     :lt .",
    },
    gte: {
        numeric: "      :gte.",
        string: "      :gte .",
        array: "     :gte .",
        file: "       :gte .",
        files: "       :gte .",
    },
    lte: {
        numeric: "      :lte.",
        string: "      :lte .",
        array: "     :lte .",
        file: "       :lte .",
        files: "       :lte .",
    },
    alpha: "    .",
    alpha_: "      .",
    alpha_dash: "    , ,   .",
    alpha_num: "      .",
    boolean: "    .",
    confirmed: "   .",
    between: {
        numeric: "    :min  :max.",
        string: "    :min  :max .",
        array: "    :min  :max .",
        file: "     :min  :max .",
        files: "     :min  :max .",
    },
    password: {
        length: "     :length .",
        letters: "      .",
        mixed: "          .",
        numbers: "      .",
        symbols: "      .",
        uncompromised: "     . ,   :attribute.",
    },
    email: "      .",
    in_array: "      : :values.",
    in: "      : :values.",
    regex: "  .",
    same: "    :other.",
    ends_with: "      : :values.",
    starts_with: "      : :values.",
    not_in: "       : :values.",
    required_if: " ,  :other  :value.",
    required: " .",
    uppercase: "     .",
    lowercase: "     .",
    url: "    URL-.",
    uuid: "    UUID.",
    range: "    :min  :max.",
    multiple_of: "    :number.",
    active_url: " :attribute    URL.",
    numeric: " :attribute   .",
    pattern: " : :pattern.",
    required_unless: " :attribute ,  :other    :values.",
    required_with: " :attribute ,  :values .",
    required_with_all: " :attribute ,  :values .",
    required_without: " :attribute ,  :values .",
    required_without_all: " :attribute ,     :values  .",
    after: " :attribute     :date.",
    before: " :attribute     :date.",
});

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be isolated against other modules in the chunk.
(() => {
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _core_main__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core/main */ "./src/core/main/index.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core/utils */ "./src/core/utils/index.js");
/* harmony import */ var _core_cookie__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./core/cookie */ "./src/core/cookie/index.js");




const cookie = _core_cookie__WEBPACK_IMPORTED_MODULE_2__["default"];
const utils = _core_utils__WEBPACK_IMPORTED_MODULE_1__["default"];
const FormGuard = _core_main__WEBPACK_IMPORTED_MODULE_0__.FormGuard;


// Assign to the global object (window in the browser or exports in Node.js)
if (typeof window !== 'undefined') {
  window.FormGuard = FormGuard;
} else if (typeof exports !== 'undefined') {
  exports.cookie = cookie;
  exports.utils = utils;
  exports.FormGuard = FormGuard;
}

  
// export { cookie, utils, FormGuard };
})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=fGuard.min.js.map